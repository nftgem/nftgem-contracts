// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "../interfaces/ISwapMeetV2.sol";

import "../access/Controllable.sol";

import "../interfaces/INFTGemMultiToken.sol";

import "../interfaces/INFTComplexGemPoolData.sol";

import "../interfaces/INFTGemFeeManager.sol";

import "../interfaces/IWrappedFtm.sol";

import "../libs/UInt256Set.sol";

contract SwapMeet is ISwapMeetV2, Controllable {
    address private auctionMaster;
    using UInt256Set for UInt256Set.Set;

    uint256 public constant listingFeeHash =
        uint256(keccak256("swapMeetListingFee"));
    uint256 public constant acceptFeeHash =
        uint256(keccak256("swapMeetAcceptFee"));
    uint256 public constant acceptVariableFeeHash =
        uint256(keccak256("swapMeetAcceptVariableFee"));
    uint256 public constant bidFeeHash = uint256(keccak256("bidFee"));

    address private constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;

    bool internal open;

    INFTGemFeeManager internal feeManager;
    INFTGemMultiToken internal multitoken;

    // all the offers in this contract
    mapping(uint256 => Offer) internal offers;

    // all the offers bids in this contract
    mapping(uint256 => Bid[]) internal offerBids;

    // all the offer but by owner
    mapping(address => Offer[]) internal offersByOwner;

    UInt256Set.Set internal offerIds;

    // proxy mapping manages alloewances w/o owner
    mapping(address => address) internal proxyList;

    constructor(
        address _multitoken,
        address _feeManager,
        address _auctionMaster
    ) {
        _addController(msg.sender);
        multitoken = INFTGemMultiToken(_multitoken);
        feeManager = INFTGemFeeManager(_feeManager);
        auctionMaster = _auctionMaster;
        open = true;
    }

    // register a new offer
    function registerOffer(
        // what to have to swap
        address _pool,
        uint256 _gem,
        // what you are willing to swap it for
        address[] calldata _pools,
        uint256[] calldata _gems,
        uint256[] calldata _quantities,
        uint256 references,
        uint256 _blockCount,
        bool _wethOnly
    )
        external
        payable
        override
        returns (uint256 _offerId, Offer memory _offer)
    {
        require(open, "swap meet closed");

        // get the listing fee - the service is a flat fee
        uint256 listingFee = INFTGemFeeManager(feeManager).fee(listingFeeHash);
        listingFee = listingFee == 0 ? 0.01 ether : listingFee;

        // an offer is offerer address plus gem hash
        _offerId = uint256(keccak256(abi.encodePacked(msg.sender, _gem)));

        // basic sanity checks
        require(!offerIds.exists(_offerId), "gem already registered");
        require(_gems.length == _pools.length, "mismatched gem quantities");
        require(msg.value >= listingFee, "insufficient listing fee");

        // if wethOnly is set, then the offer is only acceptable using weth
        if (offers[_offerId].wethOnly) {
            require(
                _pools.length == 0 &&
                    _gems.length == 0 &&
                    _quantities.length == 1,
                "not a token sale or auction"
            );
        }

        // make sure they own the gem they wanna trade
        require(
            IERC1155(address(multitoken)).balanceOf(msg.sender, _gem) > 0,
            "insufficient gem balance"
        );

        // make sure the gem is of the specified pool
        INFTGemMultiToken.TokenType tt = INFTComplexGemPoolData(_pool)
            .tokenType(_gem);

        // require that the gem be from this pool
        require(tt == INFTGemMultiToken.TokenType.GEM, "invalid token type");

        // make sure the pool addresses are valid and that
        // the token quantities are all valid
        for (uint256 i = 0; i < _quantities.length; i++) {
            // if no gems and no quantities, then it is a
            // gem to FTM swap and the quantity is the FTM amount
            // that the ggem is on sale for
            if (_gems.length == 0 && _pools.length == 0) {} else if (
                _gems[i] == 0
            ) {
                // if any gem, then check to see that this pool is valid
                try INFTComplexGemPoolData(_pools[i]).symbol() returns (
                    string memory _symbol
                ) {
                    require(bytes(_symbol).length > 0, "invalid pool");
                } catch {
                    require(false, "invalid pool");
                }
            } else {
                // if a specific gem, then check to make sure the gem is from this pool
                try
                    INFTComplexGemPoolData(_pools[i]).tokenType(_gems[i])
                returns (INFTGemMultiToken.TokenType _tokenType) {
                    require(
                        _tokenType == INFTGemMultiToken.TokenType.GEM,
                        "not a gem from this pool"
                    );
                } catch {
                    require(false, "invalid pool");
                }
            }

            require(_quantities[i] > 0, "invalid token quantity");
        }

        // create the offer
        offers[_offerId] = Offer(
            msg.sender,
            _pool,
            _gem,
            _pools,
            _gems,
            _quantities,
            listingFee,
            0,
            references,
            false,
            _blockCount,
            _wethOnly,
            false,
            address(0),
            0
        );

        // add the offer to the offers mapping
        offerIds.insert(_offerId);
        offersByOwner[msg.sender].push(offers[_offerId]);

        // return offer
        _offer = offers[_offerId];

        // emit the event
        emit OfferRegistered(
            msg.sender,
            _offerId,
            _pool,
            _gem,
            _pools,
            _gems,
            _quantities,
            references,
            listingFee,
            _blockCount
        );
    }

    function _deleteOffer(uint256 _offerId) internal {
        // get the offer owner
        address offerOwner = offers[_offerId].owner;

        // remove offer from offers mapping
        offerIds.remove(_offerId);
        delete offers[_offerId];
        delete offerBids[_offerId];

        // remove offer from owner's offers mapping
        for (
            uint256 offerIndex = 0;
            offerIndex < offersByOwner[offerOwner].length;
            ++offerIndex
        ) {
            if (offersByOwner[offerOwner][offerIndex].gem == _offerId) {
                offersByOwner[offerOwner][offerIndex] = offersByOwner[
                    offerOwner
                ][offersByOwner[offerOwner].length - 1];
                offersByOwner[offerOwner].pop();
            }
        }
    }

    // unregister an offer
    function unregisterOffer(uint256 _id)
        external
        override
        returns (bool success)
    {
        // // ensure the offer is registered
        require(offerIds.exists(_id) == true, "offer not registered");

        // ensure the offer is the message sender
        require(offers[_id].owner == msg.sender, "caller not owner");

        // get the listing fee of the offer
        uint256 _listingFee = offers[_id].listingFee;

        // find out if they are penalized for missing tokens
        bool penalty = offers[_id].missingTokenPenalty;

        // get the offer owner
        address offerOwner = offers[_id].owner;

        // delete the offer
        _deleteOffer(_id);

        // give them their fees back if they arent penalized
        if (!penalty) {
            // refund listing fee to the owner
            payable(offerOwner).transfer(_listingFee);
        }

        // emit the unregistered event
        emit OfferUnregistered(_id);

        return true;
    }

    // is an active offer
    function isOffer(uint256 _id)
        external
        view
        override
        returns (bool success)
    {
        return offerIds.exists(_id);
    }

    // list all offers
    function listOffers()
        external
        view
        override
        returns (Offer[] memory offersOut)
    {
        offersOut = new Offer[](offerIds.keyList.length);
        for (
            uint256 offerIndex = 0;
            offerIndex < offerIds.keyList.length;
            ++offerIndex
        ) {
            offersOut[offerIndex] = offers[offerIds.keyList[offerIndex]];
        }
    }

    // list all offer ids
    function listOfferIds()
        external
        view
        override
        returns (uint256[] memory _offerIds)
    {
        _offerIds = offerIds.keyList;
    }

    // list all offers by owner
    function listOffersByOwner(address ownerAddress)
        external
        view
        override
        returns (Offer[] memory _ids)
    {
        _ids = offersByOwner[ownerAddress];
    }

    // get details of an offer
    function getOffer(uint256 _id)
        external
        view
        override
        returns (Offer memory)
    {
        require(offerIds.exists(_id), "offer not registered");
        return offers[_id];
    }

    // get bids of an offer
    function getOfferBids(uint256 _id)
        external
        view
        override
        returns (Bid[] memory _bids)
    {
        require(offerIds.exists(_id), "offer not registered");
        _bids = offerBids[_id];
    }

    // create a bid
    function createBid(
        uint256 _id,
        uint256 _amount,
        bool useWeth
    ) external payable override returns (bool) {
        // this tell us if this is is a gem to fantom swap
        bool _isTokenAuction = isTokenAuction(_id);
        require(_isTokenAuction, "not an auction");

        // this is capitalism - so figure out our fee first
        uint256 bidFee = INFTGemFeeManager(feeManager).fee(bidFeeHash);
        bidFee = bidFee == 0 ? 100 : bidFee;

        // check that the offer is valid
        require(offerIds.exists(_id), "offer not registered");
        require(msg.value >= bidFee, "insufficient bid fee");
        require(offers[_id].wethOnly && !useWeth, "offer is weth only");

        // the min amount for the next bid. Must be greater than the current bid
        uint256 minAmount = offerBids[_id].length > 0
            ? offerBids[_id][offerBids[_id].length - 1].amount
            : offers[_id].quantities[0];

        // TODO: increase the bid by a set amount
        if (useWeth) {
            uint256 bal = IERC20(WFTM).balanceOf(msg.sender);
            require(bal > minAmount, "cant afford bid");
        } else {
            require(
                payable(msg.sender).balance >= minAmount,
                "cant afford bid"
            );
        }
        // add the bid to the bid mapping
        Bid memory _bid = Bid(_id, msg.sender, _amount);

        offerBids[_id].push(_bid);

        emit BidCreated(_id, msg.sender, _amount);
        return true;
    }

    // accept an offer
    function acceptOffer(uint256 _id, uint256[] memory _gems)
        external
        payable
        override
        returns (bool success)
    {
        // require this not be an auction
        bool _isTokenAuction = isTokenAuction(_id);
        require(!_isTokenAuction, "is an auction");

        // this is capitalism - so figure out our fee first
        uint256 acceptFee = INFTGemFeeManager(feeManager).fee(acceptFeeHash);
        acceptFee = acceptFee == 0 ? 0.01 ether : acceptFee;

        // check that the offer is valid
        require(offerIds.exists(_id), "offer not registered");
        require(msg.value >= acceptFee, "insufficient accept fee");

        // how many input pools' rquirements are met. Length of this must equal length of input pools
        uint256 foundInputPools = 0;

        // iterate through all incoming gems to account for them
        for (uint256 gemIndex = 0; gemIndex < _gems.length; gemIndex++) {
            //
            // we'll need to track the required quantity of each gem
            uint256 requiredQuantity = 0;
            uint256 theIncomingGem = _gems[gemIndex]; // the incoming gem we are validating
            uint256 foundBalance = 0;
            address thePool;

            // iterate through all input pool requirements for this offer
            for (
                uint256 poolIndex = 0;
                poolIndex < offers[_id].pools.length;
                poolIndex++
            ) {
                uint256 theGemRequirement = offers[_id].gems[poolIndex]; // the gem requirement for the above pool (or 0 if any gem)

                // determine if the gem we are validating is a member of this pool
                INFTGemMultiToken.TokenType tokenType = INFTComplexGemPoolData(
                    offers[_id].pools[poolIndex]
                ).tokenType(_gems[gemIndex]);

                // if it is then get the message senders balance of the gem
                // and add it to the balance we are tracking
                if (tokenType == INFTGemMultiToken.TokenType.GEM) {
                    //
                    // the gem pool from the offer
                    thePool = offers[_id].pools[poolIndex];

                    // if we have no balance yet its the first time we have seen the pool
                    // so increment the total count of input pools we have seen
                    if (foundBalance == 0) {
                        foundInputPools++;
                    }

                    // incement the pool gem balance
                    foundBalance += IERC1155(address(multitoken)).balanceOf(
                        msg.sender,
                        _gems[gemIndex]
                    );

                    // if the requirement is specific (not 'any') then this is the
                    // place to check if the gem the pool requires is the gem we are checking
                    if (theGemRequirement != 0) {
                        require(
                            theGemRequirement == theIncomingGem,
                            "gem mismatch"
                        );
                    }

                    // grab required quantity so we can see if we have enough
                    requiredQuantity = offers[_id].quantities[poolIndex];
                }
            }

            // if the balance is less than the required quantity then reject
            require(
                thePool != address(0) && foundBalance >= requiredQuantity,
                "Insufficient gem balance"
            );
            thePool = address(0);
        }
        // this tell us if this is is a gem to fantom swap
        bool _isTokenSwap = isTokenSwap(_id);

        // if this is not a gem to ftm swap
        if (!_isTokenSwap) {
            // require that the number of pools we have seen is equal to the number of input pools
            require(
                offers[_id].pools.length == foundInputPools,
                "conditions unsatisfied"
            );
        }

        // check that the offer owner has the token to swap
        // and penalize them if they do mot have it.
        if (
            IERC1155(address(multitoken)).balanceOf(
                offers[_id].owner,
                offers[_id].gem
            ) == 0
        ) {
            // penalize the owner for not having the token
            offers[_id].missingTokenPenalty = true;
            success = false;

            // refund the accepter all tokens
            // they sent for fees or to pay for gem
            require(payable(msg.sender).send(msg.value), "refund failed");
            return success;
        }

        // if this is a gem to ftm swap
        if (_isTokenSwap) {
            // fee is permillion - unite per million
            acceptFee = INFTGemFeeManager(feeManager).fee(
                acceptVariableFeeHash
            );
            acceptFee = acceptFee == 0 ? 1000 : acceptFee; // 1000 permillion is 0.1%

            // closing fee is x permillion of the cost of the swap
            acceptFee = (offers[_id].quantities[0] / 1000000) * acceptFee;
            require(
                msg.value >= offers[_id].quantities[0],
                "insufficient swap amount"
            );
        }

        address offerPool = offers[_id].pool;
        uint256 offerHash = offers[_id].gem;

        //if this is a gem to token swap, send the FTM minus fee to seller
        if (_isTokenSwap) {
            require(
                payable(offers[_id].owner).send(
                    offers[_id].quantities[0] - acceptFee
                ),
                "swap failed"
            );
        } else {
            // swap the gems
            proxyList[msg.sender] = address(this);
            IERC1155(address(multitoken)).safeBatchTransferFrom(
                msg.sender,
                offers[_id].owner,
                _gems,
                offers[_id].quantities,
                ""
            );
            delete proxyList[msg.sender];
        }

        // swap the gem
        proxyList[offers[_id].owner] = address(this);
        IERC1155(address(multitoken)).safeTransferFrom(
            offers[_id].owner,
            msg.sender,
            offers[_id].gem,
            1,
            ""
        );
        delete proxyList[offers[_id].owner];

        // remove the offer
        _deleteOffer(_id);

        emit OfferAccepted(
            _id,
            offerPool,
            offerHash,
            msg.sender,
            _gems,
            acceptFee
        );

        return true;
    }

    function isTokenSwap(uint256 _id) internal view returns (bool) {
        return (offers[_id].pools.length == 0 &&
            offers[_id].gems.length == 0 &&
            offers[_id].quantities.length == 1 &&
            offers[_id].blockCount == 0);
    }

    function isTokenAuction(uint256 _id) internal view returns (bool) {
        return (offers[_id].pools.length == 0 &&
            offers[_id].gems.length == 0 &&
            offers[_id].quantities.length == 1 &&
            offers[_id].blockCount > 0);
    }

    // is the swap offer an auction?
    function isAuction(uint256 _id) external view override returns (bool) {
        return isTokenAuction(_id);
    }

    // set the open state of the swap
    function closeAuction(uint256 _id) external override returns (bool) {
        require(isTokenAuction(_id), "not an auction");
        require(
            msg.sender == auctionMaster ||
                this.isController(msg.sender) ||
                offers[_id].owner == msg.sender,
            "not owner or manager"
        );
        require(block.number > offers[_id].blockCount, "auction still running");

        // check if there's a winner
        bool hasWinner = offerBids[_id].length > 0;
        if (!hasWinner) {
            emit AuctionClosed(_id, address(0), 0, block.number);
            return true;
        }

        // the winning bid
        Bid memory winningBid = offerBids[_id][offerBids[_id].length - 1];
        uint256 winningBidAmount = winningBid.amount;
        address winner = winningBid.bidder;

        // this is capitalism - so figure out our fee
        uint256 acceptFee = INFTGemFeeManager(feeManager).fee(acceptFeeHash);
        acceptFee = acceptFee == 0 ? 1000 : acceptFee;
        acceptFee = (winningBidAmount / 1000000) * acceptFee;

        if (offers[_id].wethOnly) {
            // swap the gem
            proxyList[offers[_id].owner] = address(this);
            IERC1155(address(multitoken)).safeTransferFrom(
                offers[_id].owner,
                msg.sender,
                offers[_id].gem,
                1,
                ""
            );
            delete proxyList[offers[_id].owner];

            // TODO: check allowance here

            // transfer erc20 from user to owner minus
            // fee portion. MUST ALEADY BE APPROVED!
            IERC20(WFTM).transferFrom(
                msg.sender,
                offers[_id].owner,
                winningBidAmount - acceptFee
            );
            // transfer weth fee portion contract
            IERC20(WFTM).transferFrom(msg.sender, address(this), acceptFee);
            IWrappedFtm(WFTM).withdraw(acceptFee);

            // delete the offer, we dont need it anymore
            _deleteOffer(_id);

            // auction now fully completed
            emit AuctionCompleted(_id, winner, winningBidAmount, block.number);
            return true;
        } else {
            // flip collect payment flag to true - the offer is now in
            // a ready state to be paid for by the purchaser
            offers[_id].collectPayment = true;
            offers[_id].winner = winner;
            offers[_id].winningBidAmount = winningBidAmount;
        }

        emit AuctionClosed(_id, winner, winningBidAmount, block.number);
        return true;
    }

    // withdraw accrued fees
    function completeAuction(uint256 _id)
        external
        payable
        override
        returns (bool)
    {
        require(offers[_id].collectPayment, "not ready to collect payment");
        require(offers[_id].winner == msg.sender, "not auction winner");
        require(!offers[_id].wethOnly, "offer is weth only");

        // the winning bid
        Bid memory winningBid = offerBids[_id][offerBids[_id].length - 1];
        uint256 winningBidAmount = winningBid.amount;

        require(msg.value >= winningBidAmount, "insufficient funds");

        // swap the gem
        proxyList[offers[_id].owner] = address(this);
        IERC1155(address(multitoken)).safeTransferFrom(
            offers[_id].owner,
            msg.sender,
            offers[_id].gem,
            1,
            ""
        );
        delete proxyList[offers[_id].owner];

        // this is capitalism - so figure out our fee
        uint256 acceptFee = INFTGemFeeManager(feeManager).fee(acceptFeeHash);
        acceptFee = acceptFee == 0 ? 1000 : acceptFee;
        acceptFee = (winningBidAmount / 1000000) * acceptFee;

        // transfer the FTM to the seller
        payable(offers[_id].owner).transfer(winningBidAmount - acceptFee);

        // delete the offer, we dont need it anymore
        _deleteOffer(_id);

        // auction now fully completed
        emit AuctionCompleted(_id, msg.sender, winningBidAmount, block.number);
        return true;
    }

    // withdraw accrued fees
    function withdrawFees(address _receiver) external override onlyController {
        require(payable(address(this)).balance > 0, "no fees to withdraw");
        uint256 theBalance = payable(address(this)).balance;
        payable(_receiver).transfer(theBalance);
        emit SwapMeetFeesWithdrawn(_receiver, theBalance);
    }

    // set open state
    function setOpenState(bool openState) external override onlyController {
        open = openState;
        emit SwapMeetIsOpen(open);
    }

    // is the swap open
    function isOpen() external view override returns (bool) {
        return open;
    }

    // called by the multitoken when a swap is performed by the
    // swap meet - we temporarily set the operator of the token
    // via this proxy function, which is called from isApproved()
    function proxies(address input) external view returns (address) {
        return proxyList[input];
    }

}
