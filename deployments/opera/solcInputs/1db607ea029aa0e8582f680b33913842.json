{
  "language": "Solidity",
  "sources": {
    "src/access/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IControllable.sol\";\n\nabstract contract Controllable is IControllable {\n    mapping(address => bool) internal _controllers;\n\n    /**\n     * @dev Throws if called by any account not in authorized list\n     */\n    modifier onlyController() {\n        require(\n            _controllers[msg.sender] == true || address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Add an address allowed to control this contract\n     */\n    function _addController(address _controller) internal {\n        _controllers[_controller] = true;\n    }\n\n    /**\n     * @dev Add an address allowed to control this contract\n     */\n    function addController(address _controller)\n        external\n        override\n        onlyController\n    {\n        _controllers[_controller] = true;\n    }\n\n    /**\n     * @dev Check if this address is a controller\n     */\n    function isController(address _address)\n        external\n        view\n        override\n        returns (bool allowed)\n    {\n        allowed = _controllers[_address];\n    }\n\n    /**\n     * @dev Remove the sender address from the list of controllers\n     */\n    function relinquishControl() external override onlyController {\n        delete _controllers[msg.sender];\n    }\n}\n"
    },
    "src/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IControllable {\n    event ControllerAdded(\n        address indexed contractAddress,\n        address indexed controllerAddress\n    );\n    event ControllerRemoved(\n        address indexed contractAddress,\n        address indexed controllerAddress\n    );\n\n    function addController(address controller) external;\n\n    function isController(address controller) external view returns (bool);\n\n    function relinquishControl() external;\n}\n"
    },
    "src/utils/BulkTokenSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/IBulkTokenSender.sol\";\n\n/**\n * @dev Collection of utility functions that mint tokens\n */\ncontract BulkTokenSender is IBulkTokenSender, Controllable {\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    function bulkSend(\n        address tokenAddress,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external override onlyController {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            IERC20(tokenAddress).transferFrom(\n                address(this),\n                recipients[i],\n                gquantities[i]\n            );\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/interfaces/INFTGemMultiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface INFTGemMultiToken {\n    enum TokenType {\n        GOVERNANCE,\n        CLAIM,\n        GEM\n    }\n\n    struct Royalty {\n        address owner;\n        uint256 royaltyPermillion;\n    }\n\n    // called by controller to mint a claim or a gem\n    function mint(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external;\n\n    // called by controller to mint a claim or a gem\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external;\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external;\n\n    // called by controller to burn a claim\n    function burn(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external;\n\n    function heldTokens(address holder)\n        external\n        view\n        returns (uint256[] memory);\n\n    function allHeldTokens(address holder, uint256 _idx)\n        external\n        view\n        returns (uint256);\n\n    function allHeldTokensLength(address holder)\n        external\n        view\n        returns (uint256);\n\n    function tokenHolders(uint256 _token)\n        external\n        view\n        returns (address[] memory);\n\n    function allTokenHolders(uint256 _token, uint256 _idx)\n        external\n        view\n        returns (address);\n\n    function allTokenHoldersLength(uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function totalBalances(uint256 _id) external view returns (uint256);\n\n    function allProxyRegistries(uint256 _idx) external view returns (address);\n\n    function allProxyRegistriesLength() external view returns (uint256);\n\n    function addProxyRegistry(address registry) external;\n\n    function removeProxyRegistryAt(uint256 index) external;\n\n    function getRegistryManager() external view returns (address);\n\n    function setRegistryManager(address newManager) external;\n\n    function setRoyaltyInfo(\n        uint256 _tokenId,\n        address _owner,\n        uint256 feePermil\n    ) external;\n\n    function lock(uint256 token, uint256 timeframe) external;\n\n    function unlockTime(address account, uint256 token)\n        external\n        view\n        returns (uint256);\n\n    function setTokenData(\n        uint256 tokenHash,\n        TokenType tokenType,\n        address tokenPool\n    ) external;\n\n    function getTokenData(uint256 tokenHash)\n        external\n        view\n        returns (TokenType, address);\n}\n"
    },
    "src/interfaces/IBulkTokenSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IBulkTokenSender {\n    function bulkSend(\n        address tokenAddress,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external;\n}\n"
    },
    "src/utils/BulkTokenMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/IBulkTokenMinter.sol\";\n\n/**\n * @dev Collection of utility functions that mint tokens\n */\ncontract BulkTokenMinter is IBulkTokenMinter, Controllable {\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /**\n     * @dev Mint one token hash type to multiple accounts with multiple quantities\n     */\n    function bulkMintToken(\n        address multitoken,\n        address[] memory recipients,\n        uint256 tokenHash,\n        uint256[] memory quantities\n    ) external override onlyController {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            INFTGemMultiToken(multitoken).mint(\n                recipients[i],\n                tokenHash,\n                quantities[i]\n            );\n        }\n    }\n\n    /**\n     * @dev Mint governance to recipients\n     */\n    function bulkMintGov(\n        address multitoken,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external override onlyController {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            INFTGemMultiToken(multitoken).mint(\n                recipients[i],\n                0,\n                gquantities[i]\n            );\n        }\n    }\n}\n"
    },
    "src/interfaces/IBulkTokenMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IBulkTokenMinter {\n    function bulkMintGov(\n        address multitoken,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external;\n\n    function bulkMintToken(\n        address multitoken,\n        address[] memory recipients,\n        uint256 tokenHash,\n        uint256[] memory quantities\n    ) external;\n}\n"
    },
    "src/utils/BulkGovernanceTokenMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/IGovernanceTokenMinter.sol\";\nimport \"../interfaces/IGovernanceMintable.sol\";\n\n/**\n * @dev Collection of utility functions that mint tokens\n */\ncontract BulkGovernanceTokenMinter is IGovernanceTokenMinter, Controllable {\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /**\n     * @dev Mint one token hash type to multiple accounts with multiple quantities\n     */\n    function bulkMint(\n        address multitoken,\n        address[] memory recipients,\n        uint256[] memory quantities\n    ) external override onlyController {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            IGovernanceMintable(multitoken).mint(recipients[i], quantities[i]);\n        }\n    }\n}\n"
    },
    "src/interfaces/IGovernanceTokenMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IGovernanceTokenMinter {\n    function bulkMint(\n        address token,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external;\n}\n"
    },
    "src/interfaces/IGovernanceMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IGovernanceMintable {\n    function mint(address account, uint256 amount) external;\n}\n"
    },
    "src/governance/GovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IGovernanceMintable.sol\";\n\ncontract GovernanceToken is IGovernanceMintable {\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Bitgem\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"BGEM\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    mapping(address => mapping(address => uint96)) internal allowances;\n\n    mapping(address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    uint256 public availableSupply;\n\n    uint256 public totalSupply;\n\n    address public minter;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /**\n     * @notice Construct a new Comp token\n     * @param account The initial account to grant all the tokens\n     */\n    constructor(\n        address account,\n        uint256 _availableSupply,\n        uint256 _totalSupply\n    ) {\n        minter = account;\n        totalSupply = _totalSupply;\n        availableSupply = _availableSupply;\n        if (_availableSupply > 0) {\n            balances[account] = uint96(_availableSupply);\n            emit Transfer(address(0), account, _availableSupply);\n        }\n    }\n\n    /**\n     * @notice Mint the given amount of tokens to the given account\n     * @param account The address of the account holding the funds\n     * @param amount The address of the account spending the funds\n     */\n    function mint(address account, uint256 amount) external override {\n        require(msg.sender == minter, \"sender is not minter\");\n        require(availableSupply + amount <= totalSupply, \"over total supply\");\n        availableSupply += amount;\n        balances[account] += uint96(amount);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 rawAmount)\n        external\n        returns (bool)\n    {\n        uint96 amount;\n        if (rawAmount == type(uint256).max) {\n            amount = type(uint96).max;\n        } else {\n            amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\n        uint96 amount = safe96(\n            rawAmount,\n            \"Comp::transfer: amount exceeds 96 bits\"\n        );\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(\n            rawAmount,\n            \"Comp::approve: amount exceeds 96 bits\"\n        );\n\n        if (spender != src && spenderAllowance != type(uint96).max) {\n            uint96 newAllowance = sub96(\n                spenderAllowance,\n                amount,\n                \"Comp::transferFrom: transfer amount exceeds spender allowance\"\n            );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                getChainId(),\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        address signatory = ecrecover(digest, v, r, s);\n        require(\n            signatory != address(0),\n            \"Comp::delegateBySig: invalid signature\"\n        );\n        require(\n            nonce == nonces[signatory]++,\n            \"Comp::delegateBySig: invalid nonce\"\n        );\n        require(\n            block.timestamp <= expiry,\n            \"Comp::delegateBySig: signature expired\"\n        );\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return\n            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber)\n        public\n        view\n        returns (uint96)\n    {\n        require(\n            blockNumber < block.number,\n            \"Comp::getPriorVotes: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 amount\n    ) internal {\n        require(\n            src != address(0),\n            \"Comp::_transferTokens: cannot transfer from the zero address\"\n        );\n        require(\n            dst != address(0),\n            \"Comp::_transferTokens: cannot transfer to the zero address\"\n        );\n\n        balances[src] = sub96(\n            balances[src],\n            amount,\n            \"Comp::_transferTokens: transfer amount exceeds balance\"\n        );\n        balances[dst] = add96(\n            balances[dst],\n            amount,\n            \"Comp::_transferTokens: transfer amount overflows\"\n        );\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0\n                    ? checkpoints[srcRep][srcRepNum - 1].votes\n                    : 0;\n                uint96 srcRepNew = sub96(\n                    srcRepOld,\n                    amount,\n                    \"Comp::_moveVotes: vote amount underflows\"\n                );\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0\n                    ? checkpoints[dstRep][dstRepNum - 1].votes\n                    : 0;\n                uint96 dstRepNew = add96(\n                    dstRepOld,\n                    amount,\n                    \"Comp::_moveVotes: vote amount overflows\"\n                );\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(\n            block.number,\n            \"Comp::_writeCheckpoint: block number exceeds 32 bits\"\n        );\n\n        if (\n            nCheckpoints > 0 &&\n            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n        ) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(\n                blockNumber,\n                newVotes\n            );\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint96)\n    {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "src/tokens/NFTGemMultiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport \"../libs/Strings.sol\";\nimport \"../libs/AddressSet.sol\";\nimport \"../libs/UInt256Set.sol\";\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/IERC2981.sol\";\n\n/**\n * @dev ProxyContract placeholder - the proxy delegate\n */\ncontract OwnableDelegateProxy {\n\n}\n\n/**\n * @dev a registry of proxies\n */\ncontract ProxyRegistry {\n    mapping(address => OwnableDelegateProxy) public proxies;\n}\n\n/**\n * @dev a mock object for testing\n */\ncontract MockProxyRegistry {\n    function proxies(address input) external pure returns (address) {\n        return input;\n    }\n}\n\n/**\n * @dev the primary multitoken contract\n */\ncontract NFTGemMultiToken is\n    ERC1155Pausable,\n    ERC1155Holder,\n    INFTGemMultiToken,\n    Controllable,\n    IERC2981\n{\n    using AddressSet for AddressSet.Set;\n    using UInt256Set for UInt256Set.Set;\n\n    using Strings for string;\n\n    // proxy registries for exchanges to enable no-fee trading\n    AddressSet.Set private proxyRegistries;\n    address private registryManager;\n    mapping(uint256 => Royalty) private royaltyData;\n\n    // total balance per token id\n    mapping(uint256 => uint256) private _totalBalances;\n    // time-locked tokens\n    mapping(address => mapping(uint256 => uint256)) private _tokenLocks;\n\n    // lists of held tokens by user\n    mapping(address => UInt256Set.Set) private _heldTokens;\n    // list of token holders\n    mapping(uint256 => AddressSet.Set) private _tokenHolders;\n\n    // token types and token pool addresses, to link the multitoken to the tokens created on it\n    mapping(uint256 => INFTGemMultiToken.TokenType) private _tokenTypes;\n    mapping(uint256 => address) private _tokenPools;\n\n    bytes4 public constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n\n    /**\n     * @dev Contract initializer.\n     */\n    constructor() ERC1155(\"https://metadata.bitgem.co/\") {\n        _addController(msg.sender);\n        registryManager = msg.sender;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155, ERC1155Receiver)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC2981).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev timelock the tokens from moving until the given time\n     */\n    function lock(uint256 token, uint256 timestamp) external override {\n        require(_tokenLocks[_msgSender()][token] < timestamp, \"ALREADY_LOCKED\");\n        _tokenLocks[_msgSender()][token] = timestamp;\n    }\n\n    /**\n     * @dev unlock time for token / id\n     */\n    function unlockTime(address account, uint256 token)\n        external\n        view\n        override\n        returns (uint256 theTime)\n    {\n        theTime = _tokenLocks[account][token];\n    }\n\n    /**\n     * @dev ierc2981\n     */\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\n        external\n        view\n        override\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        require(royaltyData[_tokenId].owner != address(0), \"NO_SUCH_TOKEN\");\n        return (\n            royaltyData[_tokenId].owner,\n            (_salePrice * royaltyData[_tokenId].royaltyPermillion) / 1000000\n        );\n    }\n\n    /**\n     * @dev Update the royalty info. only callable by the royalty owner.\n     */\n    function setRoyaltyInfo(\n        uint256 _tokenId,\n        address _owner,\n        uint256 feePermil\n    ) external override {\n        require(msg.sender == royaltyData[_tokenId].owner, \"INVALID_OWNER\");\n        Royalty storage roy = royaltyData[_tokenId];\n        roy.owner = _owner;\n        roy.royaltyPermillion = feePermil;\n    }\n\n    /**\n     * @dev Returns the metadata URI for this token type\n     */\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155)\n        returns (string memory)\n    {\n        // the URI override is here to support IPFS addresses - we need to do the\n        // id concat here because IPFS can't do it. This makes this call take a little\n        // longer but the advantage is that the call returns an already-formed URI\n        require(\n            _totalBalances[_id] != 0,\n            \"NFTGemMultiToken#uri: NONEXISTENT_TOKEN\"\n        );\n        return\n            Strings.strConcat(\n                ERC1155Pausable(this).uri(_id),\n                Strings.uint2str(_id)\n            );\n    }\n\n    /**\n     * @dev returns an array of held tokens for the token holder\n     */\n    function heldTokens(address holder)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _heldTokens[holder].keyList;\n    }\n\n    /**\n     * @dev held token at index for token holder\n     */\n    function allHeldTokens(address holder, uint256 _idx)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _heldTokens[holder].keyList[_idx];\n    }\n\n    /**\n     * @dev Returns the count of held tokens for the token holder\n     */\n    function allHeldTokensLength(address holder)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _heldTokens[holder].keyList.length;\n    }\n\n    /**\n     * @dev Returns an array of token holders for the given token id\n     */\n    function tokenHolders(uint256 _token)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return _tokenHolders[_token].keyList;\n    }\n\n    /**\n     * @dev  token holder at index for token id\n     */\n    function allTokenHolders(uint256 _token, uint256 _idx)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _tokenHolders[_token].keyList[_idx];\n    }\n\n    /**\n     * @dev Returns the count of token holders for the held token\n     */\n    function allTokenHoldersLength(uint256 _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _tokenHolders[_token].keyList.length;\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function totalBalances(uint256 _id)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _totalBalances[_id];\n    }\n\n    /**\n     * @dev Returns proxy registry at index\n     */\n    function allProxyRegistries(uint256 _idx)\n        external\n        view\n        override\n        returns (address)\n    {\n        return proxyRegistries.keyList[_idx];\n    }\n\n    /**\n     * @dev Returns the registyry manager account\n     */\n    function getRegistryManager() external view override returns (address) {\n        return registryManager;\n    }\n\n    /**\n     * @dev set the registry manager account\n     */\n    function setRegistryManager(address newManager) external override {\n        require(msg.sender == registryManager, \"UNAUTHORIZED\");\n        require(newManager != address(0), \"UNAUTHORIZED\");\n        registryManager = newManager;\n    }\n\n    /**\n     * @dev a count of proxy registries\n     */\n    function allProxyRegistriesLength()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return proxyRegistries.keyList.length;\n    }\n\n    /**\n     * @dev add a proxy registry to the list\n     */\n    function addProxyRegistry(address registry) external override {\n        require(\n            msg.sender == registryManager || _controllers[msg.sender] == true,\n            \"UNAUTHORIZED\"\n        );\n        proxyRegistries.insert(registry);\n    }\n\n    /**\n     * @dev remove the proxy registry from the list at index\n     */\n    function removeProxyRegistryAt(uint256 index) external override {\n        require(\n            msg.sender == registryManager || _controllers[msg.sender] == true,\n            \"UNAUTHORIZED\"\n        );\n        require(index < proxyRegistries.keyList.length, \"INVALID_INDEX\");\n        proxyRegistries.remove(proxyRegistries.keyList[index]);\n    }\n\n    /**\n     * @dev override base functionality to check proxy registries for approvers\n     */\n    function isApprovedForAll(address _owner, address _operator)\n        public\n        view\n        override\n        returns (bool isOperator)\n    {\n        // Whitelist OpenSea proxy contract for easy trading.\n        for (uint256 i = 0; i < proxyRegistries.keyList.length; i++) {\n            ProxyRegistry proxyRegistry = ProxyRegistry(\n                proxyRegistries.keyList[i]\n            );\n            try proxyRegistry.proxies(_owner) returns (\n                OwnableDelegateProxy thePr\n            ) {\n                if (address(thePr) == _operator) {\n                    return true;\n                }\n            } catch {}\n        }\n        return ERC1155.isApprovedForAll(_owner, _operator);\n    }\n\n    /**\n     * @dev mint some amount of tokens. Only callable by token owner\n     */\n    function mint(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external override onlyController {\n        _mint(account, tokenHash, amount, \"0x0\");\n        royaltyData[tokenHash] = Royalty(msg.sender, 100000);\n    }\n\n    /**\n     * @dev mint some amount of tokens to multiple recipients. Only callable by token owner\n     */\n\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external override onlyController {\n        _mintBatch(to, ids, amounts, \"0x0\");\n    }\n\n    /**\n     * @dev burn some amount of tokens of multiple token types of account. Only callable by token owner\n     */\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external override onlyController {\n        _burnBatch(account, ids, amounts);\n    }\n\n    /**\n     * @dev set the data for this tokenhash. points to a token type (1 = claim, 2 = gem) and token pool address\n     */\n    function setTokenData(\n        uint256 tokenHash,\n        INFTGemMultiToken.TokenType tokenType,\n        address tokenPool\n    ) external override onlyController {\n        _tokenTypes[tokenHash] = tokenType;\n        _tokenPools[tokenHash] = tokenPool;\n    }\n\n    /**\n     * @dev get the token data for this token tokenhash\n     */\n    function getTokenData(uint256 tokenHash)\n        external\n        view\n        override\n        returns (INFTGemMultiToken.TokenType tokenType, address tokenPool)\n    {\n        tokenType = _tokenTypes[tokenHash];\n        tokenPool = _tokenPools[tokenHash];\n    }\n\n    /**\n     * @dev internal mint overridden to manage token holders and held tokens lists\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n    }\n\n    /**\n     * @dev internal minttbatch should account for managing lists\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n    }\n\n    /**\n     * @dev burn some amount of tokens. Only callable by token owner\n     */\n    function burn(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external override onlyController {\n        _burn(account, uint256(tokenHash), amount);\n    }\n\n    /**\n     * @dev internal burn overridden to track lists\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual override {\n        super._burn(account, id, amount);\n    }\n\n    /**\n     * @dev internal burnBatch should account for managing lists\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual override {\n        super._burnBatch(account, ids, amounts);\n    }\n\n    /**\n     * @dev we override this method in order to manager the token holder and held token lists\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            // prevent send if tokens are locked\n            if (from != address(0)) {\n                require(\n                    _tokenLocks[from][ids[i]] <= block.timestamp,\n                    \"TOKEN_LOCKED\"\n                );\n            }\n\n            // if this is not a mint then remove the held token id from lists if\n            // this is the last token if this type the sender owns\n            if (from != address(0) && balanceOf(from, ids[i]) == amounts[i]) {\n                // find and delete the token id from the token holders held tokens\n                _heldTokens[from].remove(ids[i]);\n                _tokenHolders[ids[i]].remove(from);\n            }\n\n            // if this is not a burn and receiver does not yet own token then\n            // add that account to the token for that id\n            if (to != address(0) && balanceOf(to, ids[i]) == 0) {\n                // insert the token id from the token holders held tokens\\\n                _heldTokens[to].insert(ids[i]);\n                _tokenHolders[ids[i]].insert(to);\n            }\n\n            // inc and dec balances for each token type\n            if (from == address(0)) {\n                _totalBalances[uint256(ids[i])] =\n                    _totalBalances[uint256(ids[i])] +\n                    (amounts[i]);\n            }\n            if (to == address(0)) {\n                _totalBalances[uint256(ids[i])] =\n                    _totalBalances[uint256(ids[i])] -\n                    (amounts[i]);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "src/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary Strings {\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d,\n        string memory _e\n    ) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(\n            _ba.length + _bb.length + _bc.length + _bd.length + _be.length\n        );\n        bytes memory babcde = bytes(abcde);\n        uint256 k = 0;\n        for (uint256 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (uint256 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (uint256 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (uint256 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (uint256 i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b)\n        internal\n        pure\n        returns (string memory)\n    {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function uint2str(uint256 _i)\n        internal\n        pure\n        returns (string memory _uintAsString)\n    {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "src/libs/AddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary AddressSet {\n    struct Set {\n        mapping(address => uint256) keyPointers;\n        address[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, address key) internal {\n        require(\n            !exists(self, key),\n            \"AddressSet: key already exists in the set.\"\n        );\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, address key) internal {\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\n        require(\n            exists(self, key),\n            \"AddressSet: key does not exist in the set.\"\n        );\n        if (!exists(self, key)) return;\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            address keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        self.keyList.pop();\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) internal view returns (uint256) {\n        return (self.keyList.length);\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, address key)\n        internal\n        view\n        returns (bool)\n    {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index)\n        internal\n        view\n        returns (address)\n    {\n        return self.keyList[index];\n    }\n}\n"
    },
    "src/libs/UInt256Set.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary UInt256Set {\n    struct Set {\n        mapping(uint256 => uint256) keyPointers;\n        uint256[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, uint256 key) internal {\n        require(\n            !exists(self, key),\n            \"UInt256Set: key already exists in the set.\"\n        );\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, uint256 key) internal {\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\n        // require(\n        //     exists(self, key),\n        //     \"UInt256Set: key does not exist in the set.\"\n        // );\n        if (!exists(self, key)) return;\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            uint256 keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        delete self.keyList[self.keyList.length - 1];\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) internal view returns (uint256) {\n        return (self.keyList.length);\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, uint256 key)\n        internal\n        view\n        returns (bool)\n    {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index)\n        internal\n        view\n        returns (uint256)\n    {\n        return self.keyList[index];\n    }\n}\n"
    },
    "src/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @dev Interface for the NFT Royalty Standard\n///\ninterface IERC2981 {\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    /// @param _tokenId - the NFT asset queried for royalty information\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\n    /// @return receiver - address of who should be sent the royalty payment\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][account] = accountBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "src/market/SwapMeet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"../interfaces/ISwapMeet.sol\";\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\n\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\n\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\nimport \"../libs/UInt256Set.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract SwapMeet is ISwapMeet, Controllable {\n    using UInt256Set for UInt256Set.Set;\n\n    uint256 public constant listingFeeHash =\n        uint256(keccak256(\"swapMeetListingFee\"));\n    uint256 public constant acceptFeeHash =\n        uint256(keccak256(\"swapMeetAcceptFee\"));\n    uint256 public constant acceptVariableFeeHash =\n        uint256(keccak256(\"swapMeetAcceptVariableFee\"));\n\n    bool internal open;\n\n    INFTGemFeeManager internal feeManager;\n    INFTGemMultiToken internal multitoken;\n\n    // all the offers in this contract\n    mapping(uint256 => Offer) internal offers;\n\n    // all the offer but by owner\n    mapping(address => Offer[]) internal offersByOwner;\n\n    UInt256Set.Set internal offerIds;\n\n    // proxy mapping manages alloewances w/o owner\n    mapping(address => address) internal proxyList;\n\n    constructor(address _multitoken, address _feeManager) {\n        _addController(msg.sender);\n        multitoken = INFTGemMultiToken(_multitoken);\n        feeManager = INFTGemFeeManager(_feeManager);\n        open = true;\n    }\n\n    // register a new offer\n    function registerOffer(\n        // what to have to swap\n        address _pool,\n        uint256 _gem,\n        uint256 _quantity,\n        // what you are willing to swap it for\n        address[] calldata _pools,\n        uint256[] calldata _gems,\n        uint256[] calldata _quantities,\n        uint256 references\n    )\n        external\n        payable\n        override\n        returns (uint256 _offerId, Offer memory _offer)\n    {\n        require(open, \"swap meet closed\");\n\n        // get the listing fee - the service is a flat fee\n        uint256 listingFee = INFTGemFeeManager(feeManager).fee(listingFeeHash);\n        listingFee = listingFee == 0 ? 0.5 ether : listingFee;\n\n        // an offer is offerer address plus gem hash\n        _offerId = uint256(keccak256(abi.encodePacked(msg.sender, _gem)));\n\n        // basic sanity checks\n        require(!offerIds.exists(_offerId), \"gem already registered\");\n        require(_gems.length == _pools.length, \"mismatched gem quantities\");\n        require(msg.value >= listingFee, \"insufficient listing fee\");\n        require(_quantity > 0, \"invalid quantity\");\n\n        // make sure they own the gem they wanna trade\n        require(\n            IERC1155(address(multitoken)).balanceOf(msg.sender, _gem) >=\n                _quantity,\n            \"insufficient gem balance\"\n        );\n\n        // make sure the gem is of the specified pool\n        INFTGemMultiToken.TokenType tt = INFTComplexGemPoolData(_pool)\n            .tokenType(_gem);\n\n        // require that the gem be from this pool\n        require(tt == INFTGemMultiToken.TokenType.GEM, \"invalid token type\");\n\n        // validate the input gems list\n        require(\n            _validateInputGems(_pools, _gems, _quantities),\n            \"invalid input\"\n        );\n\n        // create the offer\n        offers[_offerId] = Offer(\n            _offerId,\n            msg.sender,\n            _pool,\n            _gem,\n            _quantity,\n            _pools,\n            _gems,\n            _quantities,\n            listingFee,\n            0,\n            references,\n            false\n        );\n\n        // add the offer to the offers mapping\n        offerIds.insert(_offerId);\n        offersByOwner[msg.sender].push(offers[_offerId]);\n\n        // return offer\n        _offer = offers[_offerId];\n\n        _emitOffer(_offerId);\n    }\n\n    function _emitOffer(uint256 _offerId) internal {\n        Offer memory offer = offers[_offerId];\n        // emit the event\n        emit OfferRegistered(\n            offer.owner,\n            _offerId,\n            offer.pool,\n            offer.gem,\n            offer.quantity,\n            offer.pools,\n            offer.gems,\n            offer.quantities,\n            offer.references\n        );\n    }\n\n    function _validateInputGems(\n        address[] memory _pools,\n        uint256[] memory _gems,\n        uint256[] memory _quantities\n    ) internal view returns (bool) {\n        // make sure the pool addresses are valid and that\n        // the token quantities are all valid\n        for (uint256 i = 0; i < _quantities.length; i++) {\n            // if no gems and no quantities, then it is a\n            // gem to FTM swap and the quantity is the FTM amount\n            // that the ggem is on sale for\n            if (_gems.length == 0 && _pools.length == 0) {} else if (\n                _gems[i] == 0\n            ) {\n                // if any gem, then check to see that this pool is valid\n                try INFTComplexGemPoolData(_pools[i]).symbol() returns (\n                    string memory _symbol\n                ) {\n                    require(bytes(_symbol).length > 0, \"invalid pool\");\n                } catch {\n                    require(false, \"invalid pool\");\n                }\n            } else {\n                // if a specific gem, then check to make sure the gem is from this pool\n                try\n                    INFTComplexGemPoolData(_pools[i]).tokenType(_gems[i])\n                returns (INFTGemMultiToken.TokenType _tokenType) {\n                    require(\n                        _tokenType == INFTGemMultiToken.TokenType.GEM,\n                        \"not a gem from this pool\"\n                    );\n                } catch {\n                    require(false, \"invalid pool\");\n                }\n            }\n\n            require(_quantities[i] > 0, \"invalid token quantity\");\n        }\n        return true;\n    }\n\n    // unregister an offer\n    function unregisterOffer(uint256 _id)\n        external\n        override\n        returns (bool success)\n    {\n        // // ensure the offer is registered\n        require(offerIds.exists(_id) == true, \"offer not registered\");\n\n        // ensure the offer is the message sender\n        require(offers[_id].owner == msg.sender, \"caller not owner\");\n\n        // get the listing fee of the offer\n        uint256 _listingFee = offers[_id].listingFee;\n\n        // find out if they are penalized for missing tokens\n        bool penalty = offers[_id].missingTokenPenalty;\n\n        // get the offer owner\n        address offerOwner = offers[_id].owner;\n\n        // remove offer from offers mapping\n        offerIds.remove(_id);\n        delete offers[_id];\n\n        // remove offer from owner's offers mapping\n        for (\n            uint256 offerIndex = 0;\n            offerIndex < offersByOwner[offerOwner].length;\n            ++offerIndex\n        ) {\n            if (offersByOwner[offerOwner][offerIndex].gem == _id) {\n                offersByOwner[offerOwner][offerIndex] = offersByOwner[\n                    offerOwner\n                ][offersByOwner[offerOwner].length - 1];\n                offersByOwner[offerOwner].pop();\n            }\n        }\n\n        // give them their fees back if they arent penalized\n        if (!penalty) {\n            // refund listing fee to the owner\n            payable(offerOwner).transfer(_listingFee);\n        }\n\n        // emit the unregistered event\n        emit OfferUnregistered(_id);\n\n        return true;\n    }\n\n    // is an active offer\n    function isOffer(uint256 _id)\n        external\n        view\n        override\n        returns (bool success)\n    {\n        return offerIds.exists(_id);\n    }\n\n    // list all offers\n    function listOffers()\n        external\n        view\n        override\n        returns (Offer[] memory offersOut)\n    {\n        offersOut = new Offer[](offerIds.keyList.length);\n        for (\n            uint256 offerIndex = 0;\n            offerIndex < offerIds.keyList.length;\n            ++offerIndex\n        ) {\n            offersOut[offerIndex] = offers[offerIds.keyList[offerIndex]];\n        }\n    }\n\n    // list all offer ids\n    function listOfferIds()\n        external\n        view\n        override\n        returns (uint256[] memory _offerIds)\n    {\n        _offerIds = offerIds.keyList;\n    }\n\n    // list all offers by owner\n    function listOffersByOwner(address ownerAddress)\n        external\n        view\n        override\n        returns (Offer[] memory _ids)\n    {\n        _ids = offersByOwner[ownerAddress];\n    }\n\n    // get details of an offer\n    function getOffer(uint256 _id)\n        external\n        view\n        override\n        returns (Offer memory)\n    {\n        require(offerIds.exists(_id), \"offer not registered\");\n        return offers[_id];\n    }\n\n    // accept an offer\n    function acceptOffer(uint256 _id, uint256[] memory _gems)\n        external\n        payable\n        override\n        returns (bool success)\n    {\n        // this is capitalism - so figure out our fee first\n        uint256 acceptFee = INFTGemFeeManager(feeManager).fee(acceptFeeHash);\n        acceptFee = acceptFee == 0 ? 0.5 ether : acceptFee;\n\n        // check that the offer is valid\n        require(offerIds.exists(_id), \"offer not registered\");\n        require(msg.value >= acceptFee, \"insufficient accept fee\");\n\n        // how many input pools' rquirements are met. Length of this must equal length of input pools\n        uint256 foundInputPools = 0;\n\n        // iterate through all incoming gems to account for them\n        for (uint256 gemIndex = 0; gemIndex < _gems.length; gemIndex++) {\n            //\n            // we'll need to track the required quantity of each gem\n            uint256 requiredQuantity = 0;\n            uint256 theIncomingGem = _gems[gemIndex]; // the incoming gem we are validating\n            uint256 foundBalance = 0;\n            address thePool;\n\n            // iterate through all input pool requirements for this offer\n            for (\n                uint256 poolIndex = 0;\n                poolIndex < offers[_id].pools.length;\n                poolIndex++\n            ) {\n                uint256 theGemRequirement = offers[_id].gems[poolIndex]; // the gem requirement for the above pool (or 0 if any gem)\n\n                // determine if the gem we are validating is a member of this pool\n                INFTGemMultiToken.TokenType tokenType = INFTComplexGemPoolData(\n                    offers[_id].pools[poolIndex]\n                ).tokenType(_gems[gemIndex]);\n\n                // if it is then get the message senders balance of the gem\n                // and add it to the balance we are tracking\n                if (tokenType == INFTGemMultiToken.TokenType.GEM) {\n                    //\n                    // the gem pool from the offer\n                    thePool = offers[_id].pools[poolIndex];\n\n                    // if we have no balance yet its the first time we have seen the pool\n                    // so increment the total count of input pools we have seen\n                    if (foundBalance == 0) {\n                        foundInputPools++;\n                    }\n\n                    // incement the pool gem balance\n                    foundBalance += IERC1155(address(multitoken)).balanceOf(\n                        msg.sender,\n                        _gems[gemIndex]\n                    );\n\n                    // if the requirement is specific (not 'any') then this is the\n                    // place to check if the gem the pool requires is the gem we are checking\n                    if (theGemRequirement != 0) {\n                        require(\n                            theGemRequirement == theIncomingGem,\n                            \"gem mismatch\"\n                        );\n                    }\n\n                    // grab required quantity so we can see if we have enough\n                    requiredQuantity = offers[_id].quantities[poolIndex];\n                }\n            }\n\n            // if the balance is less than the required quantity then reject\n            require(\n                thePool != address(0) && foundBalance >= requiredQuantity,\n                \"Insufficient gem balance\"\n            );\n            thePool = address(0);\n        }\n        // this tell us if this is is a gem to fantom swap\n        bool isTokenSwap = (offers[_id].pools.length == 0 &&\n            offers[_id].gems.length == 0 &&\n            offers[_id].quantities.length == 1);\n\n        // if this is not a gem to ftm swap\n        if (!isTokenSwap) {\n            // require that the number of pools we have seen is equal to the number of input pools\n            require(\n                offers[_id].pools.length == foundInputPools,\n                \"conditions unsatisfied\"\n            );\n        }\n\n        // check that the offer owner has the token to swap\n        // and penalize them if they do mot have it.\n        if (\n            IERC1155(address(multitoken)).balanceOf(\n                offers[_id].owner,\n                offers[_id].gem\n            ) < offers[_id].quantity\n        ) {\n            // penalize the owner for not having the token\n            offers[_id].missingTokenPenalty = true;\n            success = false;\n\n            // refund the accepter all tokens\n            // they sent for fees or to pay for gem\n            require(payable(msg.sender).send(msg.value), \"refund failed\");\n            return success;\n        }\n\n        console.log(\"acceptOffer: sender balance good\");\n\n        // if this is a gem to ftm swap\n        if (isTokenSwap) {\n            // fee is permillion - unite per million\n            acceptFee = INFTGemFeeManager(feeManager).fee(\n                acceptVariableFeeHash\n            );\n            acceptFee = acceptFee == 0 ? 3000 : acceptFee; // 1000 permillion is 0.1%\n\n            // closing fee is x permillion of the cost of the swap\n            acceptFee = (offers[_id].quantities[0] / 1000000) * acceptFee;\n            require(\n                msg.value >= offers[_id].quantities[0],\n                \"insufficient swap amount\"\n            );\n        }\n\n        address offerPool = offers[_id].pool;\n        uint256 offerHash = offers[_id].gem;\n\n        //if this is a gem to token swap, send the FTM minus fee to seller\n        if (isTokenSwap) {\n            require(\n                payable(offers[_id].owner).send(\n                    offers[_id].quantities[0] - acceptFee\n                ),\n                \"swap failed\"\n            );\n        } else {\n            // swap the gems\n            proxyList[msg.sender] = address(this);\n            IERC1155(address(multitoken)).safeBatchTransferFrom(\n                msg.sender,\n                offers[_id].owner,\n                _gems,\n                offers[_id].quantities,\n                \"\"\n            );\n            delete proxyList[msg.sender];\n        }\n\n        console.log(\"acceptOffer: transfer batch\");\n\n        // swap the gem\n        proxyList[offers[_id].owner] = address(this);\n        IERC1155(address(multitoken)).safeTransferFrom(\n            offers[_id].owner,\n            msg.sender,\n            offers[_id].gem,\n            offers[_id].quantity,\n            \"\"\n        );\n        delete proxyList[offers[_id].owner];\n\n        console.log(\"acceptOffer: transfer gem\");\n\n        // remove the offer\n        offerIds.remove(_id);\n        delete offers[_id];\n\n        emit OfferAccepted(\n            _id,\n            offerPool,\n            offerHash,\n            msg.sender,\n            _gems,\n            acceptFee\n        );\n\n        return true;\n    }\n\n    // withdraw accrued fees\n    function withdrawFees(address _receiver) external override onlyController {\n        require(payable(address(this)).balance > 0, \"no fees to withdraw\");\n        uint256 theBalance = payable(address(this)).balance;\n        payable(_receiver).transfer(theBalance);\n        emit SwapMeetFeesWithdrawn(_receiver, theBalance);\n    }\n\n    // set open state\n    function setOpenState(bool openState) external override onlyController {\n        open = openState;\n        emit SwapMeetIsOpen(open);\n    }\n\n    // is the swap open\n    function isOpen() external view override returns (bool) {\n        return open;\n    }\n\n    // called by the multitoken when a swap is performed by the\n    // swap meet - we temporarily set the operator of the token\n    // via this proxy function, which is called from isApproved()\n    function proxies(address input) external view returns (address) {\n        return proxyList[input];\n    }\n}\n"
    },
    "src/interfaces/ISwapMeet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libs/UInt256Set.sol\";\n\ninterface ISwapMeet {\n    // an offer to swap a gem for some number of other gems\n    struct Offer {\n        uint256 id;\n        address owner;\n        address pool;\n        uint256 gem;\n        uint256 quantity;\n        address[] pools;\n        uint256[] gems;\n        uint256[] quantities;\n        uint256 listingFee;\n        uint256 acceptFee;\n        uint256 references;\n        bool missingTokenPenalty;\n    }\n\n    // an offer is registered with the swap\n    event OfferRegistered(\n        address _from,\n        uint256 _offerId,\n        address _pool,\n        uint256 _gem,\n        uint256 _quantity,\n        address[] _pools,\n        uint256[] _gems,\n        uint256[] _quantities,\n        uint256 _references\n    );\n\n    // an offer is cancelled\n    event OfferUnregistered(uint256 _offerId);\n\n    // an offer is aacepted\n    event OfferAccepted(\n        uint256 _offerId,\n        address _offerPool,\n        uint256 _offerItem,\n        address _acceptor,\n        uint256[] _gems,\n        uint256 _acceptFee\n    );\n\n    // an offer is cancelled\n    event SwapMeetFeesWithdrawn(address _recipient, uint256 _feesAmount);\n\n    // when the meet is opened and closed. closed means\n    // the meet is no longer accepting offers\n    event SwapMeetIsOpen(bool openState);\n\n    // registe a new offer\n    function registerOffer(\n        // what to have to swap\n        address _pool,\n        uint256 _gem,\n        uint256 _quantity,\n        // what you are willing to swap it for\n        address[] calldata _pools,\n        uint256[] calldata _gems,\n        uint256[] calldata _quantities,\n        uint256 _references\n    ) external payable returns (uint256, Offer memory);\n\n    // unregister an offer\n    function unregisterOffer(uint256 _id) external returns (bool);\n\n    // is an active offer\n    function isOffer(uint256 _id) external view returns (bool);\n\n    // list all offers\n    function listOffers() external view returns (Offer[] memory);\n\n    // list all offer ids\n    function listOfferIds() external view returns (uint256[] memory);\n\n    // list all offers\n    function listOffersByOwner(address ownerAddress)\n        external\n        view\n        returns (Offer[] memory);\n\n    // get details of an offer\n    function getOffer(uint256 _id) external view returns (Offer memory);\n\n    // accept an offer\n    function acceptOffer(uint256 _id, uint256[] memory)\n        external\n        payable\n        returns (bool);\n\n    // withdraw the swap meet fees\n    function withdrawFees(address _receiver) external;\n\n    // set the open state of the swap\n    function setOpenState(bool openState) external;\n\n    function isOpen() external view returns (bool);\n}\n"
    },
    "src/interfaces/INFTComplexGemPoolData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./INFTGemMultiToken.sol\";\nimport \"./INFTComplexGemPool.sol\";\n\ninterface INFTComplexGemPoolData {\n    enum PriceIncrementType {\n        COMPOUND,\n        INVERSELOG,\n        NONE\n    }\n\n    /**\n     * @dev a requirement of erc20, erc1155, or nft gem\n     */\n    struct InputRequirement {\n        address token;\n        address pool;\n        INFTComplexGemPool.RequirementType inputType; // 1 = erc20, 2 = erc1155, 3 = pool\n        uint256 tokenId; // if erc20 slot 0 contains required amount\n        uint256 minVal;\n        bool takeCustody;\n        bool burn;\n        bool exactAmount;\n    }\n\n    /**\n     * @dev Event generated when an NFT claim is imported from a legacy contract\n     */\n    event NFTGemImported(\n        address indexed converter,\n        address indexed pool,\n        address oldPool,\n        address oldToken,\n        uint256 indexed gemHash,\n        uint256 quantity\n    );\n\n    function addInputRequirement(\n        address theToken,\n        address pool,\n        INFTComplexGemPool.RequirementType inputType,\n        uint256 theTokenId,\n        uint256 minAmount,\n        bool takeCustody,\n        bool burn,\n        bool exactAmount\n    ) external;\n\n    function updateInputRequirement(\n        uint256 ndx,\n        address theToken,\n        address pool,\n        INFTComplexGemPool.RequirementType inputType,\n        uint256 tid,\n        uint256 minAmount,\n        bool takeCustody,\n        bool burn,\n        bool exactAmount\n    ) external;\n\n    function allInputRequirementsLength() external returns (uint256);\n\n    function allInputRequirements(uint256 ndx)\n        external\n        view\n        returns (\n            address,\n            address,\n            INFTComplexGemPool.RequirementType,\n            uint256,\n            uint256,\n            bool,\n            bool,\n            bool\n        );\n\n    function settings()\n        external\n        view\n        returns (\n            string memory settingsSymbol,\n            string memory settingsName,\n            string memory settingsDescription,\n            uint256 settingsCategory,\n            uint256 settingsEthPrice,\n            uint256 settingsMinTime,\n            uint256 settingsMaxTime,\n            uint256 settingsDiffStep,\n            uint256 settingsMacClaims,\n            uint256 settingsMaxQuantityPerClaim,\n            uint256 settingsMaxClaimsPerAccount\n        );\n\n    function stats()\n        external\n        view\n        returns (\n            bool statsVisible,\n            uint256 statsClaimedCount,\n            uint256 statsMintedCount,\n            uint256 statsTotalStakedEth,\n            uint256 statsNextClaimHash,\n            uint256 statsNextGemHash,\n            uint256 statsNextClaimId,\n            uint256 statsNextGemId\n        );\n\n    function claim(uint256 claimHash)\n        external\n        view\n        returns (\n            uint256 claimClaimAmount,\n            uint256 claimClaimQuantity,\n            uint256 claimClaimUnlockTime,\n            uint256 claimClaimTokenAmount,\n            address claimStakedToken,\n            uint256 claimNextClaimId\n        );\n\n    function token(uint256 tokenHash)\n        external\n        view\n        returns (\n            INFTGemMultiToken.TokenType tokenTokenType,\n            uint256 tokenTokenId,\n            address tokenTokenSource\n        );\n\n    function addAllowedTokenSource(address allowedToken) external;\n\n    function removeAllowedTokenSource(address allowedToken) external;\n\n    function allowedTokenSources() external view returns (address[] memory);\n\n    function importLegacyGem(\n        address pool,\n        address legacyToken,\n        uint256 tokenHash,\n        address recipient,\n        bool burnOld\n    ) external;\n\n    function isLegacyGemImported(address account, uint256 tokenhash)\n        external\n        view\n        returns (bool);\n\n    function setNextIds(uint256 _nextClaimId, uint256 _nextGemId) external;\n\n    function tokenHashes() external view returns (uint256[] memory);\n\n    function setTokenHashes(uint256[] memory inTokenHashes) external;\n\n    // pool is inited with these parameters. Once inited, all\n    // but ethPrice are immutable. ethPrice only increases. ONLY UP\n    function symbol() external view returns (string memory);\n\n    function ethPrice() external view returns (uint256);\n\n    function setVisible(bool isVisible) external;\n\n    function visible() external view returns (bool);\n\n    function setCategory(uint256 theCategory) external;\n\n    function category() external view returns (uint256);\n\n    function setDescription(string memory desc) external;\n\n    function description() external view returns (string memory);\n\n    // these describe the pools created contents over time. This is where\n    // you query to get information about a token that a pool created\n    function claimedCount() external view returns (uint256);\n\n    function claimAmount(uint256 claimId) external view returns (uint256);\n\n    function claimQuantity(uint256 claimId) external view returns (uint256);\n\n    function maxQuantityPerClaim() external view returns (uint256);\n\n    function maxClaimsPerAccount() external view returns (uint256);\n\n    function setMaxQuantityPerClaim(uint256 claimId) external;\n\n    function setMaxClaimsPerAccount(uint256 claimId) external;\n\n    function mintedCount() external view returns (uint256);\n\n    function totalStakedEth() external view returns (uint256);\n\n    function tokenId(uint256 tokenHash) external view returns (uint256);\n\n    function tokenType(uint256 tokenHash)\n        external\n        view\n        returns (INFTGemMultiToken.TokenType);\n\n    function allTokenHashesLength() external view returns (uint256);\n\n    function allTokenHashes(uint256 ndx) external view returns (uint256);\n\n    function nextClaimHash() external view returns (uint256);\n\n    function nextGemHash() external view returns (uint256);\n\n    function nextGemId() external view returns (uint256);\n\n    function nextClaimId() external view returns (uint256);\n\n    function setValidateErc20(bool) external;\n\n    function validateErc20() external view returns (bool);\n\n    function claimUnlockTime(uint256 claimId) external view returns (uint256);\n\n    function claimTokenAmount(uint256 claimId) external view returns (uint256);\n\n    function gemClaimHash(uint256 gemHash) external view returns (uint256);\n\n    function stakedToken(uint256 claimId) external view returns (address);\n\n    function allowedTokensLength() external view returns (uint256);\n\n    function allowedTokens(uint256 idx) external view returns (address);\n\n    function isTokenAllowed(address tkn) external view returns (bool);\n\n    function addAllowedToken(address tkn) external;\n\n    function removeAllowedToken(address tkn) external;\n\n    function allowPurchase() external view returns (bool);\n\n    function setAllowPurchase(bool allow) external;\n\n    function enabled() external view returns (bool);\n\n    function setEnabled(bool enable) external;\n\n    function priceIncrementType() external view returns (PriceIncrementType);\n\n    function setPriceIncrementType(PriceIncrementType incrementType) external;\n}\n"
    },
    "src/interfaces/INFTGemFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface INFTGemFeeManager {\n    event FeeChanged(\n        address indexed operator,\n        uint256 indexed feeHash,\n        uint256 value\n    );\n\n    function fee(uint256 feeTypeHash) external view returns (uint256);\n\n    function setFee(uint256 feeTypeHash, uint256 _fee) external;\n\n    function balanceOf(address token) external view returns (uint256);\n\n    function transferEth(address payable recipient, uint256 amount) external;\n\n    function transferToken(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "src/interfaces/INFTComplexGemPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface INFTComplexGemPool {\n    enum RequirementType {\n        ERC20,\n        ERC1155,\n        POOL\n    }\n\n    /**\n     * @dev Event generated when an NFT claim is created using ETH\n     */\n    event NFTGemClaimCreated(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 length,\n        uint256 quantity,\n        uint256 amountPaid\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is created using ERC20 tokens\n     */\n    event NFTGemERC20ClaimCreated(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 length,\n        address token,\n        uint256 quantity,\n        uint256 conversionRate\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is redeemed\n     */\n    event NFTGemClaimRedeemed(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 amountPaid,\n        uint256 quantity,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is redeemed\n     */\n    event NFTGemERC20ClaimRedeemed(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        address token,\n        uint256 ethPrice,\n        uint256 tokenAmount,\n        uint256 quantity,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when a gem is created\n     */\n    event NFTGemCreated(\n        address account,\n        address pool,\n        uint256 claimHash,\n        uint256 gemHash,\n        uint256 quantity\n    );\n\n    function setMultiToken(address token) external;\n\n    function setGovernor(address addr) external;\n\n    function setFeeTracker(address addr) external;\n\n    function setSwapHelper(address addr) external;\n\n    function mintGenesisGems(address creator, address funder) external;\n\n    function createClaim(uint256 timeframe) external payable;\n\n    function createClaims(uint256 timeframe, uint256 count) external payable;\n\n    function createERC20Claim(address erc20token, uint256 tokenAmount) external;\n\n    function createERC20Claims(\n        address erc20token,\n        uint256 tokenAmount,\n        uint256 count\n    ) external;\n\n    function collectClaim(uint256 claimHash, bool requireMature) external;\n\n    function purchaseGems(uint256 count) external payable;\n\n    function initialize(\n        string memory,\n        string memory,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n"
    },
    "src/test/ERC3156FlashBorrowerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IERC3156FlashBorrower.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract ERC3156FlashBorrowerMock is IERC3156FlashBorrower {\n    bytes32 constant internal RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    bool immutable _enableApprove;\n    bool immutable _enableReturn;\n\n    event BalanceOf(address token, address account, uint256 value);\n    event TotalSupply(address token, uint256 value);\n\n    constructor(bool enableReturn, bool enableApprove) {\n        _enableApprove = enableApprove;\n        _enableReturn = enableReturn;\n    }\n\n    function onFlashLoan(\n        address /*initiator*/,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) public override returns (bytes32) {\n        // require(msg.sender == token, \"\");\n\n        emit BalanceOf(token, address(this), IERC20(token).balanceOf(address(this)));\n        emit TotalSupply(token, IERC20(token).totalSupply());\n\n        if (data.length > 0) {\n            // test code invocation\n        }\n        if (_enableApprove) {\n            IERC20(token).approve(msg.sender, amount + fee);\n        }\n\n        return _enableReturn ? RETURN_VALUE : bytes32(0);\n    }\n}"
    },
    "src/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "src/tokens/ERC20WrappedERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport \"../interfaces/IERC20WrappedERC1155.sol\";\nimport \"./WrappedTokenLib.sol\";\n\n/**\n * @dev Wrap a single ERC1155 token hash into an ERC20 token.\n */\ncontract ERC20WrappedERC1155 is ERC20, ERC1155Holder, IERC20WrappedERC1155 {\n    using WrappedTokenLib for WrappedTokenLib.WrappedTokenData;\n\n    WrappedTokenLib.WrappedTokenData internal tokenData;\n\n    /**\n     * @dev constructor sets up token parameters.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address erc1155Token,\n        uint256 tokenIndex,\n        uint256 exchangeRate\n    ) ERC20(name, symbol) {\n        tokenData.erc1155token = erc1155Token;\n        tokenData.tokenPool = address(0);\n        tokenData.index = tokenIndex;\n        tokenData.tokenType = INFTGemMultiToken.TokenType.GEM;\n        tokenData.rate = exchangeRate;\n        _setupDecimals(decimals);\n    }\n\n    /**\n     * @dev initialize is a stub because this class is deployed by us with constructor params\n     */\n    function initialize(\n        string memory,\n        string memory,\n        address,\n        address,\n        uint8,\n        address\n    ) external override {\n        tokenData.erc20token = address(this);\n    }\n\n    /**\n     * @dev wrap a quantity of tokens by transferring ERC1155 to this contract and minting ERC20 token\n     */\n    function _wrap(uint256 quantity) internal {\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(\n            IERC1155(tokenData.erc1155token).balanceOf(\n                msg.sender,\n                tokenData.index\n            ) >= quantity,\n            \"INSUFFICIENT_ERC1155_BALANCE\"\n        );\n        IERC1155(tokenData.erc1155token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenData.index,\n            quantity,\n            \"\"\n        );\n        _mint(msg.sender, quantity * (tokenData.rate * 10**decimals()));\n    }\n\n    /**\n     * @dev wrap a quantity of erc1155 governance to erc20\n     */\n    function wrap(uint256 quantity) external virtual override {\n        _wrap(quantity);\n    }\n\n    /**\n     * @dev unwrap a quantity of wrapped erc20 governance to erc1155\n     */\n    function _unwrap(uint256 quantity) internal {\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(\n            IERC1155(tokenData.erc1155token).balanceOf(\n                address(this),\n                tokenData.index\n            ) >= quantity,\n            \"INSUFFICIENT_RESERVES\"\n        );\n        require(\n            balanceOf(msg.sender) >=\n                quantity * (tokenData.rate * 10**decimals()),\n            \"INSUFFICIENT_ERC20_BALANCE\"\n        );\n        _burn(msg.sender, quantity * (tokenData.rate * 10**decimals()));\n        IERC1155(tokenData.erc1155token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            tokenData.index,\n            quantity,\n            \"\"\n        );\n    }\n\n    /**\n     * @dev unwrap a quantity of wrapped erc20 governance to erc1155\n     */\n    function unwrap(uint256 quantity) external virtual override {\n        _unwrap(quantity);\n    }\n\n    /**\n     * @dev get reserves held in wrapper\n     */\n    function getReserves() external view override returns (uint256) {\n        return\n            IERC1155(tokenData.erc1155token).balanceOf(\n                address(this),\n                tokenData.index\n            );\n    }\n\n    /**\n     * @dev get the token address this wrapper is bound to\n     */\n    function getTokenAddress() external view override returns (address) {\n        return tokenData.erc1155token;\n    }\n\n    /**\n     * @dev get the token id this wrapper is bound to\n     */\n    function getTokenId() external view override returns (uint256) {\n        return tokenData.index;\n    }\n}\n"
    },
    "src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev sets the decimal value\n     */\n    function _setupDecimals(uint8 _value) internal {\n        _decimals = _value;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/interfaces/IERC20WrappedERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20WrappedERC1155 {\n    function wrap(uint256 quantity) external;\n\n    function unwrap(uint256 quantity) external;\n\n    function getReserves() external returns (uint256);\n\n    function getTokenAddress() external returns (address);\n\n    function getTokenId() external returns (uint256);\n\n    event Wrap(address indexed account, uint256 quantity);\n    event Unwrap(address indexed account, uint256 quantity);\n\n    function initialize(\n        string memory,\n        string memory,\n        address,\n        address,\n        uint8,\n        address\n    ) external;\n}\n"
    },
    "src/tokens/WrappedTokenLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IERC20WrappedGem.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\n\n/**\n * @dev wrapped token library\n */\nlibrary WrappedTokenLib {\n    event Wrap(address indexed account, uint256 quantity);\n    event Unwrap(address indexed account, uint256 quantity);\n\n    /**\n     * @dev data struct for wrapped token\n     */\n    struct WrappedTokenData {\n        address erc1155token;\n        address erc20token;\n        address tokenPool;\n        uint256 index;\n        INFTGemMultiToken.TokenType tokenType;\n        uint256 rate;\n        uint256 wrappedBalance;\n        mapping(address => uint256[]) ids;\n        mapping(address => uint256[]) amounts;\n    }\n\n    /**\n     * @dev get pool balance (number of minted claims or gems) for given token pool, token type, for account\n     */\n    function getPoolTypeBalance(\n        address erc1155token,\n        address tokenPool,\n        INFTGemMultiToken.TokenType tokenType,\n        address account\n    ) public view returns (uint256 tq) {\n        uint256[] memory ht = INFTGemMultiToken(erc1155token).heldTokens(\n            account\n        );\n        for (uint256 i = ht.length - 1; i >= 0; i = i - 1) {\n            uint256 tokenHash = ht[i];\n            (\n                INFTGemMultiToken.TokenType _tokenType,\n                address _tokenPool\n            ) = INFTGemMultiToken(erc1155token).getTokenData(tokenHash);\n            if (_tokenType == tokenType && _tokenPool == tokenPool) {\n                uint256 oq = IERC1155(erc1155token).balanceOf(\n                    account,\n                    tokenHash\n                );\n                tq = tq + oq;\n            }\n            if (i == 0) break;\n        }\n    }\n\n    /**\n     * @dev transfer a given number of claims / gems from account to recipient\n     */\n    function transferPoolTypesFrom(\n        WrappedTokenData storage self,\n        address from,\n        address to,\n        uint256 quantity\n    ) public {\n        uint256 tq = quantity;\n        delete self.ids[to];\n        delete self.amounts[to];\n\n        uint256[] memory ht = INFTGemMultiToken(self.erc1155token).heldTokens(\n            from\n        );\n        for (uint256 i = ht.length - 1; i >= 0 && tq > 0; i = i - 1) {\n            uint256 tokenHash = ht[i];\n            (\n                INFTGemMultiToken.TokenType _tokenType,\n                address _tokenPool\n            ) = INFTGemMultiToken(self.erc1155token).getTokenData(tokenHash);\n            if (_tokenType == self.tokenType && _tokenPool == self.tokenPool) {\n                uint256 oq = IERC1155(self.erc1155token).balanceOf(\n                    from,\n                    tokenHash\n                );\n                uint256 toTransfer = oq > tq ? tq : oq;\n                self.ids[to].push(tokenHash);\n                self.amounts[to].push(toTransfer);\n                tq = tq - toTransfer;\n            }\n            if (i == 0) break;\n        }\n\n        require(tq == 0, \"INSUFFICIENT_GEMS\");\n\n        IERC1155(self.erc1155token).safeBatchTransferFrom(\n            from,\n            to,\n            self.ids[to],\n            self.amounts[to],\n            \"\"\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interfaces/IERC20WrappedGem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./IERC20WrappedERC1155.sol\";\n\n/**\n * @dev A wrapped gem is an erc20 wrapper around an erc1155 token type\n */\ninterface IERC20WrappedGem is IERC20WrappedERC1155 {\n\n}\n"
    },
    "src/nftpix/NiftyPixContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INiftyPixContract.sol\";\n\ncontract NiftyPixContract is INiftyPixContract, Initializable, Ownable {\n    mapping(uint256 => string) private niftyPixMapping;\n    mapping(uint256 => address) private niftyPixGemPool;\n    uint256[] private niftyPixHashes;\n\n    uint256 private mintingFee;\n\n    address[] private nftGemPools;\n    address private multiToken;\n\n    modifier isInitialized() {\n        require(\n            nftGemPools.length != 0 && multiToken != address(0),\n            \"Not initialized\"\n        );\n        _;\n    }\n\n    function initialize(\n        address _nftGemPool,\n        address _multiToken,\n        uint256 _mintingFee\n    ) external initializer {\n        nftGemPools.push(_nftGemPool);\n        multiToken = _multiToken;\n        mintingFee = _mintingFee;\n    }\n\n    function initialized() external view override returns (bool) {\n        return nftGemPools.length != 0 && multiToken != address(0);\n    }\n\n    function transferOwnership(address newOwner) public override onlyOwner {\n        super.transferOwnership(newOwner);\n        emit NiftyPixOwnerChanged(newOwner);\n    }\n\n    function getNiftyPixData(uint256 tokenHash)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        return niftyPixMapping[tokenHash];\n    }\n\n    function _findGemPool(uint256 tokenHash) internal view returns (address) {\n        for (uint256 i = 0; i < nftGemPools.length; i++) {\n            if (\n                INFTComplexGemPoolData(nftGemPools[i]).tokenType(tokenHash) ==\n                INFTGemMultiToken.TokenType.GEM\n            ) return nftGemPools[i];\n        }\n        return address(0);\n    }\n\n    function setNiftyPixData(uint256 tokenHash, string memory tokenData)\n        external\n        payable\n        override\n        isInitialized\n    {\n        require(msg.value >= mintingFee, \"Missing fee\");\n\n        require(\n            bytes(niftyPixMapping[tokenHash]).length == 0,\n            \"Niftypix Data already set\"\n        );\n        require(\n            IERC1155(multiToken).balanceOf(msg.sender, tokenHash) > 0,\n            \"Does not own this token\"\n        );\n        address foundGemPool = _findGemPool(tokenHash);\n        require(foundGemPool != address(0), \"Not a Bitgem Canvas NFT\");\n\n        niftyPixMapping[tokenHash] = tokenData;\n        niftyPixGemPool[tokenHash] = foundGemPool;\n        niftyPixHashes.push(tokenHash);\n\n        emit NiftyPixDataAdded(tokenHash, tokenData);\n    }\n\n    function getNiftyPixTokenHashes()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return niftyPixHashes;\n    }\n\n    function hasNiftyPixData(uint256[] memory tokenHashes)\n        external\n        view\n        override\n        returns (bool[] memory result)\n    {\n        result = new bool[](tokenHashes.length);\n        for (uint256 i = 0; i < tokenHashes.length; i++) {\n            result[i] = bytes(niftyPixMapping[tokenHashes[i]]).length != 0;\n        }\n    }\n\n    function nftGemPoolAddresses()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return nftGemPools;\n    }\n\n    function nftGemTokenAddress() external view override returns (address) {\n        return multiToken;\n    }\n\n    function collectFees(address payable receiver) external override onlyOwner {\n        uint256 feesAmount = address(this).balance;\n        (bool success, ) = receiver.call{value: feesAmount}(\"\");\n        require(success, \"Fees send failed\");\n        emit NiftyPixFeesCollected(receiver, feesAmount);\n    }\n\n    function addNftGemPool(address theAddress) external override onlyOwner {\n        // require the address to not be zero\n        require(theAddress != address(0), \"Address is zero\");\n        for (uint256 i = 0; i < nftGemPools.length; i++) {\n            if (nftGemPools[i] == theAddress) return;\n        }\n        // add the address to the array\n        nftGemPools.push(theAddress);\n    }\n\n    function removeNftGemPool(address theAddress) external override onlyOwner {\n        // require the address to not be zero\n        require(theAddress != address(0), \"Address is zero\");\n        for (uint256 i = 0; i < nftGemPools.length; i++) {\n            if (nftGemPools[i] == theAddress) {\n                if (nftGemPools.length > 1) {\n                    nftGemPools[i] = nftGemPools[nftGemPools.length - 1];\n                }\n                nftGemPools.pop();\n            }\n        }\n    }\n\n    function setMintingFee(uint256 newFee) external override onlyOwner {\n        mintingFee = newFee;\n        emit NiftyPixFeeChanged(newFee);\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return mintingFee;\n    }\n\n    function getFeesBalance() external view override returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/interfaces/INiftyPixContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface INiftyPixContract {\n    event NiftyPixDataAdded(uint256 tokenHash, string tokenData);\n\n    event NiftyPixFeesCollected(address receiver, uint256 amount);\n\n    event NiftyPixFeeChanged(uint256 newFee);\n\n    event NiftyPixOwnerChanged(address newOwner);\n\n    function initialized() external view returns (bool);\n\n    function getNiftyPixData(uint256 tokenHash)\n        external\n        view\n        returns (string memory);\n\n    function setNiftyPixData(uint256 tokenHash, string memory tokenData)\n        external\n        payable;\n\n    function hasNiftyPixData(uint256[] memory tokenHashes)\n        external\n        view\n        returns (bool[] memory);\n\n    function getNiftyPixTokenHashes() external view returns (uint256[] memory);\n\n    function getFeesBalance() external view returns (uint256);\n\n    function collectFees(address payable receiver) external;\n\n    function setMintingFee(uint256 newFee) external;\n\n    function getMintingFee() external view returns (uint256);\n\n    function nftGemPoolAddresses() external view returns (address[] memory);\n\n    function nftGemTokenAddress() external view returns (address);\n\n    function addNftGemPool(address theAddress) external;\n\n    function removeNftGemPool(address theAddress) external;\n\n\n}\n"
    },
    "src/pool/NFTComplexGemPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\nimport \"../interfaces/INFTComplexGemPool.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/ISwapQueryHelper.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IWrappedFtm.sol\";\n\nimport \"../libs/AddressSet.sol\";\n\nimport \"./NFTComplexGemPoolData.sol\";\n\ncontract NFTComplexGemPool is\n    NFTComplexGemPoolData,\n    INFTComplexGemPool,\n    IERC3156FlashLender,\n    ERC1155Holder\n{\n    using AddressSet for AddressSet.Set;\n    using ComplexPoolLib for ComplexPoolLib.ComplexPoolData;\n\n    address private constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;\n\n    /**\n     * @dev Add an address allowed to control this contract\n     */\n    function addController(address _controllerAddress) external {\n        require(\n            poolData.controllers[msg.sender] == true ||\n                address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        poolData.controllers[_controllerAddress] = true;\n    }\n\n    /**\n     * @dev Check if this address is a controller\n     */\n    function isController(address _controllerAddress)\n        external\n        view\n        returns (bool)\n    {\n        return poolData.controllers[_controllerAddress];\n    }\n\n    /**\n     * @dev Remove the sender's address from the list of controllers\n     */\n    function relinquishControl() external {\n        require(\n            poolData.controllers[msg.sender] == true ||\n                address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        delete poolData.controllers[msg.sender];\n    }\n\n    constructor() {\n        poolData.controllers[msg.sender] = true;\n    }\n\n    /**\n     * @dev initializer called when contract is deployed\n     */\n    function initialize(\n        string memory _symbol,\n        string memory _name,\n        uint256 _ethPrice,\n        uint256 _minTime,\n        uint256 _maxTime,\n        uint256 _diffstep,\n        uint256 _maxClaims,\n        address _allowedToken\n    ) external override onlyController {\n        poolData.pool = address(this);\n        poolData.symbol = _symbol;\n        poolData.name = _name;\n        poolData.ethPrice = _ethPrice;\n        poolData.minTime = _minTime;\n        poolData.maxTime = _maxTime;\n        poolData.diffstep = _diffstep;\n        poolData.maxClaims = _maxClaims;\n        poolData.visible = true;\n        poolData.enabled = true;\n        if (_allowedToken != address(0)) {\n            poolData.allowedTokens.insert(_allowedToken);\n        }\n    }\n\n    /**\n     * @dev set the governor. pool uses the governor to issue gov token issuance requests\n     */\n    function setGovernor(address _governorAddress) external override {\n        require(\n            poolData.controllers[msg.sender] =\n                true ||\n                msg.sender == poolData.governor,\n            \"UNAUTHORIZED\"\n        );\n        poolData.governor = _governorAddress;\n    }\n\n    /**\n     * @dev set the fee tracker. pool uses the  fee tracker to issue  fee tracker token issuance requests\n     */\n    function setFeeTracker(address _feeTrackerAddress) external override {\n        require(\n            poolData.controllers[msg.sender] =\n                true ||\n                msg.sender == poolData.governor,\n            \"UNAUTHORIZED\"\n        );\n        poolData.feeTracker = _feeTrackerAddress;\n    }\n\n    /**\n     * @dev set the multitoken that this pool will mint new tokens on. Must be a controller of the multitoken\n     */\n    function setMultiToken(address _multiTokenAddress) external override {\n        require(\n            poolData.controllers[msg.sender] =\n                true ||\n                msg.sender == poolData.governor,\n            \"UNAUTHORIZED\"\n        );\n        poolData.multitoken = _multiTokenAddress;\n    }\n\n    /**\n     * @dev set the AMM swap helper that gets token prices\n     */\n    function setSwapHelper(address _swapHelperAddress) external override {\n        require(\n            poolData.controllers[msg.sender] =\n                true ||\n                msg.sender == poolData.governor,\n            \"UNAUTHORIZED\"\n        );\n        poolData.swapHelper = _swapHelperAddress;\n    }\n\n    /**\n     * @dev mint the genesis gems earned by the pools creator and funder\n     */\n    function mintGenesisGems(address _creatorAddress, address _funderAddress)\n        external\n        override\n    {\n        // security checks for this method are in the library - this\n        // method  may only be  called one time per new pool creation\n        poolData.mintGenesisGems(_creatorAddress, _funderAddress);\n    }\n\n    /**\n     * @dev create a single claim with given timeframe\n     */\n    function createClaim(uint256 _timeframe) external payable override {\n        poolData.createClaims(_timeframe, 1);\n    }\n\n    /**\n     * @dev create multiple claims with given timeframe\n     */\n    function createClaims(uint256 _timeframe, uint256 _count)\n        external\n        payable\n        override\n    {\n        poolData.createClaims(_timeframe, _count);\n    }\n\n    /**\n     * @dev purchase gems\n     */\n    function purchaseGems(uint256 _count) external payable override {\n        poolData.purchaseGems(msg.sender, msg.value, _count);\n    }\n\n    /**\n     * @dev create a claim using a erc20 token\n     */\n    function createERC20Claim(address _erc20TokenAddress, uint256 _tokenAmount)\n        external\n        override\n    {\n        poolData.createERC20Claims(_erc20TokenAddress, _tokenAmount, 1);\n    }\n\n    /**\n     * @dev create a claim using a erc20 token\n     */\n    function createERC20Claims(\n        address _erc20TokenAddress,\n        uint256 _tokenAmount,\n        uint256 _count\n    ) external override {\n        poolData.createERC20Claims(_erc20TokenAddress, _tokenAmount, _count);\n    }\n\n    /**\n     * @dev collect an open claim (take custody of the funds the claim is redeemable for and maybe a gem too)\n     */\n    function collectClaim(uint256 _claimHash, bool _requireMature)\n        external\n        override\n    {\n        poolData.collectClaim(_claimHash, _requireMature);\n    }\n\n    /**\n     * @dev The maximum flash loan amount - 90% of available funds\n     */\n    function maxFlashLoan(address tokenAddress)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // if the token address is zero then get the FTM balance\n        // other wise get the token balance of the given token address\n        // must not revert\n        if (tokenAddress != address(0)) {\n            try IERC20(tokenAddress).balanceOf(address(this)) returns (\n                uint256 balance\n            ) {\n                return balance - balance / 10;\n            } catch {\n                return 0;\n            }\n        }\n        // if the token address is zero then get the FTM balance\n        return address(this).balance - (address(this).balance / 10);\n    }\n\n    /**\n     * @dev The flash loan fee - 0.1% of borrowed funds\n     */\n    function flashFee(address token, uint256 amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // must revert if token balanve is 0 or\n        // if the token address is not a ERC20 token\n        if (token != address(0)) {\n            try IERC20(token).balanceOf(address(this)) returns (\n                uint256 balance\n            ) {\n                require(balance > 0, \"ERC20 token not found\");\n            } catch {\n                require(false, \"ERC20 token not found\");\n            }\n        }\n        // get hash of flash fee key using token address\n        uint256 flashFeeHash = uint256(\n            keccak256(abi.encodePacked(\"flash_loan\", address(token)))\n        );\n        // get the flash fee from the storage\n        uint256 feeDiv = INFTGemFeeManager(poolData.feeTracker).fee(\n            flashFeeHash\n        );\n        // if the flash fee is not set, get the default fee\n        if (feeDiv == 0) {\n            flashFeeHash = uint256(keccak256(abi.encodePacked(\"flash_loan\")));\n            feeDiv = INFTGemFeeManager(poolData.feeTracker).fee(flashFeeHash);\n        }\n        // if no default fee, set the fee to 10000 (0.01%)\n        if (feeDiv == 0) {\n            feeDiv = 10000;\n        }\n        return amount / feeDiv;\n    }\n\n    /**\n     * @dev Perform a flash loan (borrow tokens from the controller and return them after a certain time)\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool) {\n        // get the fee of the flash loan\n        uint256 fee = flashFee(token, amount);\n\n        // get the receiver's address\n        address receiverAddress = address(receiver);\n\n        // no token address means we are sending FTM\n        if (token == address(0)) {\n            // transfer FTM to receiver - we get paid back in WFTM\n            payable(receiverAddress).transfer(amount);\n        } else {\n            // else we are sending erc20 tokens\n            IERC20(token).transfer(receiverAddress, amount);\n        }\n\n        // create success callback hash\n        bytes32 callbackSuccess = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n        // call the flash loan callback\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) ==\n                callbackSuccess,\n            \"FlashMinter: Callback failed\"\n        );\n\n        // if the token is 0 then we have to\n        // get paid in WFTM in order to properly\n        // meter the loan since the erc20 approval\n        // sets us widthdraw a specific amount\n        if (token == address(0)) {\n            token = WFTM;\n        }\n\n        // to get our allowance of the token from the receiver\n        // this is the amount we will be allowed to withdraw\n        // aka the loan repayment amount\n        uint256 _allowance = IERC20(token).allowance(\n            address(receiver),\n            address(this)\n        );\n\n        // if the allowance is greater than the loan amount plus\n        // the fee then we can finish the flash loan\n        require(\n            _allowance >= (amount + fee),\n            \"FlashMinter: Repay not approved\"\n        );\n\n        // transfer the tokens back to the lender\n        IERC20(token).transferFrom(\n            address(receiver),\n            address(this),\n            _allowance\n        );\n\n        // if this is wrapped fantom and wrapped fantom is not\n        // in allowed tokens then this is a repay so unwrap the WFTM\n        if (token == WFTM) {\n            IWrappedFtm(WFTM).withdraw(_allowance);\n        }\n\n        return true;\n    }\n}\n"
    },
    "src/interfaces/INFTGemGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface INFTGemGovernor {\n    function createPool(\n        address owner,\n        address funder,\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external returns (address);\n\n    function createSystemPool(\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external returns (address);\n\n    function initialized() external view returns (bool);\n}\n"
    },
    "src/interfaces/ISwapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ISwapQueryHelper {\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function factory() external view returns (address);\n\n    function COIN() external pure returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function hasPool(address token) external view returns (bool);\n\n    function getReserves(address pair) external view returns (uint256, uint256);\n\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        returns (address[] memory);\n\n    function setFactory(address f) external;\n}\n"
    },
    "src/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "src/interfaces/IWrappedFtm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IWrappedFtm {\n    // deposit wraps received FTM tokens as wFTM in 1:1 ratio by minting\n    // the received amount of FTMs in wFTM on the sender's address.\n    function deposit() external payable returns (uint256);\n\n    // withdraw unwraps FTM tokens by burning specified amount\n    // of wFTM from the caller address and sending the same amount\n    // of FTMs back in exchange.\n    function withdraw(uint256 amount) external returns (uint256);\n}\n"
    },
    "src/pool/NFTComplexGemPoolData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../libs/AddressSet.sol\";\n\nimport \"./ComplexPoolLib.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\nimport \"../interfaces/INFTGemPoolData.sol\";\nimport \"../interfaces/IWrappedFtm.sol\";\n\ncontract NFTComplexGemPoolData is INFTComplexGemPoolData {\n    using AddressSet for AddressSet.Set;\n    using ComplexPoolLib for ComplexPoolLib.ComplexPoolData;\n\n    ComplexPoolLib.ComplexPoolData internal poolData;\n\n    /**\n     * @dev Throws if called by any account not in authorized list\n     */\n    modifier onlyController() {\n        require(\n            poolData.controllers[msg.sender] == true ||\n                msg.sender == poolData.governor ||\n                address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        _;\n    }\n\n    constructor() {\n        poolData.controllers[msg.sender] = true;\n        poolData.controllers[tx.origin] = true;\n    }\n\n    /**\n     * @dev all the tokenhashes (both claim and gem) for this pool\n     */\n    function tokenHashes() external view override returns (uint256[] memory) {\n        return poolData.tokenHashes;\n    }\n\n    /**\n     * @dev set all the token hashes for this pool\n     */\n    function setTokenHashes(uint256[] memory _tokenHashes)\n        external\n        override\n        onlyController\n    {\n        poolData.tokenHashes = _tokenHashes;\n    }\n\n    /**\n     * @dev The symbol for this pool / NFT\n     */\n    function symbol() external view override returns (string memory) {\n        return poolData.symbol;\n    }\n\n    /**\n     * @dev The ether price for this pool / NFT\n     */\n    function ethPrice() external view override returns (uint256) {\n        return poolData.ethPrice;\n    }\n\n    /**\n     * @dev max allowable quantity per claim\n     */\n    function maxQuantityPerClaim() external view override returns (uint256) {\n        return poolData.maxQuantityPerClaim;\n    }\n\n    /**\n     * @dev max claims that can be made on this NFT on any given account\n     */\n    function maxClaimsPerAccount() external view override returns (uint256) {\n        return poolData.maxClaimsPerAccount;\n    }\n\n    /**\n     * @dev update max quantity per claim\n     */\n    function setMaxQuantityPerClaim(uint256 _maxQuantityPerClaim)\n        external\n        override\n        onlyController\n    {\n        poolData.maxQuantityPerClaim = _maxQuantityPerClaim;\n    }\n\n    /**\n     * @dev update max claims that can be made on this NFT\n     */\n    function setMaxClaimsPerAccount(uint256 _maxClaimsPerAccount)\n        external\n        override\n        onlyController\n    {\n        poolData.maxClaimsPerAccount = _maxClaimsPerAccount;\n    }\n\n    /**\n     * @dev returns if pool allows purchase\n     */\n    function allowPurchase() external view override returns (bool) {\n        return poolData.allowPurchase;\n    }\n\n    /**\n     * @dev set whether pool allows purchase\n     */\n    function setAllowPurchase(bool _allowPurchase)\n        external\n        override\n        onlyController\n    {\n        poolData.allowPurchase = _allowPurchase;\n    }\n\n    /**\n     * @dev is pool enabled (taking claim requests)\n     */\n    function enabled() external view override returns (bool) {\n        return poolData.enabled;\n    }\n\n    /**\n     * @dev set the enabled status of this pool\n     */\n    function setEnabled(bool _enabled) external override onlyController {\n        poolData.enabled = _enabled;\n    }\n\n    /**\n     * @dev return the appreciation curve of this pool.\n     */\n    function priceIncrementType()\n        external\n        view\n        override\n        returns (PriceIncrementType)\n    {\n        return poolData.priceIncrementType;\n    }\n\n    /**\n     * @dev set the appreciation curve of this pool.\n     */\n    function setPriceIncrementType(PriceIncrementType _incrementType)\n        external\n        override\n        onlyController\n    {\n        poolData.priceIncrementType = _incrementType;\n    }\n\n    /**\n     * @dev return the number of claims made thus far\n     */\n    function claimedCount() external view override returns (uint256) {\n        return poolData.nextClaimIdVal;\n    }\n\n    /**\n     * @dev return the number of gems made thus far\n     */\n    function mintedCount() external view override returns (uint256) {\n        return poolData.nextGemIdVal;\n    }\n\n    /**\n     * @dev the total amopunt of staked eth in this pool\n     */\n    function totalStakedEth() external view override returns (uint256) {\n        return poolData.totalStakedEth;\n    }\n\n    /**\n     * @dev get token type of hash - 1 is for claim, 2 is for gem\n     */\n    function tokenType(uint256 _tokenHash)\n        external\n        view\n        override\n        returns (INFTGemMultiToken.TokenType)\n    {\n        return poolData.tokenTypes[_tokenHash];\n    }\n\n    /**\n     * @dev get the claim hash of the gem\n     */\n    function gemClaimHash(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.gemClaims[_claimHash];\n    }\n\n    /**\n     * @dev get token id (serial #) of the given token hash. 0 if not a token, 1 if claim, 2 if gem\n     */\n    function tokenId(uint256 _tokenHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.tokenIds[_tokenHash];\n    }\n\n    /**\n     * @dev returns a count of all token hashes\n     */\n    function allTokenHashesLength() external view override returns (uint256) {\n        return poolData.tokenHashes.length;\n    }\n\n    /**\n     * @dev get the token hash at index\n     */\n    function allTokenHashes(uint256 ndx)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.tokenHashes[ndx];\n    }\n\n    /**\n     * @dev return the next claim hash\n     */\n    function nextClaimHash() external view override returns (uint256) {\n        return poolData.nextClaimHash();\n    }\n\n    /**\n     * @dev return the next gem hash\n     */\n    function nextGemHash() external view override returns (uint256) {\n        return poolData.nextGemHash();\n    }\n\n    /**\n     * @dev return the next claim id\n     */\n    function nextClaimId() external view override returns (uint256) {\n        return poolData.nextClaimIdVal;\n    }\n\n    /**\n     * @dev return the next gem id\n     */\n    function nextGemId() external view override returns (uint256) {\n        return poolData.nextGemIdVal;\n    }\n\n    /**\n     * @dev return the count of allowed tokens\n     */\n    function allowedTokensLength() external view override returns (uint256) {\n        return poolData.allowedTokens.count();\n    }\n\n    /**\n     * @dev the allowed token address at index\n     */\n    function allowedTokens(uint256 _index)\n        external\n        view\n        override\n        returns (address)\n    {\n        return poolData.allowedTokens.keyAtIndex(_index);\n    }\n\n    /**\n     * @dev add an allowed token to the pool\n     */\n    function addAllowedToken(address _tokenAddress)\n        external\n        override\n        onlyController\n    {\n        poolData.allowedTokens.insert(_tokenAddress);\n    }\n\n    /**\n     * @dev add an allowed token to the pool\n     */\n    function removeAllowedToken(address _tokenAddress)\n        external\n        override\n        onlyController\n    {\n        poolData.allowedTokens.remove(_tokenAddress);\n    }\n\n    /**\n     * @dev is the token in the allowed tokens list\n     */\n    function isTokenAllowed(address _tokenAddress)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return poolData.allowedTokens.exists(_tokenAddress);\n    }\n\n    /**\n     * @dev the claim amount for the given claim id\n     */\n    function claimAmount(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.claimAmount(_claimHash);\n    }\n\n    /**\n     * @dev the claim quantity (count of gems staked) for the given claim id\n     */\n    function claimQuantity(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.claimQuantity(_claimHash);\n    }\n\n    /**\n     * @dev the lock time for this claim. once past lock time a gema is minted\n     */\n    function claimUnlockTime(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.claimUnlockTime(_claimHash);\n    }\n\n    /**\n     * @dev claim token amount if paid using erc20\n     */\n    function claimTokenAmount(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.claimTokenAmount(_claimHash);\n    }\n\n    /**\n     * @dev the staked token if staking with erc20\n     */\n    function stakedToken(uint256 _claimHash)\n        external\n        view\n        override\n        returns (address)\n    {\n        return poolData.stakedToken(_claimHash);\n    }\n\n    /**\n     * @dev set market visibility\n     */\n    function setVisible(bool _visible) external override onlyController {\n        poolData.visible = _visible;\n    }\n\n    /**\n     * @dev set market visibility\n     */\n    function visible() external view override returns (bool) {\n        return poolData.visible;\n    }\n\n    /**\n     * @dev set category category\n     */\n    function setCategory(uint256 _category) external override onlyController {\n        poolData.category = _category;\n    }\n\n    /**\n     * @dev get market category\n     */\n    function category() external view override returns (uint256) {\n        return poolData.category;\n    }\n\n    /**\n     * @dev set description\n     */\n    function setDescription(string memory desc)\n        external\n        override\n        onlyController\n    {\n        poolData.description = desc;\n    }\n\n    /**\n     * @dev get description\n     */\n    function description() external view override returns (string memory) {\n        return poolData.description;\n    }\n\n    /**\n     * @dev set validate erc20 token against AMM\n     */\n    function setValidateErc20(bool) external override onlyController {\n        poolData.validateerc20 = true;\n    }\n\n    /**\n     * @dev get validate erc20 token against AMM\n     */\n    function validateErc20() external view override returns (bool) {\n        return poolData.validateerc20;\n    }\n\n    /**\n     * @dev add an input requirement for this token\n     */\n    function addInputRequirement(\n        address _tokenAddress,\n        address _poolAddress,\n        INFTComplexGemPool.RequirementType _inputType,\n        uint256 _tokenId,\n        uint256 _minAmount,\n        bool _takeCustody,\n        bool _burn,\n        bool _exactAmount\n    ) external override {\n        poolData.addInputRequirement(\n            _tokenAddress,\n            _poolAddress,\n            _inputType,\n            _tokenId,\n            _minAmount,\n            _takeCustody,\n            _burn,\n            _exactAmount\n        );\n    }\n\n    /**\n     * @dev add an input requirement for this token\n     */\n    function updateInputRequirement(\n        uint256 _index,\n        address _tokenAddress,\n        address _poolAddress,\n        INFTComplexGemPool.RequirementType _inputType,\n        uint256 _tokenId,\n        uint256 _minAmount,\n        bool _takeCustody,\n        bool _burn,\n        bool _exactAmount\n    ) external override {\n        poolData.updateInputRequirement(\n            _index,\n            _tokenAddress,\n            _poolAddress,\n            _inputType,\n            _tokenId,\n            _minAmount,\n            _takeCustody,\n            _burn,\n            _exactAmount\n        );\n    }\n\n    /**\n     * @dev all Input Requirements Length\n     */\n    function allInputRequirementsLength()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.allInputRequirementsLength();\n    }\n\n    /**\n     * @dev all Input Requirements at element\n     */\n    function allInputRequirements(uint256 _index)\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            INFTComplexGemPool.RequirementType,\n            uint256,\n            uint256,\n            bool,\n            bool,\n            bool\n        )\n    {\n        return poolData.allInputRequirements(_index);\n    }\n\n    /**\n     * @dev add an allowed token source\n     */\n    function addAllowedTokenSource(address _allowedToken) external override {\n        if (!poolData.allowedTokenSources.exists(_allowedToken)) {\n            poolData.allowedTokenSources.insert(_allowedToken);\n        }\n    }\n\n    /**\n     * @dev remove an allowed token source\n     */\n    function removeAllowedTokenSource(address _allowedToken) external override {\n        if (poolData.allowedTokenSources.exists(_allowedToken)) {\n            poolData.allowedTokenSources.remove(_allowedToken);\n        }\n    }\n\n    /**\n     * @dev returns an array of all allowed token sources\n     */\n    function allowedTokenSources()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return poolData.allowedTokenSources.keyList;\n    }\n\n    /**\n     * @dev delegate proxy method for multitoken allow\n     */\n    function proxies(address) external view returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev these settings defines how the pool behaves\n     */\n    function settings()\n        external\n        view\n        override\n        returns (\n            string memory,\n            string memory,\n            string memory,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            poolData.symbol,\n            poolData.name,\n            poolData.description,\n            poolData.category,\n            poolData.ethPrice,\n            poolData.minTime,\n            poolData.maxTime,\n            poolData.diffstep,\n            poolData.maxClaims,\n            poolData.maxQuantityPerClaim,\n            poolData.maxClaimsPerAccount\n        );\n    }\n\n    /**\n     * @dev these stats reflect the current pool state\n     */\n    function stats()\n        external\n        view\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            poolData.visible,\n            poolData.nextClaimIdVal,\n            poolData.nextGemIdVal,\n            poolData.totalStakedEth,\n            poolData.nextClaimHash(),\n            poolData.nextGemHash(),\n            poolData.nextClaimIdVal,\n            poolData.nextGemIdVal\n        );\n    }\n\n    /**\n     * @dev return the claim details for the given claim hash\n     */\n    function claim(uint256 claimHash)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (\n            poolData.claimAmount(claimHash),\n            poolData.claimQuantity(claimHash),\n            poolData.claimUnlockTime(claimHash),\n            poolData.claimTokenAmount(claimHash),\n            poolData.stakedToken(claimHash),\n            poolData.nextClaimIdVal\n        );\n    }\n\n    /**\n     * @dev return the token data for the given hash\n     */\n    function token(uint256 _tokenHash)\n        external\n        view\n        override\n        returns (\n            INFTGemMultiToken.TokenType,\n            uint256,\n            address\n        )\n    {\n        return (\n            poolData.tokenTypes[_tokenHash],\n            poolData.tokenIds[_tokenHash],\n            poolData.tokenSources[_tokenHash]\n        );\n    }\n\n    /**\n     * @dev import the legacy gem\n     */\n    function importLegacyGem(\n        address _poolAddress,\n        address _legacyToken,\n        uint256 _tokenHash,\n        address _recipient,\n        bool _burnOld\n    ) external override {\n        // this method is callable by anyone - this is used to import historical\n        // gems into the new contracts. A gem can only be imported in once\n        // per source\n        require(_tokenHash > 0, \"INVALID_TOKENHASH\");\n        require(_poolAddress > address(0), \"INVALID_POOL\");\n        require(_legacyToken > address(0), \"INVALID_TOKEN\");\n        require(_recipient > address(0), \"INVALID_RECIPIENT\");\n        require(\n            poolData.allowedTokenSources.exists(_legacyToken) == true,\n            \"INVALID_TOKENSOURCE\"\n        );\n        // get legacy token quantity\n        uint256 quantity = IERC1155(_legacyToken).balanceOf(\n            _recipient,\n            _tokenHash\n        );\n        // require some amount to import\n        require(quantity > 0, \"NOTHING_TO_IMPORT\");\n        // if we are to burn old tokens do it now\n        if (_burnOld == true) {\n            INFTGemMultiToken(_legacyToken).burn(\n                _recipient,\n                _tokenHash,\n                quantity\n            );\n            // and exit if we have already imported them. this logic\n            // lets us import without burning the old tokens first,\n            // and then burn them afterwards\n            if (\n                poolData.importedLegacyToken[_tokenHash][_recipient] >= quantity\n            ) {\n                return;\n            }\n        }\n        // require that the token is not already imported\n        require(\n            poolData.importedLegacyToken[_tokenHash][_recipient] < quantity,\n            \"ALREADY_IMPORTED\"\n        );\n\n        // rebuild the poolhash to make sure its correct\n        bytes32 importedSymHash = keccak256(\n            abi.encodePacked(INFTGemPoolData(_poolAddress).symbol())\n        );\n        bytes32 poolSymHash = keccak256(abi.encodePacked(poolData.symbol));\n        require(importedSymHash == poolSymHash, \"INVALID_POOLHASH\");\n\n        // get the token type from the legacy token\n        INFTGemMultiToken.TokenType importTokenTYpe = INFTGemPoolData(\n            _poolAddress\n        ).tokenType(_tokenHash);\n\n        // only import tokens that are gems\n        require(\n            importTokenTYpe == INFTGemMultiToken.TokenType.GEM,\n            \"NOT_A_GEM\"\n        );\n        // get the token id from the legacy token\n        uint256 importTokenId = INFTGemPoolData(_poolAddress).tokenId(\n            _tokenHash\n        );\n\n        // store import data\n        poolData.tokenTypes[_tokenHash] = importTokenTYpe;\n        poolData.tokenIds[_tokenHash] = importTokenId;\n        poolData.tokenSources[_tokenHash] = _legacyToken;\n        poolData.importedLegacyToken[_tokenHash][_recipient] = quantity;\n\n        // mint the token hash on the new token\n        INFTGemMultiToken(poolData.multitoken).mint(\n            _recipient,\n            _tokenHash,\n            quantity\n        );\n        // set the token data\n        INFTGemMultiToken(poolData.multitoken).setTokenData(\n            _tokenHash,\n            INFTGemMultiToken.TokenType.GEM,\n            address(this)\n        );\n\n        emit NFTGemImported(\n            msg.sender,\n            address(this),\n            _poolAddress,\n            _legacyToken,\n            _tokenHash,\n            quantity\n        );\n    }\n\n    /**\n     * @dev returns if legacy gem with given hash is imported\n     */\n    function isLegacyGemImported(address _account, uint256 _tokenhash)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return poolData.importedLegacyToken[_tokenhash][_account] > 0;\n    }\n\n    /**\n     * @dev set the next claim and gem ids\n     */\n    function setNextIds(uint256 _nextClaimId, uint256 _nextGemId)\n        external\n        override\n        onlyController\n    {\n        poolData.nextClaimIdVal = _nextClaimId;\n        poolData.nextGemIdVal = _nextGemId;\n    }\n}\n"
    },
    "src/pool/ComplexPoolLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\nimport \"../interfaces/ISwapQueryHelper.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/INFTComplexGemPool.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\nimport \"../libs/AddressSet.sol\";\n\nlibrary ComplexPoolLib {\n    using AddressSet for AddressSet.Set;\n    address private constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;\n    /**\n     * @dev Event generated when an NFT claim is created using base currency\n     */\n    event NFTGemClaimCreated(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 length,\n        uint256 quantity,\n        uint256 amountPaid\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is created using ERC20 tokens\n     */\n    event NFTGemERC20ClaimCreated(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 length,\n        address token,\n        uint256 quantity,\n        uint256 conversionRate\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is redeemed\n     */\n    event NFTGemClaimRedeemed(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 amountPaid,\n        uint256 quantity,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when an NFT erc20 claim is redeemed\n     */\n    event NFTGemERC20ClaimRedeemed(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        address token,\n        uint256 ethPrice,\n        uint256 tokenAmount,\n        uint256 quantity,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when a gem is created\n     */\n    event NFTGemCreated(\n        address account,\n        address pool,\n        uint256 claimHash,\n        uint256 gemHash,\n        uint256 quantity\n    );\n\n    /**\n     * @dev data describes complex pool\n     */\n    struct ComplexPoolData {\n        // governor and multitoken target\n        address pool;\n        address multitoken;\n        address governor;\n        address feeTracker;\n        address swapHelper;\n        uint256 category;\n        bool visible;\n        // it all starts with a symbol and a nams\n        string symbol;\n        string name;\n        string description;\n        // magic economy numbers\n        uint256 ethPrice;\n        uint256 minTime;\n        uint256 maxTime;\n        uint256 diffstep;\n        uint256 maxClaims;\n        uint256 maxQuantityPerClaim;\n        uint256 maxClaimsPerAccount;\n        bool validateerc20;\n        bool allowPurchase;\n        bool enabled;\n        INFTComplexGemPoolData.PriceIncrementType priceIncrementType;\n        mapping(uint256 => INFTGemMultiToken.TokenType) tokenTypes;\n        mapping(uint256 => uint256) tokenIds;\n        mapping(uint256 => address) tokenSources;\n        AddressSet.Set allowedTokenSources;\n        uint256[] tokenHashes;\n        // next ids of things\n        uint256 nextGemIdVal;\n        uint256 nextClaimIdVal;\n        uint256 totalStakedEth;\n        // records claim timestamp / ETH value / ERC token and amount sent\n        mapping(uint256 => uint256) claimLockTimestamps;\n        mapping(uint256 => address) claimLockToken;\n        mapping(uint256 => uint256) claimAmountPaid;\n        mapping(uint256 => uint256) claimQuant;\n        mapping(uint256 => uint256) claimTokenAmountPaid;\n        mapping(uint256 => mapping(address => uint256)) importedLegacyToken;\n        // input NFTs storage\n        mapping(uint256 => uint256) gemClaims;\n        mapping(uint256 => uint256[]) claimIds;\n        mapping(uint256 => uint256[]) claimQuantities;\n        mapping(address => bool) controllers;\n        mapping(address => uint256) claimsMade;\n        INFTComplexGemPoolData.InputRequirement[] inputRequirements;\n        AddressSet.Set allowedTokens;\n    }\n\n    function checkGemRequirement(\n        ComplexPoolData storage self,\n        uint256 _inputIndex,\n        address _holderAddress,\n        uint256 _quantity\n    ) internal view returns (address) {\n        address gemtoken;\n        int256 required = int256(\n            self.inputRequirements[_inputIndex].minVal * _quantity\n        );\n        uint256[] memory hashes = INFTGemMultiToken(\n            self.inputRequirements[_inputIndex].token\n        ).heldTokens(_holderAddress);\n        for (\n            uint256 _hashIndex = 0;\n            _hashIndex < hashes.length;\n            _hashIndex += 1\n        ) {\n            uint256 hashAt = hashes[_hashIndex];\n            if (\n                INFTComplexGemPoolData(self.inputRequirements[_inputIndex].pool)\n                .tokenType(hashAt) == INFTGemMultiToken.TokenType.GEM\n            ) {\n                gemtoken = self.inputRequirements[_inputIndex].token;\n                uint256 balance = IERC1155(\n                    self.inputRequirements[_inputIndex].token\n                ).balanceOf(_holderAddress, hashAt);\n                if (balance > uint256(required)) {\n                    balance = uint256(required);\n                }\n                if (balance == 0) {\n                    continue;\n                }\n                required = required - int256(balance);\n            }\n            if (\n                required == 0 &&\n                self.inputRequirements[_inputIndex].exactAmount == false\n            ) {\n                break;\n            }\n            if (required < 0) {\n                require(required == 0, \"EXACT_AMOUNT_REQUIRED\");\n            }\n        }\n        require(required == 0, \"UNMET_GEM_REQUIREMENT\");\n        return gemtoken;\n    }\n\n    /**\n     * @dev checks to see that account owns all the pool requirements needed to mint at least the given quantity of NFT\n     */\n    function requireInputReqs(\n        ComplexPoolData storage self,\n        address _holderAddress,\n        uint256 _quantity\n    ) public view {\n        for (\n            uint256 _inputIndex = 0;\n            _inputIndex < self.inputRequirements.length;\n            _inputIndex += 1\n        ) {\n            if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.ERC20\n            ) {\n                require(\n                    IERC20(self.inputRequirements[_inputIndex].token).balanceOf(\n                        _holderAddress\n                    ) >=\n                        self.inputRequirements[_inputIndex].minVal *\n                            (_quantity),\n                    \"UNMET_ERC20_REQUIREMENT\"\n                );\n            } else if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.ERC1155\n            ) {\n                require(\n                    IERC1155(self.inputRequirements[_inputIndex].token)\n                    .balanceOf(\n                        _holderAddress,\n                        self.inputRequirements[_inputIndex].tokenId\n                    ) >=\n                        self.inputRequirements[_inputIndex].minVal *\n                            (_quantity),\n                    \"UNMET_ERC1155_REQUIREMENT\"\n                );\n            } else if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.POOL\n            ) {\n                checkGemRequirement(\n                    self,\n                    _inputIndex,\n                    _holderAddress,\n                    _quantity\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Transfer a quantity of input reqs from to\n     */\n    function takeInputReqsFrom(\n        ComplexPoolData storage self,\n        uint256 _claimHash,\n        address _fromAddress,\n        uint256 _quantity\n    ) internal {\n        address gemtoken;\n        for (\n            uint256 _inputIndex = 0;\n            _inputIndex < self.inputRequirements.length;\n            _inputIndex += 1\n        ) {\n            if (!self.inputRequirements[_inputIndex].takeCustody) {\n                continue;\n            }\n            if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.ERC20\n            ) {\n                IERC20 token = IERC20(\n                    self.inputRequirements[_inputIndex].token\n                );\n                token.transferFrom(\n                    _fromAddress,\n                    self.pool,\n                    self.inputRequirements[_inputIndex].minVal * (_quantity)\n                );\n            } else if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.ERC1155\n            ) {\n                IERC1155 token = IERC1155(\n                    self.inputRequirements[_inputIndex].token\n                );\n                token.safeTransferFrom(\n                    _fromAddress,\n                    self.pool,\n                    self.inputRequirements[_inputIndex].tokenId,\n                    self.inputRequirements[_inputIndex].minVal * (_quantity),\n                    \"\"\n                );\n            } else if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.POOL\n            ) {\n                gemtoken = checkGemRequirement(\n                    self,\n                    _inputIndex,\n                    _fromAddress,\n                    _quantity\n                );\n            }\n        }\n\n        if (self.claimIds[_claimHash].length > 0 && gemtoken != address(0)) {\n            IERC1155(gemtoken).safeBatchTransferFrom(\n                _fromAddress,\n                self.pool,\n                self.claimIds[_claimHash],\n                self.claimQuantities[_claimHash],\n                \"\"\n            );\n        }\n    }\n\n    /**\n     * @dev Return the returnable input requirements for claimhash to account\n     */\n    function returnInputReqsTo(\n        ComplexPoolData storage self,\n        uint256 _claimHash,\n        address _toAddress,\n        uint256 _quantity\n    ) internal {\n        address gemtoken;\n        for (uint256 i = 0; i < self.inputRequirements.length; i++) {\n            if (\n                self.inputRequirements[i].inputType ==\n                INFTComplexGemPool.RequirementType.ERC20 &&\n                self.inputRequirements[i].burn == false &&\n                self.inputRequirements[i].takeCustody == true\n            ) {\n                IERC20 token = IERC20(self.inputRequirements[i].token);\n                token.transferFrom(\n                    self.pool,\n                    _toAddress,\n                    self.inputRequirements[i].minVal * (_quantity)\n                );\n            } else if (\n                self.inputRequirements[i].inputType ==\n                INFTComplexGemPool.RequirementType.ERC1155 &&\n                self.inputRequirements[i].burn == false &&\n                self.inputRequirements[i].takeCustody == true\n            ) {\n                IERC1155 token = IERC1155(self.inputRequirements[i].token);\n                token.safeTransferFrom(\n                    self.pool,\n                    _toAddress,\n                    self.inputRequirements[i].tokenId,\n                    self.inputRequirements[i].minVal * (_quantity),\n                    \"\"\n                );\n            } else if (\n                self.inputRequirements[i].inputType ==\n                INFTComplexGemPool.RequirementType.POOL &&\n                self.inputRequirements[i].burn == false &&\n                self.inputRequirements[i].takeCustody == true\n            ) {\n                gemtoken = self.inputRequirements[i].token;\n            }\n        }\n        if (self.claimIds[_claimHash].length > 0 && gemtoken != address(0)) {\n            IERC1155(gemtoken).safeBatchTransferFrom(\n                self.pool,\n                _toAddress,\n                self.claimIds[_claimHash],\n                self.claimQuantities[_claimHash],\n                \"\"\n            );\n        }\n    }\n\n    /**\n     * @dev add an input requirement for this token\n     */\n    function addInputRequirement(\n        ComplexPoolData storage self,\n        address token,\n        address pool,\n        INFTComplexGemPool.RequirementType inputType,\n        uint256 tokenId,\n        uint256 minAmount,\n        bool takeCustody,\n        bool burn,\n        bool exactAmount\n    ) public {\n        require(token != address(0), \"INVALID_TOKEN\");\n        require(\n            inputType == INFTComplexGemPool.RequirementType.ERC20 ||\n                inputType == INFTComplexGemPool.RequirementType.ERC1155 ||\n                inputType == INFTComplexGemPool.RequirementType.POOL,\n            \"INVALID_INPUTTYPE\"\n        );\n        require(\n            (inputType == INFTComplexGemPool.RequirementType.POOL &&\n                pool != address(0)) ||\n                inputType != INFTComplexGemPool.RequirementType.POOL,\n            \"INVALID_POOL\"\n        );\n        require(\n            (inputType == INFTComplexGemPool.RequirementType.ERC20 &&\n                tokenId == 0) ||\n                inputType == INFTComplexGemPool.RequirementType.ERC1155 ||\n                (inputType == INFTComplexGemPool.RequirementType.POOL &&\n                    tokenId == 0),\n            \"INVALID_TOKENID\"\n        );\n        require(minAmount != 0, \"ZERO_AMOUNT\");\n        require(!(!takeCustody && burn), \"INVALID_TOKENSTATE\");\n        self.inputRequirements.push(\n            INFTComplexGemPoolData.InputRequirement(\n                token,\n                pool,\n                inputType,\n                tokenId,\n                minAmount,\n                takeCustody,\n                burn,\n                exactAmount\n            )\n        );\n    }\n\n    /**\n     * @dev update input requirement at index\n     */\n    function updateInputRequirement(\n        ComplexPoolData storage self,\n        uint256 _index,\n        address _tokenAddress,\n        address _poolAddress,\n        INFTComplexGemPool.RequirementType _inputRequirementType,\n        uint256 _tokenId,\n        uint256 _minAmount,\n        bool _takeCustody,\n        bool _burn,\n        bool _exactAmount\n    ) public {\n        require(_index < self.inputRequirements.length, \"OUT_OF_RANGE\");\n        require(_tokenAddress != address(0), \"INVALID_TOKEN\");\n        require(\n            _inputRequirementType == INFTComplexGemPool.RequirementType.ERC20 ||\n                _inputRequirementType ==\n                INFTComplexGemPool.RequirementType.ERC1155 ||\n                _inputRequirementType ==\n                INFTComplexGemPool.RequirementType.POOL,\n            \"INVALID_INPUTTYPE\"\n        );\n        require(\n            (_inputRequirementType == INFTComplexGemPool.RequirementType.POOL &&\n                _poolAddress != address(0)) ||\n                _inputRequirementType !=\n                INFTComplexGemPool.RequirementType.POOL,\n            \"INVALID_POOL\"\n        );\n        require(\n            (_inputRequirementType ==\n                INFTComplexGemPool.RequirementType.ERC20 &&\n                _tokenId == 0) ||\n                _inputRequirementType ==\n                INFTComplexGemPool.RequirementType.ERC1155 ||\n                (_inputRequirementType ==\n                    INFTComplexGemPool.RequirementType.POOL &&\n                    _tokenId == 0),\n            \"INVALID_TOKENID\"\n        );\n        require(_minAmount != 0, \"ZERO_AMOUNT\");\n        require(!(!_takeCustody && _burn), \"INVALID_TOKENSTATE\");\n        self.inputRequirements[_index] = INFTComplexGemPoolData\n        .InputRequirement(\n            _tokenAddress,\n            _poolAddress,\n            _inputRequirementType,\n            _tokenId,\n            _minAmount,\n            _takeCustody,\n            _burn,\n            _exactAmount\n        );\n    }\n\n    /**\n     * @dev count of input requirements\n     */\n    function allInputRequirementsLength(ComplexPoolData storage self)\n        public\n        view\n        returns (uint256)\n    {\n        return self.inputRequirements.length;\n    }\n\n    /**\n     * @dev input requirements at index\n     */\n    function allInputRequirements(ComplexPoolData storage self, uint256 _index)\n        public\n        view\n        returns (\n            address,\n            address,\n            INFTComplexGemPool.RequirementType,\n            uint256,\n            uint256,\n            bool,\n            bool,\n            bool\n        )\n    {\n        require(_index < self.inputRequirements.length, \"OUT_OF_RANGE\");\n        INFTComplexGemPoolData.InputRequirement memory req = self\n        .inputRequirements[_index];\n        return (\n            req.token,\n            req.pool,\n            req.inputType,\n            req.tokenId,\n            req.minVal,\n            req.takeCustody,\n            req.burn,\n            req.exactAmount\n        );\n    }\n\n    /**\n     * @dev attempt to create a claim using the given timeframe with count\n     */\n    function createClaims(\n        ComplexPoolData storage self,\n        uint256 _timeframe,\n        uint256 _count\n    ) public {\n        // enabled\n        require(self.enabled == true, \"DISABLED\");\n        // minimum timeframe\n        require(_timeframe >= self.minTime, \"TIMEFRAME_TOO_SHORT\");\n        // no ETH\n        require(msg.value != 0, \"ZERO_BALANCE\");\n        // zero qty\n        require(_count != 0, \"ZERO_QUANTITY\");\n        // maximum timeframe\n        require(\n            (self.maxTime != 0 && _timeframe <= self.maxTime) ||\n                self.maxTime == 0,\n            \"TIMEFRAME_TOO_LONG\"\n        );\n        // max quantity per claim\n        require(\n            (self.maxQuantityPerClaim != 0 &&\n                _count <= self.maxQuantityPerClaim) ||\n                self.maxQuantityPerClaim == 0,\n            \"MAX_QUANTITY_EXCEEDED\"\n        );\n        require(\n            (self.maxClaimsPerAccount != 0 &&\n                self.claimsMade[msg.sender] < self.maxClaimsPerAccount) ||\n                self.maxClaimsPerAccount == 0,\n            \"MAX_QUANTITY_EXCEEDED\"\n        );\n\n        uint256 adjustedBalance = msg.value / (_count);\n        // cost given this timeframe\n\n        uint256 cost = (self.ethPrice * (self.minTime)) / (_timeframe);\n        require(adjustedBalance >= cost, \"INSUFFICIENT_ETH\");\n\n        // get the nest claim hash, revert if no more claims\n        uint256 claimHash = nextClaimHash(self);\n        require(claimHash != 0, \"NO_MORE_CLAIMABLE\");\n\n        // require the user to have the input requirements\n        requireInputReqs(self, msg.sender, _count);\n\n        // mint the new claim to the caller's address\n        INFTGemMultiToken(self.multitoken).mint(msg.sender, claimHash, 1);\n        INFTGemMultiToken(self.multitoken).setTokenData(\n            claimHash,\n            INFTGemMultiToken.TokenType.CLAIM,\n            address(this)\n        );\n        addToken(self, claimHash, INFTGemMultiToken.TokenType.CLAIM);\n\n        // record the claim unlock time and cost paid for this claim\n        uint256 claimUnlockTimestamp = block.timestamp + (_timeframe);\n        self.claimLockTimestamps[claimHash] = claimUnlockTimestamp;\n        self.claimAmountPaid[claimHash] = cost * (_count);\n        self.claimQuant[claimHash] = _count;\n        self.claimsMade[msg.sender] = self.claimsMade[msg.sender] + (1);\n\n        // tranasfer NFT input requirements from user to pool\n        takeInputReqsFrom(self, claimHash, msg.sender, _count);\n\n        // emit an event about it\n        emit NFTGemClaimCreated(\n            msg.sender,\n            address(self.pool),\n            claimHash,\n            _timeframe,\n            _count,\n            cost\n        );\n\n        // increase the staked eth balance\n        self.totalStakedEth = self.totalStakedEth + (cost * (_count));\n\n        // return the extra to sender\n        if (msg.value > cost * (_count)) {\n            (bool success, ) = payable(msg.sender).call{\n                value: msg.value - (cost * (_count))\n            }(\"\");\n            require(success, \"REFUND_FAILED\");\n        }\n    }\n\n    function getPoolFee(ComplexPoolData storage self, address tokenUsed)\n        internal\n        view\n        returns (uint256)\n    {\n        // get the fee for this pool if it exists\n        uint256 poolDivFeeHash = uint256(\n            keccak256(abi.encodePacked(\"pool_fee\", address(self.pool)))\n        );\n        uint256 poolFee = INFTGemFeeManager(self.feeTracker).fee(\n            poolDivFeeHash\n        );\n        // get the pool fee for this token if it exists\n        uint256 poolTokenFeeHash = uint256(\n            keccak256(abi.encodePacked(\"pool_fee\", address(tokenUsed)))\n        );\n        uint256 poolTokenFee = INFTGemFeeManager(self.feeTracker).fee(\n            poolTokenFeeHash\n        );\n        // get the default fee amoutn for this token\n        uint256 defaultFeeHash = uint256(\n            keccak256(abi.encodePacked(\"pool_fee\"))\n        );\n        uint256 defaultFee = INFTGemFeeManager(self.feeTracker).fee(\n            defaultFeeHash\n        );\n        defaultFee = defaultFee == 0 ? 2000 : defaultFee;\n\n        // get the fee, preferring the token fee if available\n        uint256 feeNum = poolFee != poolTokenFee\n            ? (poolTokenFee != 0 ? poolTokenFee : poolFee)\n            : poolFee;\n\n        // set the fee to default if it is 0\n        return feeNum == 0 ? defaultFee : feeNum;\n    }\n\n    function getMinimumLiquidity(\n        ComplexPoolData storage self,\n        address tokenUsed\n    ) internal view returns (uint256) {\n        // get the fee for this pool if it exists\n        uint256 poolDivFeeHash = uint256(\n            keccak256(abi.encodePacked(\"min_liquidity\", address(self.pool)))\n        );\n        uint256 poolFee = INFTGemFeeManager(self.feeTracker).fee(\n            poolDivFeeHash\n        );\n        // get the pool fee for this token if it exists\n        uint256 poolTokenFeeHash = uint256(\n            keccak256(abi.encodePacked(\"min_liquidity\", address(tokenUsed)))\n        );\n        uint256 poolTokenFee = INFTGemFeeManager(self.feeTracker).fee(\n            poolTokenFeeHash\n        );\n        // get the default fee amoutn for this token\n        uint256 defaultFeeHash = uint256(\n            keccak256(abi.encodePacked(\"min_liquidity\"))\n        );\n        uint256 defaultFee = INFTGemFeeManager(self.feeTracker).fee(\n            defaultFeeHash\n        );\n        defaultFee = defaultFee == 0 ? 50 : defaultFee;\n\n        // get the fee, preferring the token fee if available\n        uint256 feeNum = poolFee != poolTokenFee\n            ? (poolTokenFee != 0 ? poolTokenFee : poolFee)\n            : poolFee;\n\n        // set the fee to default if it is 0\n        return feeNum == 0 ? defaultFee : feeNum;\n    }\n\n    /**\n     * @dev crate multiple gem claim using an erc20 token. this token must be tradeable in Uniswap or this call will fail\n     */\n    function createERC20Claims(\n        ComplexPoolData storage self,\n        address erc20token,\n        uint256 tokenAmount,\n        uint256 count\n    ) public {\n        // enabled\n        require(self.enabled == true, \"DISABLED\");\n        // must be a valid address\n        require(erc20token != address(0), \"INVALID_ERC20_TOKEN\");\n\n        // token is allowed\n        require(\n            (self.allowedTokens.count() > 0 &&\n                self.allowedTokens.exists(erc20token)) ||\n                self.allowedTokens.count() == 0,\n            \"TOKEN_DISALLOWED\"\n        );\n\n        // zero qty\n        require(count != 0, \"ZERO_QUANTITY\");\n\n        // max quantity per claim\n        require(\n            (self.maxQuantityPerClaim != 0 &&\n                count <= self.maxQuantityPerClaim) ||\n                self.maxQuantityPerClaim == 0,\n            \"MAX_QUANTITY_EXCEEDED\"\n        );\n        require(\n            (self.maxClaimsPerAccount != 0 &&\n                self.claimsMade[msg.sender] < self.maxClaimsPerAccount) ||\n                self.maxClaimsPerAccount == 0,\n            \"MAX_QUANTITY_EXCEEDED\"\n        );\n\n        // require the user to have the input requirements\n        requireInputReqs(self, msg.sender, count);\n\n        // Uniswap pool must exist\n        require(\n            ISwapQueryHelper(self.swapHelper).hasPool(erc20token) == true,\n            \"NO_UNISWAP_POOL\"\n        );\n\n        // must have an amount specified\n        require(tokenAmount >= 0, \"NO_PAYMENT_INCLUDED\");\n\n        // get a quote in ETH for the given token.\n        (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        ) = ISwapQueryHelper(self.swapHelper).coinQuote(\n            erc20token,\n            tokenAmount / (count)\n        );\n\n        // TODO: update liquidity multiple from fee manager\n        if (self.validateerc20 == true) {\n            uint256 minLiquidity = getMinimumLiquidity(self, erc20token);\n            // make sure the convertible amount is has reserves > 100x the token\n            require(\n                ethReserve >= ethereum * minLiquidity * (count),\n                \"INSUFFICIENT_ETH_LIQUIDITY\"\n            );\n\n            // make sure the convertible amount is has reserves > 100x the token\n            require(\n                tokenReserve >= tokenAmount * minLiquidity * (count),\n                \"INSUFFICIENT_TOKEN_LIQUIDITY\"\n            );\n        }\n\n        // make sure the convertible amount is less than max price\n        require(ethereum <= self.ethPrice, \"OVERPAYMENT\");\n\n        // calculate the maturity time given the converted eth\n        uint256 maturityTime = (self.ethPrice * (self.minTime)) / (ethereum);\n\n        // make sure the convertible amount is less than max price\n        require(maturityTime >= self.minTime, \"INSUFFICIENT_TIME\");\n\n        // get the next claim hash, revert if no more claims\n        uint256 claimHash = nextClaimHash(self);\n        require(claimHash != 0, \"NO_MORE_CLAIMABLE\");\n\n        // mint the new claim to the caller's address\n        INFTGemMultiToken(self.multitoken).mint(msg.sender, claimHash, 1);\n        INFTGemMultiToken(self.multitoken).setTokenData(\n            claimHash,\n            INFTGemMultiToken.TokenType.CLAIM,\n            address(this)\n        );\n        addToken(self, claimHash, INFTGemMultiToken.TokenType.CLAIM);\n\n        // record the claim unlock time and cost paid for this claim\n        uint256 claimUnlockTimestamp = block.timestamp + (maturityTime);\n        self.claimLockTimestamps[claimHash] = claimUnlockTimestamp;\n        self.claimAmountPaid[claimHash] = ethereum;\n        self.claimLockToken[claimHash] = erc20token;\n        self.claimTokenAmountPaid[claimHash] = tokenAmount;\n        self.claimQuant[claimHash] = count;\n        self.claimsMade[msg.sender] = self.claimsMade[msg.sender] + (1);\n\n        // tranasfer NFT input requirements from user to pool\n        takeInputReqsFrom(self, claimHash, msg.sender, count);\n\n        // increase staked eth amount\n        self.totalStakedEth = self.totalStakedEth + (ethereum);\n\n        // emit a message indicating that an erc20 claim has been created\n        emit NFTGemERC20ClaimCreated(\n            msg.sender,\n            address(self.pool),\n            claimHash,\n            maturityTime,\n            erc20token,\n            count,\n            ethereum\n        );\n\n        // transfer the caller's ERC20 tokens into the pool\n        IERC20(erc20token).transferFrom(\n            msg.sender,\n            address(self.pool),\n            tokenAmount\n        );\n    }\n\n    /**\n     * @dev collect an open claim (take custody of the funds the claim is redeeemable for and maybe a gem too)\n     */\n    function collectClaim(\n        ComplexPoolData storage self,\n        uint256 _claimHash,\n        bool _requireMature\n    ) public {\n        // enabled\n        require(self.enabled == true, \"DISABLED\");\n        // check the maturity of the claim - only issue gem if mature\n        uint256 unlockTime = self.claimLockTimestamps[_claimHash];\n        bool isMature = unlockTime < block.timestamp;\n        require(\n            !_requireMature || (_requireMature && isMature),\n            \"IMMATURE_CLAIM\"\n        );\n        __collectClaim(self, _claimHash);\n    }\n\n    /**\n     * @dev collect an open claim (take custody of the funds the claim is redeeemable for and maybe a gem too)\n     */\n    function __collectClaim(ComplexPoolData storage self, uint256 claimHash)\n        internal\n    {\n        // validation checks - disallow if not owner (holds coin with claimHash)\n        // or if the unlockTime amd unlockPaid data is in an invalid state\n        require(\n            IERC1155(self.multitoken).balanceOf(msg.sender, claimHash) == 1,\n            \"NOT_CLAIM_OWNER\"\n        );\n        uint256 unlockTime = self.claimLockTimestamps[claimHash];\n        uint256 unlockPaid = self.claimAmountPaid[claimHash];\n        require(unlockTime != 0 && unlockPaid > 0, \"INVALID_CLAIM\");\n\n        // grab the erc20 token info if there is any\n        address tokenUsed = self.claimLockToken[claimHash];\n        uint256 unlockTokenPaid = self.claimTokenAmountPaid[claimHash];\n\n        // check the maturity of the claim - only issue gem if mature\n        bool isMature = unlockTime < block.timestamp;\n\n        //  burn claim and transfer money back to user\n        INFTGemMultiToken(self.multitoken).burn(msg.sender, claimHash, 1);\n\n        // if they used erc20 tokens stake their claim, return their tokens\n        if (tokenUsed != address(0)) {\n            // calculate fee portion using fee tracker\n            uint256 feePortion = 0;\n            if (isMature == true) {\n                feePortion = unlockTokenPaid / getPoolFee(self, tokenUsed);\n            }\n            // assess a fee for minting the NFT. Fee is collectec in fee tracker\n            IERC20(tokenUsed).transferFrom(\n                address(self.pool),\n                self.feeTracker,\n                feePortion\n            );\n            // send the principal minus fees to the caller\n            IERC20(tokenUsed).transferFrom(\n                address(self.pool),\n                msg.sender,\n                unlockTokenPaid - (feePortion)\n            );\n\n            // emit an event that the claim was redeemed for ERC20\n            emit NFTGemERC20ClaimRedeemed(\n                msg.sender,\n                address(self.pool),\n                claimHash,\n                tokenUsed,\n                unlockPaid,\n                unlockTokenPaid,\n                self.claimQuant[claimHash],\n                feePortion\n            );\n        } else {\n            // calculate fee portion using fee tracker\n            uint256 feePortion = 0;\n            if (isMature == true) {\n                feePortion = unlockPaid / getPoolFee(self, address(0));\n            }\n            // transfer the ETH fee to fee tracker\n            payable(self.feeTracker).transfer(feePortion);\n\n            // transfer the ETH back to user\n            payable(msg.sender).transfer(unlockPaid - (feePortion));\n\n            // emit an event that the claim was redeemed for ETH\n            emit NFTGemClaimRedeemed(\n                msg.sender,\n                address(self.pool),\n                claimHash,\n                unlockPaid,\n                self.claimQuant[claimHash],\n                feePortion\n            );\n        }\n\n        // tranasfer NFT input requirements from pool to user\n        returnInputReqsTo(\n            self,\n            claimHash,\n            msg.sender,\n            self.claimQuant[claimHash]\n        );\n\n        // deduct the total staked ETH balance of the pool\n        self.totalStakedEth = self.totalStakedEth - (unlockPaid);\n\n        // if all this is happening before the unlocktime then we exit\n        // without minting a gem because the user is withdrawing early\n        if (!isMature) {\n            return;\n        }\n\n        // get the next gem hash, increase the staking sifficulty\n        // for the pool, and mint a gem token back to account\n        uint256 nextHash = nextGemHash(self);\n\n        // associate gem and claim\n        self.gemClaims[nextHash] = claimHash;\n\n        // mint the gem\n        INFTGemMultiToken(self.multitoken).mint(\n            msg.sender,\n            nextHash,\n            self.claimQuant[claimHash]\n        );\n        addToken(self, nextHash, INFTGemMultiToken.TokenType.GEM);\n\n        // emit an event about a gem getting created\n        emit NFTGemCreated(\n            msg.sender,\n            address(self.pool),\n            claimHash,\n            nextHash,\n            self.claimQuant[claimHash]\n        );\n    }\n\n    /**\n     * @dev purchase gem(s) at the listed pool price\n     */\n    function purchaseGems(\n        ComplexPoolData storage self,\n        address sender,\n        uint256 value,\n        uint256 count\n    ) public {\n        // enabled\n        require(self.enabled == true, \"DISABLED\");\n        // non-zero balance\n        require(value != 0, \"ZERO_BALANCE\");\n        // non-zero quantity\n        require(count != 0, \"ZERO_QUANTITY\");\n        // sufficient input eth\n        uint256 adjustedBalance = value / (count);\n        require(adjustedBalance >= self.ethPrice, \"INSUFFICIENT_ETH\");\n        require(self.allowPurchase == true, \"PURCHASE_DISALLOWED\");\n\n        // get the next gem hash, increase the staking sifficulty\n        // for the pool, and mint a gem token back to account\n        uint256 nextHash = nextGemHash(self);\n\n        // mint the gem\n        INFTGemMultiToken(self.multitoken).mint(sender, nextHash, count);\n        addToken(self, nextHash, INFTGemMultiToken.TokenType.GEM);\n\n        // transfer the funds for the gem to the fee tracker\n        payable(self.feeTracker).transfer(value);\n\n        // emit an event about a gem getting created\n        emit NFTGemCreated(sender, address(self.pool), 0, nextHash, count);\n    }\n\n    /**\n     * @dev create a token of token hash / token type\n     */\n    function addToken(\n        ComplexPoolData storage self,\n        uint256 tokenHash,\n        INFTGemMultiToken.TokenType tokenType\n    ) public {\n        require(\n            tokenType == INFTGemMultiToken.TokenType.CLAIM ||\n                tokenType == INFTGemMultiToken.TokenType.GEM,\n            \"INVALID_TOKENTYPE\"\n        );\n        self.tokenHashes.push(tokenHash);\n        self.tokenTypes[tokenHash] = tokenType;\n        self.tokenIds[tokenHash] = tokenType ==\n            INFTGemMultiToken.TokenType.CLAIM\n            ? nextClaimId(self)\n            : nextGemId(self);\n        INFTGemMultiToken(self.multitoken).setTokenData(\n            tokenHash,\n            tokenType,\n            address(this)\n        );\n        if (tokenType == INFTGemMultiToken.TokenType.GEM) {\n            increaseDifficulty(self);\n        }\n    }\n\n    /**\n     * @dev get the next claim id\n     */\n    function nextClaimId(ComplexPoolData storage self)\n        public\n        returns (uint256)\n    {\n        uint256 ncId = self.nextClaimIdVal;\n        self.nextClaimIdVal = self.nextClaimIdVal + (1);\n        return ncId;\n    }\n\n    /**\n     * @dev get the next gem id\n     */\n    function nextGemId(ComplexPoolData storage self) public returns (uint256) {\n        uint256 ncId = self.nextGemIdVal;\n        self.nextGemIdVal = self.nextGemIdVal + (1);\n        return ncId;\n    }\n\n    /**\n     * @dev increase the pool's difficulty by calculating the step increase portion and adding it to the eth price of the market\n     */\n    function increaseDifficulty(ComplexPoolData storage self) public {\n        if (\n            self.priceIncrementType ==\n            INFTComplexGemPoolData.PriceIncrementType.COMPOUND\n        ) {\n            uint256 diffIncrease = self.ethPrice / (self.diffstep);\n            self.ethPrice = self.ethPrice + (diffIncrease);\n        } else if (\n            self.priceIncrementType ==\n            INFTComplexGemPoolData.PriceIncrementType.INVERSELOG\n        ) {\n            uint256 diffIncrease = self.diffstep / (self.ethPrice);\n            self.ethPrice = self.ethPrice + (diffIncrease);\n        }\n    }\n\n    /**\n     * @dev the hash of the next gem to be minted\n     */\n    function nextGemHash(ComplexPoolData storage self)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        \"gem\",\n                        address(self.pool),\n                        self.nextGemIdVal\n                    )\n                )\n            );\n    }\n\n    /**\n     * @dev the hash of the next claim to be minted\n     */\n    function nextClaimHash(ComplexPoolData storage self)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            (self.maxClaims != 0 && self.nextClaimIdVal <= self.maxClaims) ||\n                self.maxClaims == 0\n                ? uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            \"claim\",\n                            address(self.pool),\n                            self.nextClaimIdVal\n                        )\n                    )\n                )\n                : 0;\n    }\n\n    /**\n     * @dev get the token hash at index\n     */\n    function allTokenHashes(ComplexPoolData storage self, uint256 ndx)\n        public\n        view\n        returns (uint256)\n    {\n        return self.tokenHashes[ndx];\n    }\n\n    /**\n     * @dev return the claim amount paid for this claim\n     */\n    function claimAmount(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.claimAmountPaid[claimHash];\n    }\n\n    /**\n     * @dev the claim quantity (count of gems staked) for the given claim hash\n     */\n    function claimQuantity(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.claimQuant[claimHash];\n    }\n\n    /**\n     * @dev the lock time for this claim hash. once past lock time a gem is minted\n     */\n    function claimUnlockTime(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.claimLockTimestamps[claimHash];\n    }\n\n    /**\n     * @dev return the claim token amount for this claim hash\n     */\n    function claimTokenAmount(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.claimTokenAmountPaid[claimHash];\n    }\n\n    /**\n     * @dev return the claim hash of the given gemhash\n     */\n    function gemClaimHash(ComplexPoolData storage self, uint256 gemHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.gemClaims[gemHash];\n    }\n\n    /**\n     * @dev return the token that was staked to create the given token hash. 0 if the native token\n     */\n    function stakedToken(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (address)\n    {\n        return self.claimLockToken[claimHash];\n    }\n\n    /**\n     * @dev add a token that is allowed to be used to create a claim\n     */\n    function addAllowedToken(ComplexPoolData storage self, address token)\n        public\n    {\n        if (!self.allowedTokens.exists(token) && token != WFTM) {\n            self.allowedTokens.insert(token);\n        }\n    }\n\n    /**\n     * @dev  remove a token that is allowed to be used to create a claim\n     */\n    function removeAllowedToken(ComplexPoolData storage self, address token)\n        public\n    {\n        if (self.allowedTokens.exists(token)) {\n            self.allowedTokens.remove(token);\n        }\n    }\n\n    /**\n     * @dev deposit into pool\n     */\n    function deposit(\n        ComplexPoolData storage self,\n        address erc20token,\n        uint256 tokenAmount\n    ) public {\n        if (erc20token == address(0)) {\n            require(msg.sender.balance >= tokenAmount, \"INSUFFICIENT_BALANCE\");\n            self.totalStakedEth = self.totalStakedEth + (msg.sender.balance);\n        } else {\n            require(\n                IERC20(erc20token).balanceOf(msg.sender) >= tokenAmount,\n                \"INSUFFICIENT_BALANCE\"\n            );\n            IERC20(erc20token).transferFrom(\n                msg.sender,\n                address(self.pool),\n                tokenAmount\n            );\n        }\n    }\n\n    /**\n     * @dev deposit NFT into pool\n     */\n    function depositNFT(\n        ComplexPoolData storage self,\n        address erc1155token,\n        uint256 tokenId,\n        uint256 tokenAmount\n    ) public {\n        require(\n            IERC1155(erc1155token).balanceOf(msg.sender, tokenId) >=\n                tokenAmount,\n            \"INSUFFICIENT_BALANCE\"\n        );\n        IERC1155(erc1155token).safeTransferFrom(\n            msg.sender,\n            address(self.pool),\n            tokenId,\n            tokenAmount,\n            \"\"\n        );\n    }\n\n    /**\n     * @dev withdraw pool contents\n     */\n    function withdraw(\n        ComplexPoolData storage self,\n        address erc20token,\n        address destination,\n        uint256 tokenAmount\n    ) public {\n        require(destination != address(0), \"ZERO_ADDRESS\");\n        require(\n            self.controllers[msg.sender] == true || msg.sender == self.governor,\n            \"UNAUTHORIZED\"\n        );\n        if (erc20token == address(0)) {\n            payable(destination).transfer(tokenAmount);\n        } else {\n            IERC20(erc20token).transferFrom(\n                address(self.pool),\n                address(destination),\n                tokenAmount\n            );\n        }\n    }\n\n    /**\n     * @dev withdraw pool NFT\n     */\n    function withdrawNFT(\n        ComplexPoolData storage self,\n        address erc1155token,\n        address destination,\n        uint256 tokenId,\n        uint256 tokenAmount\n    ) public {\n        require(\n            self.controllers[msg.sender] == true || msg.sender == self.governor,\n            \"UNAUTHORIZED\"\n        );\n        require(erc1155token != address(0), \"ZERO_ADDRESS\");\n        require(destination != address(0), \"ZERO_ADDRESS\");\n        require(\n            IERC1155(erc1155token).balanceOf(address(self.pool), tokenId) >=\n                tokenAmount,\n            \"INSUFFICIENT_BALANCE\"\n        );\n        IERC1155(erc1155token).safeTransferFrom(\n            address(self.pool),\n            address(destination),\n            tokenId,\n            tokenAmount,\n            \"\"\n        );\n    }\n\n    /**\n     * @dev mint the genesis gems earned by the pools creator and funder\n     */\n    function mintGenesisGems(\n        ComplexPoolData storage self,\n        address creator,\n        address funder\n    ) public {\n        require(self.multitoken != address(0), \"NO_MULTITOKEN\");\n        require(\n            creator != address(0) && funder != address(0),\n            \"ZERO_DESTINATION\"\n        );\n        require(self.nextGemIdVal == 0, \"ALREADY_MINTED\");\n\n        uint256 gemHash = nextGemHash(self);\n        INFTGemMultiToken(self.multitoken).mint(creator, gemHash, 1);\n        addToken(self, gemHash, INFTGemMultiToken.TokenType.GEM);\n        // emit an event about a gem getting created\n        emit NFTGemCreated(creator, address(self.pool), 0, gemHash, 1);\n\n        gemHash = nextGemHash(self);\n        INFTGemMultiToken(self.multitoken).mint(funder, gemHash, 1);\n        addToken(self, gemHash, INFTGemMultiToken.TokenType.GEM);\n        // emit an event about a gem getting created\n        emit NFTGemCreated(funder, address(self.pool), 0, gemHash, 1);\n    }\n}\n"
    },
    "src/interfaces/INFTGemPoolData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./INFTGemMultiToken.sol\";\n\ninterface INFTGemPoolData {\n    // pool is inited with these parameters. Once inited, all\n    // but ethPrice are immutable. ethPrice only increases. ONLY UP\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function ethPrice() external view returns (uint256);\n\n    function minTime() external view returns (uint256);\n\n    function maxTime() external view returns (uint256);\n\n    function difficultyStep() external view returns (uint256);\n\n    function maxClaims() external view returns (uint256);\n\n    // these describe the pools created contents over time. This is where\n    // you query to get information about a token that a pool created\n    function claimedCount() external view returns (uint256);\n\n    function claimAmount(uint256 claimId) external view returns (uint256);\n\n    function claimQuantity(uint256 claimId) external view returns (uint256);\n\n    function mintedCount() external view returns (uint256);\n\n    function totalStakedEth() external view returns (uint256);\n\n    function tokenId(uint256 tokenHash) external view returns (uint256);\n\n    function tokenType(uint256 tokenHash)\n        external\n        view\n        returns (INFTGemMultiToken.TokenType);\n\n    function allTokenHashesLength() external view returns (uint256);\n\n    function allTokenHashes(uint256 ndx) external view returns (uint256);\n\n    function nextClaimHash() external view returns (uint256);\n\n    function nextGemHash() external view returns (uint256);\n\n    function nextGemId() external view returns (uint256);\n\n    function nextClaimId() external view returns (uint256);\n\n    function claimUnlockTime(uint256 claimId) external view returns (uint256);\n\n    function claimTokenAmount(uint256 claimId) external view returns (uint256);\n\n    function stakedToken(uint256 claimId) external view returns (address);\n\n    function allowedTokensLength() external view returns (uint256);\n\n    function allowedTokens(uint256 idx) external view returns (address);\n\n    function isTokenAllowed(address token) external view returns (bool);\n\n    function addAllowedToken(address token) external;\n\n    function removeAllowedToken(address token) external;\n}\n"
    },
    "src/governance/NFTGemGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTComplexGemPool.sol\";\nimport \"../interfaces/INFTGemPoolFactory.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\n/**\n * @dev The governor contract for the system. Can create system pools (public pools shown on bitgems sites)\n *      and user-owned pools (private pools not shown on the bitgem sites). All  privileged calls are made\n *      through this contract.\n */\ncontract NFTGemGovernor is Controllable, Initializable, INFTGemGovernor {\n    // the multitoken contract\n    address private multitoken;\n    // the gem pool factory contract\n    address private factory;\n    // the fee manager contract\n    address private feeTracker;\n    // the swap manager contract\n    address private swapHelper;\n\n    /**\n     * @dev contract constructor\n     */\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /**\n     * @dev init this smart contract. Can only be called once. Sets the related contracts.\n     */\n    function initialize(\n        address _multitoken,\n        address _factory,\n        address _feeTracker,\n        address _swapHelper\n    ) public initializer {\n        multitoken = _multitoken;\n        factory = _factory;\n        feeTracker = _feeTracker;\n        swapHelper = _swapHelper;\n    }\n\n    function initialized() external view override returns (bool) {\n        return\n            multitoken != address(0x0) &&\n            factory != address(0x0) &&\n            feeTracker != address(0x0) &&\n            swapHelper != address(0x0);\n    }\n\n    /**\n     * @dev associate the newly-created pool with its relations and give it the privileges\n     * @param creator the owner of the pool\n     * @param funder the funder of the pool\n     * @param pool the pool\n     */\n    function associatePool(\n        address creator,\n        address funder,\n        address pool\n    ) internal {\n        IControllable(multitoken).addController(pool);\n        IControllable(this).addController(pool);\n\n        //INFTGemMultiToken(multitoken).addProxyRegistry(pool);\n\n        INFTComplexGemPool(pool).setMultiToken(multitoken);\n        INFTComplexGemPool(pool).setSwapHelper(swapHelper);\n        INFTComplexGemPool(pool).setGovernor(address(this));\n        INFTComplexGemPool(pool).setFeeTracker(feeTracker);\n        INFTComplexGemPool(pool).mintGenesisGems(creator, funder);\n    }\n\n    /**\n     * @dev internal gem pool creator method\n     */\n    function _createPool(\n        address owner,\n        address funder,\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) internal returns (address pool) {\n        // use the gem pool factory to create a new pool\n        pool = INFTGemPoolFactory(factory).createNFTGemPool(\n            owner,\n            symbol,\n            name,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n            allowedToken\n        );\n        // associate the pool with its relations\n        associatePool(owner, funder, pool);\n    }\n\n    /**\n     * @dev create a new system pool - called by sysadmins to add public pools\n     */\n    function createSystemPool(\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external override onlyController returns (address pool) {\n        pool = _createPool(\n            msg.sender,\n            msg.sender,\n            symbol,\n            name,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n            allowedToken\n        );\n        // TODO mark the pool as a system pool\n    }\n\n    /**\n     * @dev create a new pool - public\n     */\n    function createPool(\n        address owner,\n        address funder,\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external override returns (address pool) {\n        //TODO: we may not need this here at all if a private pool is privately managed anyways\n        pool = _createPool(\n            owner,\n            funder,\n            symbol,\n            name,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n            allowedToken\n        );\n    }\n}\n"
    },
    "src/interfaces/INFTGemPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface INFTGemPoolFactory {\n    /**\n     * @dev emitted when a new gem pool has been added to the system\n     */\n    event NFTGemPoolCreated(\n        address indexed gemPoolAddress,\n        string gemSymbol,\n        string gemName,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    );\n\n    /**\n     * @dev emitted when a new gem pool has been added to the system\n     */\n    event CustomNFTGemPoolCreated(\n        address indexed gemPoolAdress,\n        string gemSymbol,\n        string gemName\n    );\n\n    function nftGemPools() external view returns (address[] memory);\n\n    function getNFTGemPool(uint256 _symbolHash) external view returns (address);\n\n    function allNFTGemPools(uint256 idx) external view returns (address);\n\n    function allNFTGemPoolsLength() external view returns (uint256);\n\n    function createNFTGemPool(\n        address owner,\n        string memory gemSymbol,\n        string memory gemName,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    ) external returns (address payable);\n}\n"
    },
    "src/factories/NFTGemPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"../interfaces/IControllable.sol\";\nimport \"../pool/NFTComplexGemPool.sol\";\nimport \"../pool/ComplexPoolLib.sol\";\n\nimport \"../interfaces/INFTGemPoolFactory.sol\";\n\ncontract NFTGemPoolFactory is INFTGemPoolFactory {\n    mapping(uint256 => address) private _getNFTGemPool;\n    address[] private _allNFTGemPools;\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function getNFTGemPool(uint256 _symbolHash)\n        external\n        view\n        override\n        returns (address gemPool)\n    {\n        gemPool = _getNFTGemPool[_symbolHash];\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function nftGemPools() external view override returns (address[] memory) {\n        return _allNFTGemPools;\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function allNFTGemPools(uint256 idx)\n        external\n        view\n        override\n        returns (address gemPool)\n    {\n        gemPool = _allNFTGemPools[idx];\n    }\n\n    /**\n     * @dev number of quantized addresses\n     */\n    function allNFTGemPoolsLength() external view override returns (uint256) {\n        return _allNFTGemPools.length;\n    }\n\n    /**\n     * @dev deploy a new erc20 token using create2\n     */\n    function createNFTGemPool(\n        address owner,\n        string memory gemSymbol,\n        string memory gemName,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    ) external override returns (address payable gemPool) {\n        // create the lookup hash for the given symbol\n        // and check if it already exists\n        bytes32 salt = keccak256(abi.encodePacked(gemSymbol));\n        require(_getNFTGemPool[uint256(salt)] == address(0), \"GEMPOOL_EXISTS\"); // single check is sufficient\n\n        // validation checks to make sure values are sane\n        require(ethPrice != 0, \"INVALID_PRICE\");\n        require(minTime != 0, \"INVALID_MIN_TIME\");\n        require(diffstep != 0, \"INVALID_DIFFICULTY_STEP\");\n\n        // create the gem pool using create2, which lets us determine the\n        // address of a gem pool without interacting with the contract itself\n        bytes memory bytecode = type(NFTComplexGemPool).creationCode;\n\n        // use create2 to deploy the gem pool contract\n        gemPool = payable(Create2.deploy(0, salt, bytecode));\n\n        // set the controller of the gem pool\n        IControllable(gemPool).addController(owner);\n\n        // initialize the erc20 contract with the relevant addresses which it proxies\n        NFTComplexGemPool(gemPool).initialize(\n            gemSymbol,\n            gemName,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxMint,\n            allowedToken\n        );\n\n        // insert the erc20 contract address into lists\n        _getNFTGemPool[uint256(salt)] = gemPool;\n        _allNFTGemPools.push(gemPool);\n\n        // emit an event about the new pool being created\n        emit NFTGemPoolCreated(\n            gemPool,\n            gemSymbol,\n            gemName,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxMint,\n            allowedToken\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "src/lootbox/LootboxLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../interfaces/ILootbox.sol\";\nimport \"../interfaces/IRandomFarm.sol\";\nimport \"../interfaces/ILootboxData.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../access/Controllable.sol\";\nimport \"./TokenSeller.sol\";\n\nlibrary LootboxLib {\n\n    event LootboxCreated(\n        address indexed creator,\n        uint256 indexed hash,\n        address indexed contractAddress,\n        ILootbox.Lootbox data\n    );\n\n    event LootboxMigrated(\n        address indexed migrator,\n        uint256 indexed hash,\n        address indexed oldContractAddress,\n        address newContractAddress,\n        ILootbox.Lootbox data\n    );\n\n    event LootboxOpened(\n        address indexed opener,\n        uint256 indexed hash,\n        ILootbox.Lootbox openedLootbox,\n        ILootbox.Loot[] receivedLoot\n    );\n\n    event LootAdded(\n        address indexed adder,\n        uint256 indexed hash,\n        ILootbox.Lootbox addedLootbox,\n        ILootbox.Loot addedLoot\n    );\n\n    event LootboxTokensMinted(\n        address indexed minter,\n        uint256 indexed hash,\n        ILootbox.Lootbox mintedLootbox,\n        uint256 mintedAmount\n    );\n\n    event LootMinted(\n        address indexed minter,\n        uint256 indexed hash,\n        ILootbox.Lootbox mintedLootbox,\n        ILootbox.Loot mintedLoot\n    );\n\n    /// @dev Sets the lootbox data. The lootbox contract can either initialise a new\n    // lootbox struct or it can load and update an existing lootbox struct.\n    function initialize(\n        ILootbox.Lootbox memory lootboxInit\n    )\n    external pure returns (ILootbox.Lootbox memory lootboxOut_) {\n        if (lootboxInit.lootboxHash == 0) {\n            require(\n                lootboxInit.multitoken != address(0),\n                \"Multitoken address must be set\"\n            );\n            require(bytes(lootboxInit.name).length != 0, \"Name must be set\");\n            require(\n                bytes(lootboxInit.symbol).length != 0,\n                \"Symbol must be set\"\n            );\n            require(lootboxInit.minLootPerOpen != 0, \"Min loot must be set\");\n            require(lootboxInit.maxLootPerOpen != 0, \"Max loot must be set\");\n            // TODO: additional validity checks would not hurt here\n            lootboxOut_ = lootboxInit;\n            lootboxOut_.lootboxHash = uint256(\n                keccak256(\n                    abi.encodePacked(\n                        lootboxInit.symbol\n                    )\n                )\n            );\n            lootboxOut_.initialized = true;\n        }\n    }\n\n    function openLootbox(\n        ILootbox.Lootbox memory _lootbox,\n        ILootbox.Loot[] memory _loot\n    )\n        external\n        returns (ILootbox.Loot[] memory _lootOut)\n    {\n        // make sure that the caller has at least one lootbox token\n        require(\n            IERC1155(_lootbox.multitoken).balanceOf(\n                msg.sender,\n                _lootbox.lootboxHash\n            ) > 0,\n            \"Insufficient lootbox token balance\"\n        );\n\n        // no need to transfer the lootbox token anywhere, we can just burn it in place\n        INFTGemMultiToken(_lootbox.multitoken).burn(\n            msg.sender,\n            _lootbox.lootboxHash,\n            1\n        );\n\n        // first we need to determine the number of loot items to mint\n        // if min == max, then we mint that exact number of items. Otherwise,\n        // we use a random number between min and max to determine the number\n        // of loot items to mint\n        uint8 lootCount = _lootbox.minLootPerOpen;\n        if (_lootbox.minLootPerOpen != _lootbox.maxLootPerOpen) {\n            lootCount = uint8(\n                IRandomFarmer(_lootbox.randomFarmer).getRandomNumber(\n                    uint256(_lootbox.minLootPerOpen),\n                    uint256(_lootbox.maxLootPerOpen)\n                )\n            );\n        } else lootCount = _lootbox.minLootPerOpen;\n\n        // now that we know how much we need to mint, we can create the\n        // loot roll array that will hold our results and create some loot\n        _lootOut = new ILootbox.Loot[](lootCount);\n\n        // now we need some randomness to determine which loot items we win\n        // we use a pseudo-random deterministic sieve to determine the number\n        // and type of tokens minted\n        uint256[] memory _lootRoll = IRandomFarmer(_lootbox.randomFarmer)\n        .getRandomUints(lootCount);\n\n        // mint the loot items\n        for (uint256 i = 0; i < lootCount; i++) {\n\n            // generate a loot item given a random seed\n            (uint8 winIndex, uint256 winRoll) = _generateLoot(\n                _loot,\n                _lootRoll[i],\n                _lootbox.probabilitiesSum\n            );\n\n            // assign the loot item to the loot array\n            _lootOut[i] = _loot[winIndex];\n            _lootOut[i].probabilityRoll = winRoll;\n\n            // mint the loot item to the multitoken\n            INFTGemMultiToken(_lootbox.multitoken).mint(\n                msg.sender,\n                _lootOut[i].lootHash,\n                1\n            );\n        }\n\n        /// generate an event reporting on the loot that was found\n        emit LootboxOpened(\n            msg.sender,\n            _lootbox.lootboxHash,\n            _lootbox,\n            _lootOut\n        );\n    }\n\n    function mintLoot(ILootbox.Lootbox memory _lootbox, ILootbox.Loot[] memory _allLoot, uint8 index, uint256 amount)\n        external\n        returns (ILootbox.Loot memory)\n    {\n        require(index < _allLoot.length, \"Loot index out of bounds\");\n        // mint the loot item to the minter\n        INFTGemMultiToken(_lootbox.multitoken).mint(\n            msg.sender,\n            _allLoot[index].lootHash,\n            amount\n        );\n        // forced to use GOVERNANCE here as a token type because\n        // someone decided to 'clean up' what they didn't understand.\n        // there was a very good reason for this, that being that an\n        // int type rather than an enum allows us to easily add new\n        // token types. Noe I have to figure out how to handle this\n        // in some other way. Thanks, Justin\n        INFTGemMultiToken(_lootbox.multitoken).setTokenData(\n            _allLoot[index].lootHash,\n            INFTGemMultiToken.TokenType.GOVERNANCE,\n            address(this)\n        );\n\n        // emit a message about it\n        emit LootMinted(\n            msg.sender,\n            _lootbox.lootboxHash,\n            _lootbox,\n            _allLoot[index]\n        );\n        // return the loot item we minted\n        return _allLoot[index];\n    }\n\n    function _generateLoot(\n        ILootbox.Loot[] memory _loot,\n        uint256 dice,\n        uint256 _probabilitiesSum\n    )\n        internal\n        pure\n        returns (uint8 winnerIndex, uint256 winnerRoll)\n    {\n        // validate the dice roll is in the proper range\n        require(\n            dice < _probabilitiesSum,\n            \"Dice roll must be less than total probability\"\n        );\n        uint256 floor = 0;\n        // get all the loot there is to award\n\n        // iterate through the loot items\n        for (uint256 i = 0; i < _loot.length; i++) {\n            // if the dice roll is between the floor and the probability index\n            // then this is the item we will award\n            if (floor <= dice && dice < _loot[i].probabilityIndex) {\n                winnerIndex = uint8(i);\n                winnerRoll = dice;\n                break;\n            }\n            // increment the floor to the next probability index\n            floor = _loot[i].probabilityIndex;\n        }\n        return (winnerIndex, winnerRoll);\n    }\n\n\n}\n"
    },
    "src/interfaces/ILootbox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./ITokenSeller.sol\";\n\n/// @dev A lootbox is a contract that works with an erc1155 to implement a game lootbox:\n/// a lootbox is a contract that accepts a single quantity of some erc1155 tokenhash and\n/// then based on a set of rules goverened by probability, mints one or more outgoing tokens\n/// as it burns the incoming token. The rules are defined by the lootbox author and are\n/// stored in the lootbox contract. A newly-created lootbox contract assigns controllership\n/// to its creator, who can them add other controllers, and can set the rules for the lootbox.\n/// Each lootbox is configured with some number of Loot items, each of which has deterministic\n/// tokenhash. These loot items each have names, symboles, and a probability of being minted.\n/// Users open the lootbox by providing the right gem to the lootbox contract, and then\n/// the lootbox contract mints the right number of tokens for the user. This contract uses\n/// a pseudo-random deterministic sieve to determine the number and type of tokens minted\n\ninterface ILootbox {\n    // the lootbox itself\n    struct Lootbox {\n        address owner;\n        address contractAddress;\n        address randomFarmer;\n        address multitoken;\n        uint256 lootboxHash; // identifier and lootbox token hash for the lootbox\n        string symbol;\n        string name;\n        string description;\n        uint8 minLootPerOpen;\n        uint8 maxLootPerOpen;\n        uint256 maxOpens;\n        uint256 openCount;\n        uint256 totalLootGenerated;\n        uint256 probabilitiesSum;\n        bool initialized;\n    }\n\n    // loot items\n    struct Loot {\n        uint256 lootHash;\n        address owner;\n        address multitoken;\n        string symbol;\n        string name;\n        uint256 probability;\n        uint256 probabilityIndex;\n        uint256 probabilityRoll;\n        uint256 maxMint;\n        uint256 minted;\n    }\n\n    event LootboxCreated(\n        address indexed creator,\n        uint256 indexed hash,\n        address indexed contractAddress,\n        Lootbox data\n    );\n\n    event LootboxMigrated(\n        address indexed migrator,\n        uint256 indexed hash,\n        address indexed oldContractAddress,\n        address newContractAddress,\n        Lootbox data\n    );\n\n    event LootboxOpened(\n        address indexed opener,\n        uint256 indexed hash,\n        Lootbox openedLootbox,\n        Loot[] receivedLoot\n    );\n\n    event LootAdded(\n        address indexed adder,\n        uint256 indexed hash,\n        Lootbox addedLootbox,\n        Loot addedLoot\n    );\n\n    event LootboxTokensMinted(\n        address indexed minter,\n        uint256 indexed hash,\n        Lootbox mintedLootbox,\n        uint256 mintedAmount\n    );\n\n    event LootMinted(\n        address indexed minter,\n        uint256 indexed hash,\n        Lootbox mintedLootbox,\n        Loot mintedLoot\n    );\n\n    function initialize(\n        address lootboxData,\n        ITokenSeller.TokenSellerInfo memory tokenSellerInfo,\n        ILootbox.Lootbox memory lootboxInit\n    ) external;\n\n    function mintLootboxTokens(uint256 amount) external;\n\n    function mintLoot(uint8 index, uint256 amount)\n        external\n        returns (Loot memory);\n\n    function openLootbox() external returns (Loot[] memory);\n\n    function allLoot() external view returns (Loot[] memory);\n\n    function addLoot(Loot memory _loot) external returns (uint256);\n\n    function getLoot(uint256 index) external view returns (Loot memory);\n}\n"
    },
    "src/interfaces/IRandomFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IRandomFarmer {\n    function getRandomBytes(uint8 amount) external returns (bytes32[] memory);\n\n    function getRandomUints(uint8 amount) external returns (uint256[] memory);\n\n    function getRandomNumber(uint256 min, uint256 max)\n        external\n        returns (uint256);\n}\n\ninterface IRandomFarm is IRandomFarmer {\n    function initialize(uint256 seed) external;\n\n    function addRandomness(uint256 randomness) external;\n}\n"
    },
    "src/interfaces/ILootboxData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./ILootbox.sol\";\nimport \"./ITokenSeller.sol\";\n\ninterface ILootboxData {\n    function getFeeManager() external view returns (address);\n\n    function setFeeManager(address feeManagerAddress) external;\n\n    function addLootbox(ILootbox.Lootbox memory)\n        external\n        returns (uint256 lootbox);\n\n    function getLootboxByAddress(address lootbox)\n        external\n        view\n        returns (ILootbox.Lootbox memory);\n\n    function getLootboxByHash(uint256 lootbox)\n        external\n        view\n        returns (ILootbox.Lootbox memory);\n\n    function setLootbox(\n        ILootbox.Lootbox memory lootboxData\n    ) external;\n\n    function lootboxes() external view returns (ILootbox.Lootbox[] memory);\n\n    function allLootboxes(uint256 index)\n        external\n        view\n        returns (ILootbox.Lootbox memory);\n\n    function allLootboxesLength() external view returns (uint256);\n\n    function getLoot(uint256 lootbox, uint256 index)\n        external\n        view\n        returns (ILootbox.Loot memory);\n\n    function addLoot(uint256 lootbox, ILootbox.Loot memory lootboxData)\n        external\n        returns (uint256);\n\n    function setLoot(\n        uint256 lootbox,\n        uint256 index,\n        ILootbox.Loot memory lootboxData\n    ) external;\n\n    function allLoot(uint256 lootbox)\n        external\n        view\n        returns (ILootbox.Loot[] memory);\n\n    function delLoot(uint256 lootbox, uint256 index)\n        external\n        returns (ILootbox.Loot memory);\n\n    function addTokenSeller(\n        address tokenSeller,\n        ITokenSeller.TokenSellerInfo memory\n    ) external returns (uint256 tokenSellerIndex);\n\n    function getTokenSeller(address tokenSeller)\n        external\n        view\n        returns (ITokenSeller.TokenSellerInfo memory);\n\n    function setTokenSeller(\n        address tokenSellerAddress,\n        ITokenSeller.TokenSellerInfo memory tokenSellerData\n    ) external;\n\n    function tokenSellers()\n        external\n        view\n        returns (ITokenSeller.TokenSellerInfo[] memory);\n\n    function allTokenSellers(uint256 index)\n        external\n        view\n        returns (ITokenSeller.TokenSellerInfo memory);\n\n    function allTokenSellersLength() external view returns (uint256);\n\n    function increaseBuyPrice(address tokenSeller) external view  returns (uint256);\n}\n"
    },
    "src/lootbox/TokenSeller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../interfaces/ITokenSeller.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\nimport \"../interfaces/ILootboxData.sol\";\nimport \"../access/Controllable.sol\";\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\ncontract TokenSeller is ITokenSeller, Controllable, Initializable {\n    ILootboxData internal _tokenSellerData;\n    ITokenSeller.TokenSellerInfo internal _tokenSeller;\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /// @dev contract must be initilized for modified method to be called\n    modifier initialized() virtual {\n        require(\n            _tokenSeller.multitoken != address(0) &&\n                _tokenSeller.initialized == true,\n            \"Token seller is not initialized\"\n        );\n        _;\n    }\n\n    /// @dev Sets the lootbox data. The lootbox contract can either initialise a new\n    // lootbox struct or it can load and update an existing lootbox struct.\n    function initialize(\n        address tokenSellerData,\n        ITokenSeller.TokenSellerInfo memory tokenSellerInit\n    ) external override initializer {\n        require(\n            IControllable(tokenSellerData).isController(address(this)) == true,\n            \"Token seller data must be controlled by this token seller\"\n        );\n        _tokenSellerData = ILootboxData(tokenSellerData);\n        if (tokenSellerInit.contractAddress == address(0)) {\n            require(\n                tokenSellerInit.multitoken != address(0),\n                \"Multitoken address must be set\"\n            );\n            require(tokenSellerInit.tokenHash != 0, \"token hash must be set\");\n            require(tokenSellerInit.buyPrice != 0, \"Price must be set\");\n            _tokenSeller = tokenSellerInit;\n            _tokenSeller.contractAddress = address(this);\n            _tokenSeller.initialized = true;\n            _tokenSellerData.addTokenSeller(address(this), _tokenSeller);\n            emit TokenSellerCreated(msg.sender, _tokenSeller);\n        } else {\n            // load the lootbox struct\n            _tokenSeller = _tokenSellerData.getTokenSeller(address(this));\n            _tokenSeller.contractAddress = address(this);\n            _tokenSellerData.setTokenSeller(address(this), _tokenSeller);\n            require(\n                _tokenSeller.owner == msg.sender,\n                \"Lootbox must be owned by the caller to uppgrade contract\"\n            );\n            emit TokenSellerMigrated(\n                msg.sender,\n                address(this),\n                _tokenSeller.contractAddress,\n                address(this),\n                _tokenSeller\n            );\n        }\n    }\n\n    function isInitialized() external view override returns (bool) {\n        return _tokenSeller.initialized;\n    }\n\n    function getInfo() external view override returns (TokenSellerInfo memory) {\n        return _tokenSeller;\n    }\n\n    function setInfo(TokenSellerInfo memory _info)\n        external\n        override\n        onlyController\n    {\n        _tokenSeller.buyPrice = _info.buyPrice;\n        _tokenSeller.buyPriceIncreaseRateType = _info.buyPriceIncreaseRateType;\n        _tokenSeller.buyPriceIncreaseRate = _info.buyPriceIncreaseRate;\n        _tokenSeller.maxQuantity = _info.maxQuantity;\n        _tokenSeller.maxBuyAmount = _info.maxBuyAmount;\n        _tokenSeller.maxTotalBuyAmount = _info.maxTotalBuyAmount;\n        _tokenSeller.saleStartTime = _info.saleStartTime;\n        _tokenSeller.saleEndTime = _info.saleEndTime;\n        _tokenSeller.open = _info.open;\n        _tokenSeller.maxTotalBuyAmount = _info.maxTotalBuyAmount;\n        _tokenSellerData.setTokenSeller(address(this), _tokenSeller);\n    }\n\n    function _request(\n        address _recipient,\n        uint256 _token,\n        uint256 _amount\n    ) internal returns (uint256) {\n        // mint the target token directly into the user's account\n        INFTGemMultiToken(_tokenSeller.multitoken).mint(\n            _recipient,\n            _token,\n            _amount\n        );\n        // set the token data - it's not a claim or gem and it was minted here\n        INFTGemMultiToken(_tokenSeller.multitoken).setTokenData(\n            _token,\n            INFTGemMultiToken.TokenType.GOVERNANCE,\n            address(this)\n        );\n        return _amount;\n    }\n\n    /// @dev Buy tokens from the token seller.\n    /// @param _amount The amount of erc1155 tokens to buy.\n    /// @return The amount of erc1155 tokens that were bought.\n    function buy(uint256 _amount) external payable override returns (uint256) {\n        require(_tokenSeller.open == true, \"The token seller is closed\");\n        require(\n            _tokenSeller.totalPurchased < _tokenSeller.maxQuantity,\n            \"The maximum amount of tokens has been bought.\"\n        );\n        require(\n            msg.value >= _tokenSeller.buyPrice * _amount,\n            \"Insufficient base currency\"\n        );\n        require(\n            _amount <= _tokenSeller.maxBuyAmount,\n            \"Amount exceeds maximum buy amount\"\n        );\n        require(\n            _amount <=\n                _tokenSeller.maxTotalBuyAmount -\n                    IERC1155(_tokenSeller.multitoken).balanceOf(\n                        msg.sender,\n                        _tokenSeller.tokenHash\n                    ),\n            \"Amount exceeds maximum buy total\"\n        );\n        require(\n            block.timestamp >= _tokenSeller.saleStartTime ||\n                _tokenSeller.saleStartTime == 0,\n            \"The sale has not started yet\"\n        );\n        require(\n            block.timestamp <= _tokenSeller.saleEndTime ||\n                _tokenSeller.saleEndTime == 0,\n            \"The sale has ended\"\n        );\n        // request (mint) the tokens\n        _request(msg.sender, _tokenSeller.tokenHash, _amount);\n        // increase total bought\n        _tokenSeller.totalPurchased += _amount;\n        // emit a message about the purchase\n        emit Sold(\n            address(this),\n            msg.sender,\n            _tokenSeller.tokenHash,\n            _tokenSeller.buyPrice,\n            _amount\n        );\n        // increase the purchase price if it's not fixed\n        _tokenSeller.buyPrice = _tokenSellerData.increaseBuyPrice(address(this));\n        _tokenSellerData.setTokenSeller(address(this), _tokenSeller);\n        // return the amount of tokens that were bought\n        return _amount;\n    }\n\n    /// @dev Request tokens from the token provider.\n    /// @param _recipient The address of the token receiver.\n    /// @param _amount The amount of erc1155 tokens to buy.\n    /// @return The amount of erc1155 tokens that were requested.\n    function request(address _recipient, uint256 _amount)\n        external\n        override\n        onlyController\n        returns (uint256)\n    {\n        require(\n            _tokenSeller.totalPurchased < _tokenSeller.maxQuantity,\n            \"The maximum amount of tokens has been bought.\"\n        );\n        return _request(_recipient, _tokenSeller.tokenHash, _amount);\n    }\n\n    function migrate_TokenSeller(address migrateTo, bool bDestroy) external initialized onlyController {\n        IControllable(address(_tokenSellerData)).addController(migrateTo);\n        ITokenSeller(migrateTo).initialize(\n            address(_tokenSellerData),\n            _tokenSeller\n        );\n         if(bDestroy == true) {\n             selfdestruct(payable(migrateTo));\n         }\n    }\n\n    function receivePayout(address payable _recipient) external override {\n        require(\n            this.isController(msg.sender) || msg.sender == _tokenSeller.owner,\n            \"Only the token seller can receive payouts\"\n        );\n        uint256 balance = payable(address(this)).balance;\n        if (balance == 0) {\n            return;\n        }\n        address feeManager = _tokenSellerData.getFeeManager();\n        require(\n            feeManager != address(this),\n            \"The token seller has no fee manager\"\n        );\n        uint256 fee = INFTGemFeeManager(feeManager).fee(\n            uint256(keccak256(abi.encodePacked(\"lootbox\")))\n        );\n        _recipient = _recipient != address(0)\n            ? _recipient\n            : payable(msg.sender);\n        fee = fee != 0 ? fee : 333;\n        uint256 feeAmount = balance / fee;\n        uint256 userPortion = balance - feeAmount;\n        require(payable(_recipient).send(userPortion), \"Failed to send\");\n        require(\n            payable(feeManager).send(feeAmount),\n            \"Failed to send to fee manager\"\n        );\n        emit FundsCollected(_recipient, userPortion);\n    }\n}\n"
    },
    "src/interfaces/ITokenSeller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @dev A token seller is a contract that can sell tokens to a token buyer.\n/// The token buyer can buy tokens from the seller by paying a certain amount\n/// of base currency to receive a certain amount of erc1155 tokens. the number\n/// of tokens that can be bought is limited by the seller - the seller can\n/// specify the maximum number of tokens that can be bought per transaction\n/// and the maximum number of tokens that can be bought in total for a given\n/// address. The seller can also specify the price of erc1155 tokens and how\n/// that price increases per successful transaction. the token seller assumes\n/// supply of the erc1155 is unlimited and features a request method\n\ninterface ITokenSeller {\n    enum BuyPriceIncreaseRateType {\n        NONE,\n        FIXED,\n        EXPONENTIAL,\n        INVERSELOG\n    }\n\n    struct TokenSellerInfo {\n        address multitoken;\n        address contractAddress;\n        address owner;\n        uint256 tokenHash;\n        uint256 buyPrice;\n        BuyPriceIncreaseRateType buyPriceIncreaseRateType;\n        uint256 buyPriceIncreaseRate;\n        uint256 maxQuantity;\n        uint256 maxBuyAmount;\n        uint256 maxTotalBuyAmount;\n        uint256 saleStartTime;\n        uint256 saleEndTime;\n        bool initialized;\n        bool open;\n        uint256 totalPurchased;\n    }\n\n    event TokenSellerCreated(address indexed creator, TokenSellerInfo info);\n\n    event Sold(\n        address indexed contractAddress,\n        address indexed buyer,\n        uint256 indexed tokenHash,\n        uint256 price,\n        uint256 amount\n    );\n\n    event Requested(\n        address indexed contractAddress,\n        address indexed seller,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n\n    event Funded(\n        address indexed contractAddress,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n\n    event FundsCollected(address indexed receiver, uint256 indexed amount);\n\n    event TokenSellerMigrated(\n        address indexed migrator,\n        address indexed hash,\n        address indexed oldContractAddress,\n        address newContractAddress,\n        TokenSellerInfo data\n    );\n\n    function initialize(address tokenSellerData, TokenSellerInfo memory _info)\n        external;\n\n    function isInitialized() external view returns (bool);\n\n    function getInfo() external view returns (TokenSellerInfo memory);\n\n    function setInfo(TokenSellerInfo memory _info) external;\n\n    /// @dev Buy tokens from the token seller.\n    /// @param _amount The amount of erc1155 tokens to buy.\n    /// @return The amount of erc1155 tokens that were bought.\n    function buy(uint256 _amount) external payable returns (uint256);\n\n    /// @dev Request tokens from the token provider.\n    /// @param _recipient The address of the token receiver.\n    /// @param _amount The amount of erc1155 tokens to buy.\n    /// @return The amount of erc1155 tokens that were requested.\n    function request(address _recipient, uint256 _amount)\n        external\n        returns (uint256);\n\n    function receivePayout(address payable _recipient) external;\n}\n"
    },
    "src/interfaces/IBitgemIndexer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../access/Controllable.sol\";\nimport \"./ITokenSeller.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\n\n/// @dev The gem indexer indexes all historical gems from legacy contracts and\n/// produces a series of events that get indexed by thegraph indexer. this is\n/// necessary because the legacy contracts generate events from library code,\n/// making things not work in thegraph.\n\ninterface IGemPoolData {\n    function allTokenHashesLength() external view returns (uint256);\n\n    function allTokenHashes(uint256 ndx) external view returns (uint256);\n\n    function tokenType(uint256 tokenHash)\n        external\n        view\n        returns (INFTGemMultiToken.TokenType);\n}\n\ninterface IBitgemIndexer {\n    struct Gem {\n        uint256 id;\n        uint256 gemHash;\n        address minter;\n        address gemPoolFactory;\n        address multitoken;\n        address pool;\n        uint256 quantity;\n    }\n\n    event GemCreated(\n        uint256 indexed gemCreateUID,\n        uint256 gemHash,\n        address minter,\n        address gemPoolFactory,\n        address multitoken,\n        address pool,\n        uint256 quantity,\n        Gem gem\n    );\n\n    function indexGem(\n        Gem memory gem\n    ) external returns (bool);\n\n    function indexGems(\n        Gem[] memory gem\n    ) external returns (bool);\n\n    function getOwnedGems(\n        address gemPool,\n        address multitoken,\n        address account,\n        uint256 page,\n        uint256 count\n    )\n        external\n        view\n        returns (uint256[] memory gems);\n}\n\n/// @title A title that should describe the contract/interface\n/// @author The name of the author\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\ncontract BitgemIndexer is IBitgemIndexer, Controllable {\n\n    mapping(uint256 => Gem) public gemMap;\n    mapping(address => Gem[]) public gemsByMinter;\n    mapping(address => Gem[]) public gemsByFactory;\n    mapping(address => Gem[]) public gemsByMultitoken;\n    mapping(address => Gem[]) public gemsByPool;\n\n    constructor() {\n        _addController(address(this));\n    }\n\n    function _makeId(Gem memory gem) internal pure returns (uint256) {\n        return uint256(\n            keccak256(\n                abi.encodePacked(\n                    gem.gemHash,\n                    gem.minter,\n                    gem.gemPoolFactory,\n                    gem.multitoken,\n                    gem.pool,\n                    gem.quantity\n                )\n            )\n        );\n    }\n\n    function getOwnedGems(\n        address gemPool,\n        address multitoken,\n        address account,\n        uint256 page,\n        uint256 count\n    )\n        external\n        view\n        override\n        returns (uint256[] memory gems)\n    {\n        // uint256 allTokenHashesLength = IGemPoolData(gemPool)\n        //     .allTokenHashesLength();\n        // require((page * count) + count <= allTokenHashesLength, \"OUT_OF_RANGE\");\n\n        uint256 gemLen = 0;\n        gems = new uint256[](count);\n\n        for (uint256 i = page * count; i < (page * count) + count; i++) {\n\n            uint256 claimHash = 0;\n            try IGemPoolData(gemPool).allTokenHashes(i) returns (uint256 _claimHash) {\n                claimHash = _claimHash;\n            } catch {\n                continue;\n            }\n\n            INFTGemMultiToken.TokenType tokenType = IGemPoolData(gemPool)\n                .tokenType(claimHash);\n\n            uint256 bal = IERC1155(multitoken).balanceOf(account, claimHash);\n            if (tokenType != INFTGemMultiToken.TokenType.GEM\n                || bal == 0\n                || claimHash == 0\n                || claimHash == 1) continue;\n\n            if (tokenType == INFTGemMultiToken.TokenType.GEM)\n                gems[gemLen++] = claimHash;\n        }\n    }\n\n    function _indexGem(\n        Gem memory gem\n    ) internal returns (bool) {\n        uint256 gemId = _makeId(gem);\n        if (gemMap[gemId].gemHash != 0) {\n            return false;\n        }\n        gem.id = gemId;\n        gemMap[gemId] = gem;\n        gemsByMinter[gem.minter].push(gem);\n        gemsByFactory[gem.gemPoolFactory].push(gem);\n        gemsByMultitoken[gem.multitoken].push(gem);\n        gemsByPool[gem.pool].push(gem);\n        emit GemCreated(\n            gem.id,\n            gem.gemHash,\n            gem.minter,\n            gem.gemPoolFactory,\n            gem.multitoken,\n            gem.pool,\n            gem.quantity,\n            gem\n        );\n        return true;\n    }\n\n\n    function indexGem(\n        Gem memory gem\n    ) external override returns (bool) {\n        return _indexGem(gem);\n    }\n\n    function indexGems(\n        Gem[] memory gem\n    ) external override returns (bool) {\n        bool success = true;\n        for (uint256 i = 0; i < gem.length; i++) {\n            success = success && _indexGem(gem[i]);\n        }\n        return success;\n    }\n\n}\n"
    },
    "src/lootbox/LootboxData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../data/GenericDataSource.sol\";\n\nimport \"../interfaces/ILootboxData.sol\";\n\nimport \"../interfaces/ITokenSeller.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\n\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\n\nimport \"../interfaces/ILootbox.sol\";\n\ncontract LootboxData is ILootboxData, GenericDatasource {\n    // all track lootboxes - as an array, by hash, and by symbol hash\n    ILootbox.Lootbox[] private _allLootboxes;\n    mapping(uint256 => ILootbox.Lootbox) private _lootboxes;\n    mapping(address => ILootbox.Lootbox) private _lootboxesByAddress;\n\n    // tracks loot for each lootbox\n    mapping(uint256 => ILootbox.Loot[]) private _loot;\n\n    // tracks token sale data\n    ITokenSeller.TokenSellerInfo[] private _allTokenSellers;\n    mapping(address => ITokenSeller.TokenSellerInfo) private _tokenSellers;\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    function addLootbox(ILootbox.Lootbox memory _lootbox)\n        external\n        override\n        returns (uint256 lootbox)\n    {\n        require(bytes(_lootbox.symbol).length != 0, \"symbol must be set\");\n        if(_lootbox.lootboxHash == 0) {\n            _lootbox.lootboxHash = uint256(keccak256(abi.encodePacked(_lootbox.symbol)));\n        }\n        if(_lootbox.contractAddress == address(0)) {\n            _lootbox.contractAddress = msg.sender;\n        }\n        _allLootboxes.push(_lootbox);\n        _lootboxes[_lootbox.lootboxHash] = _lootbox;\n        _lootboxesByAddress[_lootbox.contractAddress] = _lootbox;\n        return _allLootboxes.length - 1;\n    }\n\n    function getLootboxByAddress(address lootbox)\n        external\n        view\n        override\n        onlyController\n        returns (ILootbox.Lootbox memory)\n    {\n        return _lootboxesByAddress[lootbox];\n    }\n\n    function getLootboxByHash(uint256 lootbox)\n        external\n        view\n        override\n        onlyController\n        returns (ILootbox.Lootbox memory)\n    {\n        return _lootboxes[lootbox];\n    }\n\n    function lootboxes()\n        external\n        view\n        override\n        onlyController\n        returns (ILootbox.Lootbox[] memory)\n    {\n        return _allLootboxes;\n    }\n\n    function allLootboxes(uint256 index)\n        external\n        view\n        override\n        onlyController\n        returns (ILootbox.Lootbox memory)\n    {\n        return _allLootboxes[index];\n    }\n\n    function allLootboxesLength()\n        external\n        view\n        override\n        onlyController\n        returns (uint256)\n    {\n        return _allLootboxes.length;\n    }\n\n    function setLootbox(\n        ILootbox.Lootbox memory lootboxData\n    ) external override onlyController {\n        require(_lootboxes[lootboxData.lootboxHash].contractAddress != address(0)\n        && _lootboxes[lootboxData.lootboxHash].contractAddress == lootboxData.contractAddress, \"lootbox must be initialized\");\n        // TODO: upddate this so it only sets the updateable fields\n        _lootboxes[lootboxData.lootboxHash] = lootboxData;\n    }\n\n    function getLoot(uint256 lootbox, uint256 index)\n        external\n        view\n        override\n        onlyController\n        returns (ILootbox.Loot memory)\n    {\n        return _loot[lootbox][index];\n    }\n\n    function addLoot(uint256 lootbox, ILootbox.Loot memory lootboxData)\n        external\n        override\n        onlyController\n        returns (uint256)\n    {\n        require(_lootboxes[lootbox].owner != address(0), \"Lootbox is not set\"); // require a valid lootbox\n        _loot[lootbox].push(lootboxData);\n        return _loot[lootbox].length;\n    }\n\n    function setLoot(\n        uint256 lootbox,\n        uint256 index,\n        ILootbox.Loot memory lootboxData\n    ) external override onlyController {\n        require(index < _loot[lootbox].length, \"Index out of bounds\");\n        _loot[lootbox][index] = lootboxData;\n    }\n\n    function allLoot(uint256 lootbox)\n        external\n        view\n        override\n        onlyController\n        returns (ILootbox.Loot[] memory)\n    {\n        return _loot[lootbox];\n    }\n\n    function delLoot(uint256 lootbox, uint256 index)\n        external\n        override\n        onlyController\n        returns (ILootbox.Loot memory lootboxData)\n    {\n        require(\n            index >= 0 && index < _loot[lootbox].length,\n            \"Index out of bounds\"\n        );\n        uint256 lastEl = _loot[lootbox].length - 1;\n        lootboxData = _loot[lootbox][index];\n        if (lastEl > index) {\n            _loot[lootbox][index] = _loot[lootbox][lastEl];\n        }\n        _loot[lootbox].pop();\n    }\n\n    function addTokenSeller(\n        address tokenSeller,\n        ITokenSeller.TokenSellerInfo memory tokenSellerInfo\n    ) external override onlyController returns (uint256 tokenSellerIndex) {\n        require(\n            _tokenSellers[tokenSeller].multitoken == address(0),\n            \"Token seller already exists\"\n        );\n        _tokenSellers[tokenSeller] = tokenSellerInfo;\n        return _allTokenSellers.length;\n    }\n\n    function getTokenSeller(address tokenSeller)\n        external\n        view\n        override\n        onlyController\n        returns (ITokenSeller.TokenSellerInfo memory)\n    {\n        return _tokenSellers[tokenSeller];\n    }\n\n    function setTokenSeller(\n        address tokenSellerAddress,\n        ITokenSeller.TokenSellerInfo memory tokenSellerData\n    ) external override onlyController {\n        require(msg.sender == tokenSellerAddress, \"Token seller is not set\");\n        _tokenSellers[tokenSellerAddress] = tokenSellerData;\n    }\n\n    function tokenSellers()\n        external\n        view\n        override\n        onlyController\n        returns (ITokenSeller.TokenSellerInfo[] memory)\n    {\n        return _allTokenSellers;\n    }\n\n    function allTokenSellers(uint256 index)\n        external\n        view\n        override\n        onlyController\n        returns (ITokenSeller.TokenSellerInfo memory)\n    {\n        return _allTokenSellers[index];\n    }\n\n    function allTokenSellersLength()\n        external\n        view\n        override\n        onlyController\n        returns (uint256)\n    {\n        return _allTokenSellers.length;\n    }\n\n    function getFeeManager() external view override returns (address) {\n        return this.getAddr(\"feeManagerAddress\");\n    }\n\n    function setFeeManager(address feeManagerAddress) external override {\n        this.setAddr(\"feeManagerAddress\", feeManagerAddress);\n    }\n\n    function increaseBuyPrice(address tokenSeller) external view override returns (uint256) {\n        ITokenSeller.TokenSellerInfo memory _tokenSeller = _tokenSellers[tokenSeller];\n        if (\n            _tokenSeller.buyPriceIncreaseRateType ==\n            ITokenSeller.BuyPriceIncreaseRateType.NONE\n        ) {\n            return _tokenSeller.buyPrice;\n        } else if (\n            _tokenSeller.buyPriceIncreaseRateType ==\n            ITokenSeller.BuyPriceIncreaseRateType.FIXED\n        ) {\n            return _tokenSeller.buyPrice + _tokenSeller.buyPriceIncreaseRate;\n        } else if (\n            _tokenSeller.buyPriceIncreaseRateType ==\n            ITokenSeller.BuyPriceIncreaseRateType.EXPONENTIAL\n        ) {\n            return\n                _tokenSeller.buyPrice +\n                (_tokenSeller.buyPrice / _tokenSeller.buyPriceIncreaseRate);\n        } else if (\n            _tokenSeller.buyPriceIncreaseRateType ==\n            ITokenSeller.BuyPriceIncreaseRateType.INVERSELOG\n        ) {\n            return\n                _tokenSeller.buyPrice +\n                (_tokenSeller.buyPriceIncreaseRate / _tokenSeller.buyPrice);\n        }\n        return _tokenSeller.buyPrice;\n    }\n}\n"
    },
    "src/data/GenericDataSource.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IGenericDataSource.sol\";\nimport \"../access/Controllable.sol\";\n\n/// this contract provides a generic data source for other smart contracts.\n/// data can be set and retrieved by the owner of the contract. The basic datattypes\n/// are supported: string, bytes, uint, bool, and address. Data is set and retrieved\n/// through the 'setXXX' and 'getXXX' methods. This contract exists to enable a\n/// modular design pattern that enables easy upgrades of business logic without\n/// changing the smart contract.\ncontract GenericDatasource is IGenericDatasource, Controllable {\n    mapping(string => string) internal stringData;\n    mapping(string => bytes) internal bytesData;\n    mapping(string => uint256) internal uintData;\n    mapping(string => bool) internal boolData;\n    mapping(string => address) internal addressData;\n\n    /// @dev contract constructor\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /// @dev set a string value\n    /// @param key the key of the string value\n    /// @return the value if the value was set, falsey otherwise\n    function getStr(string memory key)\n        external\n        view\n        override\n        onlyController\n        returns (string memory)\n    {\n        return stringData[key];\n    }\n\n    /// @dev set a string value\n    /// @param key the key of the string value\n    /// @param value the value to set\n    /// @return oldData string the old data the the new data replaced\n    function setStr(string memory key, string memory value)\n        external\n        override\n        onlyController\n        returns (string memory oldData)\n    {\n        oldData = stringData[key];\n        stringData[key] = value;\n    }\n\n    function getInt(string memory key)\n        external\n        view\n        override\n        onlyController\n        returns (uint256 _data)\n    {\n        _data = uintData[key];\n    }\n\n    function setInt(string memory key, uint256 value)\n        external\n        override\n        onlyController\n    {\n        uintData[key] = value;\n    }\n\n    function getBool(string memory key)\n        external\n        view\n        override\n        onlyController\n        returns (bool _data)\n    {\n        _data = boolData[key];\n    }\n\n    function setBool(string memory key, bool bval)\n        external\n        override\n        onlyController\n    {\n        boolData[key] = bval;\n    }\n\n    function getBytes(string memory key)\n        external\n        view\n        override\n        onlyController\n        returns (bytes memory)\n    {\n        return bytesData[key];\n    }\n\n    function setBytes(string memory key, bytes memory value)\n        external\n        override\n        onlyController\n    {\n        bytesData[key] = value;\n    }\n\n    function getAddr(string memory key)\n        external\n        view\n        override\n        onlyController\n        returns (address)\n    {\n        return addressData[key];\n    }\n\n    function setAddr(string memory key, address value)\n        external\n        override\n        onlyController\n    {\n        addressData[key] = value;\n    }\n}\n"
    },
    "src/interfaces/IGenericDataSource.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IGenericDatasource {\n    function getStr(string memory key) external view returns (string memory);\n\n    function setStr(string memory key, string memory value)\n        external\n        returns (string memory);\n\n    function getInt(string memory key) external view returns (uint256);\n\n    function setInt(string memory key, uint256 value) external;\n\n    function getBool(string memory key) external view returns (bool);\n\n    function setBool(string memory key, bool value) external;\n\n    function getBytes(string memory key) external view returns (bytes memory);\n\n    function setBytes(string memory key, bytes memory value) external;\n\n    function getAddr(string memory key) external view returns (address);\n\n    function setAddr(string memory key, address value) external;\n}\n"
    },
    "src/interfaces/ILootboxFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./ILootbox.sol\";\n\n/**\n * @dev Interface for a Bitgem lootbox factory\n */\ninterface ILootboxFactory {\n    /**\n     * @dev emitted when a new gem pool has been added to the system\n     */\n    event LootboxCreated(\n        uint256 id,\n        address contractAddress,\n        ILootbox.Lootbox data\n    );\n\n    event LootboxMigrated(\n        uint256 id,\n        address contractAddress,\n        ILootbox.Lootbox data\n    );\n\n    function initialize(address) external;\n\n    function getLootbox(uint256 _symbolHash)\n        external\n        view\n        returns (ILootbox.Lootbox memory);\n\n    function lootboxes() external view returns (ILootbox.Lootbox[] memory _all);\n\n    function allLootboxes(uint256 idx) external view returns (ILootbox.Lootbox memory _lootbox);\n\n    function allLootboxesLength() external view returns (uint256);\n\n    function createLootbox(address owner, ILootbox.Lootbox memory _lootbox, ITokenSeller.TokenSellerInfo memory _tokenSellerInfo)\n        external\n        returns (ILootbox.Lootbox memory);\n}\n"
    },
    "src/factories/LootboxFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../lootbox/LootboxContract.sol\";\n\nimport \"../interfaces/ITokenSeller.sol\";\n\nimport \"../interfaces/ILootbox.sol\";\n\nimport \"../interfaces/ILootboxData.sol\";\n\nimport \"../interfaces/ILootboxFactory.sol\";\n\nimport \"../access/Controllable.sol\";\n\ncontract LootboxFactory is ILootboxFactory, Controllable, Initializable {\n    ILootboxData internal _lootboxData;\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    modifier initialized() {\n        require(\n            address(_lootboxData) != address(0),\n            \"Lootbox is not initialized\"\n        );\n        _;\n    }\n\n    /**\n     * @dev contract initialiser - set the data object\n     */\n    function initialize(address __data) external override initializer {\n        require(\n            IControllable(__data).isController(address(this)) == true,\n            \"Lootbox data must be controlled by this lootbox factory\"\n        );\n        _lootboxData = ILootboxData(__data);\n    }\n\n    function isInitialized() external view returns (bool) {\n        return address(_lootboxData) != address(0);\n    }\n\n    /**\n     * @dev get a lootbox\n     */\n    function getLootbox(uint256 _symbolHash)\n        external\n        view\n        override\n        initialized\n        returns (ILootbox.Lootbox memory _lootbox)\n    {\n        _lootbox = _lootboxData.getLootboxByHash(_symbolHash);\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function lootboxes()\n        external\n        view\n        override\n        initialized\n        returns (ILootbox.Lootbox[] memory _all)\n    {\n        _all = _lootboxData.lootboxes();\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function allLootboxes(uint256 idx)\n        external\n        view\n        override\n        initialized\n        returns (ILootbox.Lootbox memory _lootbox)\n    {\n        _lootbox = _lootboxData.allLootboxes(idx);\n    }\n\n    /**\n     * @dev number of lootboxes\n     */\n    function allLootboxesLength()\n        external\n        view\n        override\n        initialized\n        returns (uint256 _len)\n    {\n        _len = _lootboxData.allLootboxesLength();\n    }\n\n    /**\n     * @dev deploy a new lootbox using create2\n     */\n    function createLootbox(address owner, ILootbox.Lootbox memory _lootbox, ITokenSeller.TokenSellerInfo memory _tokenSellerInfo)\n        external\n        override\n        initialized\n        returns (ILootbox.Lootbox memory lootbox_)\n    {\n        // create the lookup hash for the given symbol\n        // and check if it already exists\n        bytes32 salt = keccak256(abi.encodePacked(_lootbox.symbol));\n        require(\n            _lootboxData.getLootboxByHash(uint256(salt)).contractAddress ==\n                address(0),\n            \"Lootbox EXISTS\"\n        ); // single check is sufficient\n\n        // TODO: validation checks on the incoming Lootbox data\n\n        // create the gem pool using create2, which lets us determine the\n        // address of a gem pool without interacting with the contract itself\n        bytes memory bytecode = type(LootboxContract).creationCode;\n\n        // initialize lootbox object\n        lootbox_ = _lootbox;\n\n        // use create2 to deploy the gem pool contract\n        lootbox_.contractAddress = payable(Create2.deploy(0, salt, bytecode));\n\n        // set the controller of the lootbox\n        IControllable(lootbox_.contractAddress).addController(owner);\n        IControllable(address(_lootboxData)).addController(lootbox_.contractAddress);\n\n        // initialize the lootbox data\n        ILootbox(lootbox_.contractAddress).initialize(address(_lootboxData), _tokenSellerInfo, _lootbox);\n\n        // emit an event about the new pool being created\n        emit LootboxCreated(\n            _lootbox.lootboxHash,\n            _lootbox.contractAddress,\n            _lootbox\n        );\n    }\n\n    function migrate(address migrateTo) external initialized onlyController {\n        Controllable(address(_lootboxData)).addController(migrateTo);\n        LootboxFactory(migrateTo).initialize(address(_lootboxData));\n        selfdestruct(payable(migrateTo));\n    }\n}\n"
    },
    "src/lootbox/LootboxContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"../interfaces/ILootbox.sol\";\nimport \"../interfaces/IRandomFarm.sol\";\nimport \"../interfaces/ILootboxData.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../access/Controllable.sol\";\nimport \"./TokenSeller.sol\";\nimport \"./LootboxLib.sol\";\n\n/// @dev A lootbox is a contract that works with an erc1155 to implement a game lootbox:\n/// a lootbox is a contract that accepts a single quantity of some erc1155 tokenhash and\n/// then based on a set of rules goverened by probability, mints one or more outgoing tokens\n/// as it burns the incoming token. The rules are defined by the lootbox author and are\n/// stored in the lootbox contract. A newly-created lootbox contract assigns controllership\n/// to its creator, who can them add other controllers, and can set the rules for the lootbox.\n/// Each lootbox is configured with some number of Loot items, each of which has deterministic\n/// tokenhash. These loot items each have names, symbols, and a probability of being minted.\n/// Users open the lootbox by providing the right gem to the lootbox contract, and then\n/// the lootbox contract mints the right number of tokens for the user. This contract uses\n/// a pseudo-random deterministic sieve to determine the number and type of tokens minted\n\ncontract LootboxContract is ILootbox, Controllable, Initializable, TokenSeller {\n    ILootboxData internal _lootboxData;\n    ILootbox.Lootbox internal _lootbox;\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /// @dev contract must be initilized for modified method to be called\n    modifier initialized() override {\n        require(\n            _lootbox.lootboxHash != 0 && _lootbox.initialized == true,\n            \"Lootbox is not initialized\"\n        );\n        _;\n    }\n\n    /// @dev Sets the lootbox data. The lootbox contract can either initialise a new\n    // lootbox struct or it can load and update an existing lootbox struct.\n    function initialize(\n        address lootboxData,\n        ITokenSeller.TokenSellerInfo memory tokenSellerInfo,\n        ILootbox.Lootbox memory lootboxInit\n    )\n    external override initializer {\n        require(\n            IControllable(lootboxData).isController(address(this)) == true,\n            \"Lootbox data must be controlled by this lootbox\"\n        );\n        _lootboxData = ILootboxData(lootboxData);\n        bool isNew = lootboxInit.lootboxHash == 0;\n        _lootbox = LootboxLib.initialize(lootboxInit);\n        _lootbox.contractAddress = address(this);\n        tokenSellerInfo.tokenHash = _lootbox.lootboxHash;\n        this.initialize(lootboxData, tokenSellerInfo);\n        _lootboxData.setTokenSeller(address(this), tokenSellerInfo);\n        if(isNew) {\n            _lootboxData.addLootbox(_lootbox);\n            emit LootboxCreated(\n                msg.sender,\n                _lootbox.lootboxHash,\n                address(this),\n                _lootbox\n            );\n        } else {\n            // load the lootbox struct\n            _lootbox = _lootboxData.getLootboxByHash(lootboxInit.lootboxHash);\n            _lootbox.contractAddress = address(this);\n            _lootboxData.setLootbox(_lootbox);\n            require(\n                _lootbox.owner == msg.sender,\n                \"Lootbox must be owned by the caller to uppgrade contract\"\n            );\n            emit LootboxMigrated(\n                msg.sender,\n                _lootbox.lootboxHash,\n                _lootbox.contractAddress,\n                address(this),\n                _lootbox\n            );\n        }\n    }\n\n    function openLootbox()\n        external\n        override\n        initialized\n        returns (Loot[] memory _lootOut)\n    {\n        Loot[] memory _allLoot = _lootboxData.allLoot(_lootbox.lootboxHash);\n        return LootboxLib.openLootbox(_lootbox, _allLoot);\n    }\n\n    function mintLootboxTokens(uint256 amount)\n        external\n        override\n        initialized\n        onlyController\n    {\n        // mint the loot item to the owner\n        INFTGemMultiToken(_lootbox.multitoken).mint(\n            msg.sender,\n            _lootbox.lootboxHash,\n            amount\n        );\n\n        // generate an event reporting on the loot that was found\n        emit LootboxTokensMinted(\n            msg.sender,\n            _lootbox.lootboxHash,\n            _lootbox,\n            amount\n        );\n    }\n\n    function mintLoot(uint8 index, uint256 amount)\n        external\n        override\n        initialized\n        onlyController\n        returns (Loot memory)\n    {\n        Loot[] memory _allLoot = _lootboxData.allLoot(_lootbox.lootboxHash);\n        return LootboxLib.mintLoot(_lootbox, _allLoot, index, amount);\n    }\n\n    function allLoot()\n        external\n        view\n        override\n        initialized\n        returns (Loot[] memory)\n    {\n        return _lootboxData.allLoot(_lootbox.lootboxHash);\n    }\n\n    function addLoot(Loot memory _loot)\n        external\n        override\n        initialized\n        onlyController\n        returns (uint256)\n    {\n        // basic sanity checks\n        require(bytes(_loot.symbol).length > 0, \"Symbol must be set\");\n        require(bytes(_loot.name).length > 0, \"name must be set\");\n        require(_loot.probability > 0, \"probability must be set\");\n\n        // populate field values the loot must have\n        _loot.owner = _lootbox.owner;\n        _loot.multitoken = _lootbox.multitoken;\n        _loot.probabilityIndex = _lootbox.probabilitiesSum + _loot.probability;\n        _lootbox.probabilitiesSum += _loot.probability;\n        _lootboxData.setLootbox(_lootbox);\n        _loot.lootHash = uint256(\n            keccak256(abi.encodePacked(_lootbox.symbol, _loot.symbol))\n        );\n\n        // emit a message about it\n        emit LootAdded(msg.sender, _lootbox.lootboxHash, _lootbox, _loot);\n\n        // return the added loot item index\n        return _lootboxData.addLoot(_lootbox.lootboxHash, _loot);\n    }\n\n    function _recalculateProbabilities() internal {\n        // get all the loot there is to award\n        Loot[] memory _allLoot = _lootboxData.allLoot(_lootbox.lootboxHash);\n        uint256 floor = 0;\n        // iterate through the loot items\n        for (uint256 i = 0; i < _allLoot.length; i++) {\n            // set the probability index to the floor\n            _allLoot[i].probabilityIndex = floor + _allLoot[i].probability;\n            floor += _allLoot[i].probability;\n            _lootboxData.setLoot(_lootbox.lootboxHash, i, _allLoot[i]);\n        }\n    }\n\n    function getLoot(uint256 index)\n        external\n        view\n        override\n        initialized\n        returns (Loot memory)\n    {\n        return _lootboxData.getLoot(_lootbox.lootboxHash, index);\n    }\n\n    function withdrawFees(address receiver)\n        external\n        initialized\n        onlyController\n    {\n        require(address(this).balance > 0, \"Lootbox is empty\");\n        payable(receiver).transfer(address(this).balance);\n    }\n\n    function feeBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function migrate_LootboxContract(address migrateTo) external initialized onlyController {\n        this.migrate_TokenSeller(migrateTo, false);\n        IControllable(address(_lootboxData)).addController(migrateTo);\n        ILootbox(migrateTo).initialize (address(_lootboxData), _tokenSeller, _lootbox);\n    }\n}\n"
    },
    "src/random/RandomFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IRandomFarm.sol\";\n\nimport \"../access/Controllable.sol\";\n\n/**\n * @dev A randomness farm. It does what it says - it farms randomness that\n * is provided by the user into usable randomness by other contracts.\n */\ncontract RandomFarm is IRandomFarm, Initializable {\n    uint256 private randomSeed;\n    mapping(address => uint256) private salt;\n\n    function initialize(uint256 seed) external override initializer {\n        randomSeed = seed;\n    }\n\n    function isInitialized() external view returns (bool) {\n        return randomSeed != 0;\n    }\n\n    function addRandomness(uint256 randomness) external override {\n        randomSeed = uint256(\n            keccak256(abi.encodePacked(randomSeed, randomness))\n        );\n    }\n\n    function getRandomBytes(uint8 amount)\n        external\n        override\n        returns (bytes32[] memory _randomBytes)\n    {\n        _randomBytes = new bytes32[](amount);\n        for (uint8 i = 0; i < amount; i++) {\n            _randomBytes[i] = _randomByte32();\n        }\n    }\n\n    function getRandomUints(uint8 amount)\n        external\n        override\n        returns (uint256[] memory _randomUints)\n    {\n        _randomUints = new uint256[](amount);\n        for (uint8 i = 0; i < amount; i++) {\n            _randomUints[i] = _randomUint();\n        }\n    }\n\n    function _randomByte32() internal returns (bytes32 _bytes32) {\n        _bytes32 = bytes32(\n            keccak256(\n                abi.encodePacked(\n                    blockhash(block.number - 1),\n                    randomSeed,\n                    tx.origin,\n                    salt[tx.origin]++\n                )\n            )\n        );\n    }\n\n    function _randomUint() internal returns (uint256 _uint) {\n        _uint = uint256(\n            keccak256(\n                abi.encodePacked(\n                    blockhash(block.number - 1),\n                    randomSeed,\n                    tx.origin,\n                    salt[tx.origin]++\n                )\n            )\n        );\n    }\n\n    function getRandomNumber(uint256 min, uint256 max)\n        external\n        override\n        returns (uint256)\n    {\n        return min + (_randomUint() % (max - min));\n    }\n}\n\ncontract RandomFarmer is IRandomFarmer, Controllable {\n    IRandomFarm private farm;\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    function setFarm(address _farm) public onlyController {\n        farm = IRandomFarm(_farm);\n    }\n\n    function getFarm() public view returns (address _farm) {\n        _farm = address(farm);\n    }\n\n    function getRandomBytes(uint8 amount)\n        external\n        override\n        returns (bytes32[] memory)\n    {\n        return farm.getRandomBytes(amount);\n    }\n\n    function getRandomUints(uint8 amount)\n        external\n        override\n        returns (uint256[] memory)\n    {\n        return farm.getRandomUints(amount);\n    }\n\n    function getRandomNumber(uint256 min, uint256 max)\n        external\n        override\n        returns (uint256)\n    {\n        return farm.getRandomNumber(min, max);\n    }\n}\n"
    },
    "src/tokens/ERC20WrappedGem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport \"./ERC20Constructorless.sol\";\n\nimport \"../interfaces/IERC20WrappedGem.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\nimport \"./WrappedTokenLib.sol\";\n\n/**\n * @dev Wraps a gem (erc1155 'gem' type issued by an NFTGemPool) into erc1155\n */\ncontract ERC20WrappedGem is\n    ERC20Constructorless,\n    ERC1155Holder,\n    IERC20WrappedGem,\n    Initializable\n{\n    using WrappedTokenLib for WrappedTokenLib.WrappedTokenData;\n    address internal _feeManager;\n\n    WrappedTokenLib.WrappedTokenData internal tokenData;\n\n    /**\n     * @dev initialize contract state\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address gemPool,\n        address gemToken,\n        uint8 decimals,\n        address feeManager\n    ) external override initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _feeManager = feeManager;\n        tokenData.erc1155token = gemToken;\n        tokenData.erc20token = address(this);\n        tokenData.tokenPool = gemPool;\n        tokenData.index = 0;\n        tokenData.rate = 1;\n        tokenData.tokenType = INFTGemMultiToken.TokenType.GEM;\n    }\n\n    /**\n     * @dev get fee to wrap tokens\n     */\n    function getWrapFee(uint256 totalQuantity)\n        internal\n        view\n        returns (uint256 fd)\n    {\n        uint256 thisWrapFeeHash = uint256(\n            keccak256(abi.encodePacked(\"wrap_gem\", address(this)))\n        );\n        fd = INFTGemFeeManager(_feeManager).fee(thisWrapFeeHash);\n        if (fd == 0) {\n            thisWrapFeeHash = uint256(keccak256(abi.encodePacked(\"wrap_gem\")));\n            fd = INFTGemFeeManager(_feeManager).fee(thisWrapFeeHash);\n        }\n        return fd != 0 ? totalQuantity / fd : 0;\n    }\n\n    /**\n     * @dev wrap gems to erc20\n     */\n    function wrap(uint256 quantity) external override {\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(\n            WrappedTokenLib.getPoolTypeBalance(\n                tokenData.erc1155token,\n                tokenData.tokenPool,\n                tokenData.tokenType,\n                msg.sender\n            ) >= quantity,\n            \"INSUFFICIENT_QUANTITY\"\n        );\n        uint256 tq = quantity * (tokenData.rate * 10**decimals());\n\n        uint256 fee = getWrapFee(tq);\n        uint256 userQty = tq - fee;\n\n        tokenData.transferPoolTypesFrom(msg.sender, address(this), quantity);\n        _mint(msg.sender, userQty);\n        _mint(_feeManager, fee);\n\n        tokenData.wrappedBalance = tokenData.wrappedBalance + quantity;\n\n        emit Wrap(msg.sender, quantity);\n    }\n\n    /**\n     * @dev unwrap wrapped gems\n     */\n    function unwrap(uint256 quantity) external override {\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(\n            balanceOf(msg.sender) * (10**decimals()) >= quantity,\n            \"INSUFFICIENT_QUANTITY\"\n        );\n\n        tokenData.transferPoolTypesFrom(address(this), msg.sender, quantity);\n        _burn(msg.sender, quantity * (10**decimals()));\n        tokenData.wrappedBalance = tokenData.wrappedBalance - (quantity);\n\n        emit Unwrap(msg.sender, quantity);\n    }\n\n    /**\n     * @dev get reserves held in wrapper\n     */\n    function getReserves() external view override returns (uint256) {\n        return tokenData.wrappedBalance;\n    }\n\n    /**\n     * @dev get the token address this wrapper is bound to\n     */\n    function getTokenAddress() external view override returns (address) {\n        return tokenData.erc1155token;\n    }\n\n    /**\n     * @dev get the token id this wrapper is bound to\n     */\n    function getTokenId() external view override returns (uint256) {\n        return tokenData.index;\n    }\n}\n"
    },
    "src/tokens/ERC20Constructorless.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Constructorless is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n\n    uint8 internal _decimals;\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/factories/ERC20GemTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"../tokens/ERC20WrappedGem.sol\";\n\nimport \"../interfaces/IERC20GemTokenFactory.sol\";\nimport \"../interfaces/IERC20WrappedGem.sol\";\n\ncontract ERC20GemTokenFactory is IERC20GemTokenFactory {\n    address private operator;\n\n    mapping(uint256 => address) private _getItem;\n    address[] private _allItems;\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function getItem(uint256 _symbolHash)\n        external\n        view\n        override\n        returns (address gemPool)\n    {\n        gemPool = _getItem[_symbolHash];\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function items() external view override returns (address[] memory) {\n        return _allItems;\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function allItems(uint256 idx)\n        external\n        view\n        override\n        returns (address gemPool)\n    {\n        gemPool = _allItems[idx];\n    }\n\n    /**\n     * @dev number of quantized addresses\n     */\n    function allItemsLength() external view override returns (uint256) {\n        return _allItems.length;\n    }\n\n    /**\n     * @dev deploy a new erc20 token using create2\n     */\n    function createItem(\n        string memory tokenSymbol,\n        string memory tokenName,\n        address poolAddress,\n        address tokenAddress,\n        uint8 decimals,\n        address feeManager\n    ) external override returns (address payable gemToken) {\n        bytes32 salt = keccak256(abi.encodePacked(tokenSymbol));\n        require(_getItem[uint256(salt)] == address(0), \"GEMTOKEN_EXISTS\"); // single check is sufficient\n        require(poolAddress != address(0), \"INVALID_POOL\");\n\n        // create the quantized erc20 token using create2, which lets us determine the\n        // quantized erc20 address of a token without interacting with the contract itself\n        bytes memory bytecode = type(ERC20WrappedGem).creationCode;\n\n        // use create2 to deploy the quantized erc20 contract\n        gemToken = payable(Create2.deploy(0, salt, bytecode));\n\n        // initialize the erc20 contract with the relevant addresses which it proxies\n        IERC20WrappedGem(gemToken).initialize(\n            tokenName,\n            tokenSymbol,\n            poolAddress,\n            tokenAddress,\n            decimals,\n            feeManager\n        );\n\n        // insert the erc20 contract address into lists - one that maps source to quantized,\n        _getItem[uint256(salt)] = gemToken;\n        _allItems.push(gemToken);\n\n        // emit an event about the new pool being created\n        emit ERC20GemTokenCreated(\n            gemToken,\n            poolAddress,\n            tokenSymbol,\n            ERC20(gemToken).symbol()\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/interfaces/IERC20GemTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface IERC20GemTokenFactory {\n    /**\n     * @dev emitted when a new gem pool has been added to the system\n     */\n    event ERC20GemTokenCreated(\n        address tokenAddress,\n        address poolAddress,\n        string tokenSymbol,\n        string poolSymbol\n    );\n\n    function getItem(uint256 _symbolHash) external view returns (address);\n\n    function items() external view returns (address[] memory);\n\n    function allItems(uint256 idx) external view returns (address);\n\n    function allItemsLength() external view returns (uint256);\n\n    function createItem(\n        string memory tokenSymbol,\n        string memory tokenName,\n        address poolAddress,\n        address tokenAddress,\n        uint8 decimals,\n        address feeManager\n    ) external returns (address payable);\n}\n"
    },
    "src/tokens/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @dev a test token for whatever. mints 1m tokens to caller\n */\ncontract TestToken is ERC20 {\n    constructor(string memory symbol, string memory name) ERC20(symbol, name) {\n        _mint(msg.sender, 1000000 ether);\n    }\n}\n"
    },
    "src/diagnostics/TokenPoolQuerier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"../interfaces/ITokenPoolQuerier.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\n\ninterface IGemPoolData {\n    function allTokenHashesLength() external view returns (uint256);\n\n    function allTokenHashes(uint256 ndx) external view returns (uint256);\n\n    function tokenType(uint256 tokenHash)\n        external\n        view\n        returns (INFTGemMultiToken.TokenType);\n}\n\ncontract TokenPoolQuerier is ITokenPoolQuerier {\n    function getOwnedTokens(\n        address gemPool,\n        address multitoken,\n        address account,\n        uint256 page,\n        uint256 count\n    )\n        external\n        view\n        override\n        returns (uint256[] memory claims, uint256[] memory gems)\n    {\n        uint256 allTokenHashesLength = IGemPoolData(gemPool)\n            .allTokenHashesLength();\n        require((page * count) <= allTokenHashesLength, \"OUT_OF_RANGE\");\n\n        uint256 claimLen = 0;\n        uint256 gemLen = 0;\n\n        claims = new uint256[](count);\n        gems = new uint256[](count);\n\n        for (uint256 i = page * count; i < (page * count) + count; i++) {\n            if (i >= allTokenHashesLength) {\n                break;\n            }\n            uint256 claimHash = IGemPoolData(gemPool).allTokenHashes(i);\n            INFTGemMultiToken.TokenType tokenType = IGemPoolData(gemPool)\n                .tokenType(claimHash);\n            uint256 bal = IERC1155(multitoken).balanceOf(account, claimHash);\n            if (bal == 0 || claimHash == 0 || claimHash == 1) continue;\n            else if (tokenType == INFTGemMultiToken.TokenType.CLAIM)\n                claims[claimLen++] = claimHash;\n            else if (tokenType == INFTGemMultiToken.TokenType.GEM)\n                gems[gemLen++] = claimHash;\n        }\n    }\n}\n"
    },
    "src/interfaces/ITokenPoolQuerier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITokenPoolQuerier {\n    function getOwnedTokens(\n        address gemPool,\n        address multitoken,\n        address account,\n        uint256 page,\n        uint256 count\n    ) external view returns (uint256[] memory claims, uint256[] memory gems);\n}\n"
    },
    "src/fees/NFTGemFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../access/Controllable.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\ncontract NFTGemFeeManager is Controllable, INFTGemFeeManager {\n    address private operator;\n\n    uint256 public constant MINIMUM_LIQUIDITY_HASH =\n        uint256(keccak256(\"min_liquidity\"));\n    uint256 public constant POOL_FEE_HASH =\n        uint256(keccak256(abi.encodePacked(\"pool_fee\")));\n    uint256 public constant WRAP_GEM_HASH =\n        uint256(keccak256(abi.encodePacked(\"wrap_gem\")));\n    uint256 public constant FLASH_LOAN_HASH =\n        uint256(keccak256(abi.encodePacked(\"flash_loan\")));\n\n    uint256 private constant MINIMUM_LIQUIDITY = 50;\n    uint256 private constant POOL_FEE = 2000;\n    uint256 private constant WRAP_GEM = 2000;\n    uint256 private constant FLASH_LOAN = 10000;\n\n    mapping(uint256 => uint256) private fees;\n\n    /**\n     * @dev constructor\n     */\n    constructor() {\n        _addController(msg.sender);\n        fees[MINIMUM_LIQUIDITY_HASH] = MINIMUM_LIQUIDITY;\n        fees[POOL_FEE_HASH] = POOL_FEE;\n        fees[WRAP_GEM_HASH] = WRAP_GEM;\n        fees[FLASH_LOAN_HASH] = FLASH_LOAN;\n    }\n\n    /**\n     * @dev receive funds\n     */\n    receive() external payable {\n        //\n    }\n\n    /**\n     * @dev Get the fee divisor for the specified token\n     */\n    function fee(uint256 feeHash)\n        external\n        view\n        override\n        returns (uint256 feeRet)\n    {\n        feeRet = fees[feeHash];\n    }\n\n    /**\n     * @dev Set the fee divisor for the specified token\n     */\n    function setFee(uint256 feeHash, uint256 _fee)\n        external\n        override\n        onlyController\n    {\n        fees[feeHash] = _fee;\n        emit FeeChanged(operator, feeHash, _fee);\n    }\n\n    /**\n     * @dev get the balance of this fee manager. Pass a zero address in for FTM balance\n     */\n    function balanceOf(address token) external view override returns (uint256) {\n        return\n            token == address(0)\n                ? address(this).balance\n                : IERC20(token).balanceOf(address(this));\n    }\n\n    /**\n     * @dev transfer ETH from this contract to the to given recipient\n     */\n    function transferEth(address payable recipient, uint256 amount)\n        external\n        override\n        onlyController\n    {\n        recipient.transfer(amount);\n    }\n\n    /**\n     * @dev transfer tokens from this contract to the to given recipient\n     */\n    function transferToken(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external override onlyController {\n        IERC20(token).transfer(recipient, amount);\n    }\n}\n"
    },
    "src/swap/uniswap/UniswapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./UniswapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\nimport \"../../access/Controllable.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract UniswapQueryHelper is ISwapQueryHelper, Controllable {\n    address private customFactory;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return UniswapLib.ethQuote(token, tokenAmount);\n    }\n\n    function __factory() internal view returns (address fac) {\n        fac = customFactory != address(0)\n            ? customFactory\n            : UniswapLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external view override returns (address fac) {\n        fac = __factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = UniswapLib.WETH();\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        override\n        returns (address pair)\n    {\n        pair = UniswapLib.getPair(__factory(), tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = UniswapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return UniswapLib.hasPool(token);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        return UniswapLib.getPathForETHToToken(token);\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address f) external override onlyController {\n        customFactory = f;\n    }\n}\n"
    },
    "src/swap/uniswap/UniswapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary UniswapLib {\n    address public constant UNISWAP_ROUTER_ADDRESS =\n        0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function ethQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        (tokenReserve, ethReserve, ) = IUniswapV2Pair(_pair).getReserves();\n        ethereum = quote(tokenAmount, tokenReserve, ethReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WETH() external pure returns (address weth) {\n        weth = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair = IUniswapV2Factory(_factory).getPair(tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB, ) = IUniswapV2Pair(pair).getReserves();\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForETHToToken(address token)\n        external\n        pure\n        returns (address[] memory)\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "src/swap/sushiswap/SushiSwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary SushiSwapLib {\n    address public constant UNISWAP_ROUTER_ADDRESS =\n        0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function ethQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        (tokenReserve, ethReserve, ) = IUniswapV2Pair(_pair).getReserves();\n        ethereum = quote(tokenAmount, tokenReserve, ethReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WETH() external pure returns (address weth) {\n        weth = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair = IUniswapV2Factory(_factory).getPair(tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB, ) = IUniswapV2Pair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForETHToToken(address token)\n        external\n        pure\n        returns (address[] memory)\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "src/swap/sushiswap/SushiSwapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./SushiSwapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\nimport \"../../access/Controllable.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract SushiSwapQueryHelper is ISwapQueryHelper, Controllable {\n    address private customFactory;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return SushiSwapLib.ethQuote(token, tokenAmount);\n    }\n\n    function __factory() internal view returns (address fac) {\n        fac = customFactory != address(0)\n            ? customFactory\n            : SushiSwapLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external view override returns (address fac) {\n        fac = __factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = SushiSwapLib.WETH();\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        override\n        returns (address pair)\n    {\n        pair = SushiSwapLib.getPair(__factory(), tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = SushiSwapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return SushiSwapLib.hasPool(token);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        return SushiSwapLib.getPathForETHToToken(token);\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address f) external override onlyController {\n        customFactory = f;\n    }\n}\n"
    },
    "src/swap/pangolin/PangolinQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./PangolinLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\nimport \"../../access/Controllable.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract PangolinQueryHelper is ISwapQueryHelper, Controllable {\n    address private _routerAddress;\n\n    address public constant PANGOLIN_ROUTER_ADDRESS =\n        0xefa94DE7a4656D787667C749f7E1223D71E9FD88;\n    address public constant FUJI_PANGOLIN_ROUTER_ADDRESS =\n        0xE4A575550C2b460d2307b82dCd7aFe84AD1484dd;\n\n    constructor() {\n        _routerAddress = PANGOLIN_ROUTER_ADDRESS;\n    }\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return PangolinLib.avaxQuote(token, tokenAmount);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = PangolinLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = PangolinLib.WAVAX();\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return PangolinLib.hasPool(token);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        override\n        returns (address pair)\n    {\n        address _factory = PangolinLib.factory();\n        pair = PangolinLib.getPair(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = PangolinLib.getReserves(pair);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        return PangolinLib.getPathForAVAXoToken(token);\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address) external override {}\n}\n"
    },
    "src/swap/pangolin/PangolinLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\";\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinFactory.sol\";\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinPair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary PangolinLib {\n    address public constant PANGOLIN_ROUTER_ADDRESS =\n        0xefa94DE7a4656D787667C749f7E1223D71E9FD88;\n    address public constant FUJI_PANGOLIN_ROUTER_ADDRESS =\n        0xE4A575550C2b460d2307b82dCd7aFe84AD1484dd;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function avaxQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 avalanche,\n            uint256 tokenReserve,\n            uint256 avaxReserve\n        )\n    {\n        IPangolinRouter uniswapRouter = IPangolinRouter(\n            PANGOLIN_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WAVAX = uniswapRouter.WAVAX();\n        address _pair = IPangolinFactory(_factory).getPair(token, _WAVAX);\n        (tokenReserve, avaxReserve, ) = IPangolinPair(_pair).getReserves();\n        avalanche = quote(tokenAmount, tokenReserve, avaxReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WAVAX() external pure returns (address wavax) {\n        wavax = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS).WAVAX();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IPangolinRouter uniswapRouter = IPangolinRouter(\n            PANGOLIN_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WAVAX = uniswapRouter.WAVAX();\n        address _pair = IPangolinFactory(_factory).getPair(token, _WAVAX);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs wavax\n     */\n    function getPair(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair = IPangolinFactory(_factory).getPair(tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB, ) = IPangolinPair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"40231f6b438bce0797c9ada29b718a87ea0a5cea3fe9a771abdd76bd41a3e545\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for avalanche to the given token\n     */\n    function getPathForAVAXoToken(address token)\n        external\n        pure\n        returns (address[] memory)\n    {\n        IPangolinRouter uniswapRouter = IPangolinRouter(\n            PANGOLIN_ROUTER_ADDRESS\n        );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WAVAX();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IPangolinRouter {\n    function factory() external pure returns (address);\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountAVAX);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPangolinFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinPair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPangolinPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/swap/pancakeswap/PancakeSwapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./PancakeSwapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract PancakeSwapQueryHelper is ISwapQueryHelper {\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return PancakeSwapLib.coinQuote(token, tokenAmount);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = PancakeSwapLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = PancakeSwapLib.COIN();\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return PancakeSwapLib.hasPool(token);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        override\n        returns (address pair)\n    {\n        address _factory = PancakeSwapLib.factory();\n        pair = PancakeSwapLib.getPair(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = PancakeSwapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        return PancakeSwapLib.getPathForCoinToToken(token);\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address) external override {}\n}\n"
    },
    "src/swap/pancakeswap/PancakeSwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol\";\nimport \"@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakeFactory.sol\";\nimport \"@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol\";\n\n/**\n * @dev pancake helpers\n */\nlibrary PancakeSwapLib {\n    address public constant PANCAKE_ROUTER_ADDRESS =\n        0xBCfCcbde45cE874adCB698cC183deBcF17952812;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 coin,\n            uint256 tokenReserve,\n            uint256 coinReserve\n        )\n    {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\n            PANCAKE_ROUTER_ADDRESS\n        );\n        address _factory = pancakeRouter.factory();\n        address _COIN = pancakeRouter.WETH();\n        address _pair = IPancakeFactory(_factory).getPair(token, _COIN);\n        (tokenReserve, coinReserve, ) = IPancakePair(_pair).getReserves();\n        coin = quote(tokenAmount, tokenReserve, coinReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure returns (address wavax) {\n        wavax = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\n            PANCAKE_ROUTER_ADDRESS\n        );\n        address _factory = pancakeRouter.factory();\n        address _WAVAX = pancakeRouter.WETH();\n        address _pair = IPancakeFactory(_factory).getPair(token, _WAVAX);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs wavax\n     */\n    function getPair(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair = IPancakeFactory(_factory).getPair(tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB, ) = IPancakePair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"d0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for coin to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        returns (address[] memory)\n    {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\n            PANCAKE_ROUTER_ADDRESS\n        );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = pancakeRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\nimport './IPancakeRouter01.sol';\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
    },
    "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakeFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "pancakeswap-peripheral/contracts/interfaces/IPancakeRouter01.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n"
    },
    "src/swap/mock/MockQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/ISwapQueryHelper.sol\";\n\n/**\n * @dev Mock helper for local network\n */\ncontract MockQueryHelper is ISwapQueryHelper {\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address, uint256 tokenAmount)\n        external\n        pure\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return (tokenAmount / (10), tokenAmount * (200), tokenAmount * (20));\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = address(0);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = address(99);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address, address)\n        external\n        pure\n        override\n        returns (address pair)\n    {\n        pair = address(0);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address)\n        external\n        pure\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = (0, 0);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address) external pure override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        address[] memory _mock;\n        return _mock;\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address) external override {}\n}\n"
    },
    "src/interfaces/ISwapMeetV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libs/UInt256Set.sol\";\n\ninterface ISwapMeetV2 {\n    struct Bid {\n        uint256 offerId;\n        address bidder;\n        uint256 amount;\n    }\n\n    // an offer to swap a gem for some number of other gems\n    struct Offer {\n        address owner;\n        address pool;\n        uint256 gem;\n        address[] pools;\n        uint256[] gems;\n        uint256[] quantities;\n        uint256 listingFee;\n        uint256 acceptFee;\n        uint256 references;\n        bool missingTokenPenalty;\n        uint256 blockCount;\n        bool wethOnly;\n        bool collectPayment;\n        address winner;\n        uint256 winningBidAmount;\n    }\n\n    // an offer is registered with the swap\n    event OfferRegistered(\n        address _from,\n        uint256 _offerId,\n        address _pool,\n        uint256 _gem,\n        address[] _pools,\n        uint256[] _gems,\n        uint256[] _quantities,\n        uint256 _references,\n        uint256 _listingFee,\n        uint256 _blockCount\n    );\n\n    // an offer is cancelled\n    event OfferUnregistered(uint256 _offerId);\n\n    // an offer is aacepted\n    event OfferAccepted(\n        uint256 _offerId,\n        address _offerPool,\n        uint256 _offerItem,\n        address _acceptor,\n        uint256[] _gems,\n        uint256 _acceptFee\n    );\n\n    // bid is created\n    event BidCreated(uint256 _itemId, address _bidder, uint256 _amount);\n\n    // bid is created\n    event AuctionClosed(\n        uint256 _itemId,\n        address _winner,\n        uint256 _amount,\n        uint256 _blockClosed\n    );\n\n    // bid is created\n    event AuctionCompleted(\n        uint256 _itemId,\n        address _winner,\n        uint256 _amount,\n        uint256 _blockClosed\n    );\n\n    // an offer is cancelled\n    event SwapMeetFeesWithdrawn(address _recipient, uint256 _feesAmount);\n\n    // when the meet is opened and closed. closed means\n    // the meet is no longer accepting offers\n    event SwapMeetIsOpen(bool openState);\n\n    // registe a new offer\n    function registerOffer(\n        // what to have to swap\n        address _pool,\n        uint256 _gem,\n        // what you are willing to swap it for\n        address[] calldata _pools,\n        uint256[] calldata _gems,\n        uint256[] calldata _quantities,\n        uint256 references,\n        uint256 _blockCount,\n        bool _wethOnly\n    ) external payable returns (uint256 _offerId, Offer memory _offer);\n\n    // unregister an offer\n    function unregisterOffer(uint256 _id) external returns (bool);\n\n    // is an active offer\n    function isOffer(uint256 _id) external view returns (bool);\n\n    // list all offers\n    function listOffers() external view returns (Offer[] memory);\n\n    // list all offer ids\n    function listOfferIds() external view returns (uint256[] memory);\n\n    // list all offers\n    function listOffersByOwner(address ownerAddress)\n        external\n        view\n        returns (Offer[] memory);\n\n    // get details of an offer\n    function getOffer(uint256 _id) external view returns (Offer memory);\n\n    // get bids of an offer\n    function getOfferBids(uint256 _id) external view returns (Bid[] memory);\n\n    // create a bid\n    function createBid(\n        uint256 _id,\n        uint256 _amount,\n        bool useWeth\n    ) external payable returns (bool);\n\n    // accept an offer\n    function acceptOffer(uint256 _id, uint256[] memory)\n        external\n        payable\n        returns (bool);\n\n    // withdraw the swap meet fees\n    function withdrawFees(address _receiver) external;\n\n    // set the open state of the swap\n    function setOpenState(bool openState) external;\n\n    // is the swap open\n    function isOpen() external view returns (bool);\n\n    // is the swap offer an auction?\n    function isAuction(uint256 _id) external view returns (bool);\n\n    // set the open state of the swap\n    function closeAuction(uint256 _id) external returns (bool);\n\n    function completeAuction(uint256 _id) external payable returns (bool);\n\n    // nigrate the swap meet to another version\n    // function migrate(address _newSwap) external;\n\n    // function initialize(\n    //     bool _open,\n    //     address _feeManager,\n    //     address _multitoken,\n    //     mapping(uint256 => Offer) memory _offers,\n    //     mapping(address => Offer[]) memory _offersByOwner,\n    //     UInt256Set.Set memory _offerIds,\n    //     mapping(address => address) memory _proxyList\n    // ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2222
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}