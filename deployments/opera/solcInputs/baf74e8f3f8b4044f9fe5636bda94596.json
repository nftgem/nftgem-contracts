{
  "language": "Solidity",
  "sources": {
    "src/access/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IControllable.sol\";\n\nabstract contract Controllable is IControllable {\n    mapping(address => bool) internal _controllers;\n\n    /**\n     * @dev Throws if called by any account not in authorized list\n     */\n    modifier onlyController() {\n        require(\n            _controllers[msg.sender] == true || address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Add an address allowed to control this contract\n     */\n    function _addController(address _controller) internal {\n        _controllers[_controller] = true;\n    }\n\n    /**\n     * @dev Add an address allowed to control this contract\n     */\n    function addController(address _controller)\n        external\n        override\n        onlyController\n    {\n        _controllers[_controller] = true;\n    }\n\n    /**\n     * @dev Check if this address is a controller\n     */\n    function isController(address _address)\n        external\n        view\n        override\n        returns (bool allowed)\n    {\n        allowed = _controllers[_address];\n    }\n\n    /**\n     * @dev Remove the sender address from the list of controllers\n     */\n    function relinquishControl() external override onlyController {\n        delete _controllers[msg.sender];\n    }\n}\n"
    },
    "src/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IControllable {\n    event ControllerAdded(\n        address indexed contractAddress,\n        address indexed controllerAddress\n    );\n    event ControllerRemoved(\n        address indexed contractAddress,\n        address indexed controllerAddress\n    );\n\n    function addController(address controller) external;\n\n    function isController(address controller) external view returns (bool);\n\n    function relinquishControl() external;\n}\n"
    },
    "src/utils/BulkTokenSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/IBulkTokenSender.sol\";\n\n/**\n * @dev Collection of utility functions that mint tokens\n */\ncontract BulkTokenSender is IBulkTokenSender, Controllable {\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    function bulkSend(\n        address tokenAddress,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external override onlyController {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            IERC20(tokenAddress).transferFrom(\n                address(this),\n                recipients[i],\n                gquantities[i]\n            );\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/interfaces/INFTGemMultiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface INFTGemMultiToken {\n    enum TokenType {\n        GOVERNANCE,\n        CLAIM,\n        GEM\n    }\n\n    // called by controller to mint a claim or a gem\n    function mint(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external;\n\n    // called by controller to mint a claim or a gem\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external;\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external;\n\n    // called by controller to burn a claim\n    function burn(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external;\n\n    function heldTokens(address holder)\n        external\n        view\n        returns (uint256[] memory);\n\n    function allHeldTokens(address holder, uint256 _idx)\n        external\n        view\n        returns (uint256);\n\n    function allHeldTokensLength(address holder)\n        external\n        view\n        returns (uint256);\n\n    function tokenHolders(uint256 _token)\n        external\n        view\n        returns (address[] memory);\n\n    function allTokenHolders(uint256 _token, uint256 _idx)\n        external\n        view\n        returns (address);\n\n    function allTokenHoldersLength(uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function totalBalances(uint256 _id) external view returns (uint256);\n\n    function allProxyRegistries(uint256 _idx) external view returns (address);\n\n    function allProxyRegistriesLength() external view returns (uint256);\n\n    function addProxyRegistry(address registry) external;\n\n    function removeProxyRegistryAt(uint256 index) external;\n\n    function getRegistryManager() external view returns (address);\n\n    function setRegistryManager(address newManager) external;\n\n    function lock(uint256 token, uint256 timeframe) external;\n\n    function unlockTime(address account, uint256 token)\n        external\n        view\n        returns (uint256);\n\n    function setTokenData(\n        uint256 tokenHash,\n        TokenType tokenType,\n        address tokenPool\n    ) external;\n\n    function getTokenData(uint256 tokenHash)\n        external\n        view\n        returns (TokenType, address);\n}\n"
    },
    "src/interfaces/IBulkTokenSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IBulkTokenSender {\n    function bulkSend(\n        address tokenAddress,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external;\n}\n"
    },
    "src/utils/BulkTokenMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/IBulkTokenMinter.sol\";\n\n/**\n * @dev Collection of utility functions that mint tokens\n */\ncontract BulkTokenMinter is IBulkTokenMinter, Controllable {\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /**\n     * @dev Mint one token hash type to multiple accounts with multiple quantities\n     */\n    function bulkMintToken(\n        address multitoken,\n        address[] memory recipients,\n        uint256 tokenHash,\n        uint256[] memory quantities\n    ) external override onlyController {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            INFTGemMultiToken(multitoken).mint(\n                recipients[i],\n                tokenHash,\n                quantities[i]\n            );\n        }\n    }\n\n    /**\n     * @dev Mint governance to recipients\n     */\n    function bulkMintGov(\n        address multitoken,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external override onlyController {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            INFTGemMultiToken(multitoken).mint(\n                recipients[i],\n                0,\n                gquantities[i]\n            );\n        }\n    }\n}\n"
    },
    "src/interfaces/IBulkTokenMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IBulkTokenMinter {\n    function bulkMintGov(\n        address multitoken,\n        address[] memory recipients,\n        uint256[] memory gquantities\n    ) external;\n\n    function bulkMintToken(\n        address multitoken,\n        address[] memory recipients,\n        uint256 tokenHash,\n        uint256[] memory quantities\n    ) external;\n}\n"
    },
    "src/tokens/NFTGemMultiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport \"../libs/Strings.sol\";\nimport \"../libs/AddressSet.sol\";\nimport \"../libs/UInt256Set.sol\";\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\n\n/**\n * @dev ProxyContract placeholder - the proxy delegate\n */\ncontract OwnableDelegateProxy {\n\n}\n\n/**\n * @dev a registry of proxies\n */\ncontract ProxyRegistry {\n    mapping(address => OwnableDelegateProxy) public proxies;\n}\n\n/**\n * @dev a mock object for testing\n */\ncontract MockProxyRegistry {\n    function proxies(address input) external pure returns (address) {\n        return input;\n    }\n}\n\n/**\n * @dev the primary multitoken contract\n */\ncontract NFTGemMultiToken is\n    ERC1155Pausable,\n    ERC1155Holder,\n    INFTGemMultiToken,\n    Controllable\n{\n    using AddressSet for AddressSet.Set;\n    using UInt256Set for UInt256Set.Set;\n\n    using Strings for string;\n\n    // proxy registries for exchanges to enable no-fee trading\n    AddressSet.Set private proxyRegistries;\n    address private registryManager;\n\n    // total balance per token id\n    mapping(uint256 => uint256) private _totalBalances;\n    // time-locked tokens\n    mapping(address => mapping(uint256 => uint256)) private _tokenLocks;\n\n    // lists of held tokens by user\n    mapping(address => UInt256Set.Set) private _heldTokens;\n    // list of token holders\n    mapping(uint256 => AddressSet.Set) private _tokenHolders;\n\n    // token types and token pool addresses, to link the multitoken to the tokens created on it\n    mapping(uint256 => INFTGemMultiToken.TokenType) private _tokenTypes;\n    mapping(uint256 => address) private _tokenPools;\n\n    /**\n     * @dev Contract initializer.\n     */\n    constructor() ERC1155(\"https://metadata.nftgem.host/\") {\n        _addController(msg.sender);\n        registryManager = msg.sender;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155, ERC1155Receiver)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev timelock the tokens from moving until the given time\n     */\n    function lock(uint256 token, uint256 timestamp) external override {\n        require(_tokenLocks[_msgSender()][token] < timestamp, \"ALREADY_LOCKED\");\n        _tokenLocks[_msgSender()][token] = timestamp;\n    }\n\n    /**\n     * @dev unlock time for token / id\n     */\n    function unlockTime(address account, uint256 token)\n        external\n        view\n        override\n        returns (uint256 theTime)\n    {\n        theTime = _tokenLocks[account][token];\n    }\n\n    /**\n     * @dev Returns the metadata URI for this token type\n     */\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155)\n        returns (string memory)\n    {\n        // the URI override is here to support IPFS addresses - we need to do the\n        // id concat here because IPFS can't do it. This makes this call take a little\n        // longer but the advantage is that the call returns an already-formed URI\n        require(\n            _totalBalances[_id] != 0,\n            \"NFTGemMultiToken#uri: NONEXISTENT_TOKEN\"\n        );\n        return\n            Strings.strConcat(\n                ERC1155Pausable(this).uri(_id),\n                Strings.uint2str(_id)\n            );\n    }\n\n    /**\n     * @dev returns an array of held tokens for the token holder\n     */\n    function heldTokens(address holder)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _heldTokens[holder].keyList;\n    }\n\n    /**\n     * @dev held token at index for token holder\n     */\n    function allHeldTokens(address holder, uint256 _idx)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _heldTokens[holder].keyList[_idx];\n    }\n\n    /**\n     * @dev Returns the count of held tokens for the token holder\n     */\n    function allHeldTokensLength(address holder)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _heldTokens[holder].keyList.length;\n    }\n\n    /**\n     * @dev Returns an array of token holders for the given token id\n     */\n    function tokenHolders(uint256 _token)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return _tokenHolders[_token].keyList;\n    }\n\n    /**\n     * @dev  token holder at index for token id\n     */\n    function allTokenHolders(uint256 _token, uint256 _idx)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _tokenHolders[_token].keyList[_idx];\n    }\n\n    /**\n     * @dev Returns the count of token holders for the held token\n     */\n    function allTokenHoldersLength(uint256 _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _tokenHolders[_token].keyList.length;\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function totalBalances(uint256 _id)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _totalBalances[_id];\n    }\n\n    /**\n     * @dev Returns proxy registry at index\n     */\n    function allProxyRegistries(uint256 _idx)\n        external\n        view\n        override\n        returns (address)\n    {\n        return proxyRegistries.keyList[_idx];\n    }\n\n    /**\n     * @dev Returns the registyry manager account\n     */\n    function getRegistryManager() external view override returns (address) {\n        return registryManager;\n    }\n\n    /**\n     * @dev set the registry manager account\n     */\n    function setRegistryManager(address newManager) external override {\n        require(msg.sender == registryManager, \"UNAUTHORIZED\");\n        require(newManager != address(0), \"UNAUTHORIZED\");\n        registryManager = newManager;\n    }\n\n    /**\n     * @dev a count of proxy registries\n     */\n    function allProxyRegistriesLength()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return proxyRegistries.keyList.length;\n    }\n\n    /**\n     * @dev add a proxy registry to the list\n     */\n    function addProxyRegistry(address registry) external override {\n        require(\n            msg.sender == registryManager || _controllers[msg.sender] == true,\n            \"UNAUTHORIZED\"\n        );\n        proxyRegistries.insert(registry);\n    }\n\n    /**\n     * @dev remove the proxy registry from the list at index\n     */\n    function removeProxyRegistryAt(uint256 index) external override {\n        require(\n            msg.sender == registryManager || _controllers[msg.sender] == true,\n            \"UNAUTHORIZED\"\n        );\n        require(index < proxyRegistries.keyList.length, \"INVALID_INDEX\");\n        proxyRegistries.remove(proxyRegistries.keyList[index]);\n    }\n\n    /**\n     * @dev override base functionality to check proxy registries for approvers\n     */\n    function isApprovedForAll(address _owner, address _operator)\n        public\n        view\n        override\n        returns (bool isOperator)\n    {\n        // Whitelist OpenSea proxy contract for easy trading.\n        for (uint256 i = 0; i < proxyRegistries.keyList.length; i++) {\n            ProxyRegistry proxyRegistry = ProxyRegistry(\n                proxyRegistries.keyList[i]\n            );\n            try proxyRegistry.proxies(_owner) returns (\n                OwnableDelegateProxy thePr\n            ) {\n                if (address(thePr) == _operator) {\n                    return true;\n                }\n            } catch {}\n        }\n        return ERC1155.isApprovedForAll(_owner, _operator);\n    }\n\n    /**\n     * @dev mint some amount of tokens. Only callable by token owner\n     */\n    function mint(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external override onlyController {\n        _mint(account, uint256(tokenHash), amount, \"0x0\");\n    }\n\n    /**\n     * @dev mint some amount of tokens to multiple recipients. Only callable by token owner\n     */\n\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external override onlyController {\n        _mintBatch(to, ids, amounts, \"0x0\");\n    }\n\n    /**\n     * @dev burn some amount of tokens of multiple token types of account. Only callable by token owner\n     */\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external override onlyController {\n        _burnBatch(account, ids, amounts);\n    }\n\n    /**\n     * @dev set the data for this tokenhash. points to a token type (1 = claim, 2 = gem) and token pool address\n     */\n    function setTokenData(\n        uint256 tokenHash,\n        INFTGemMultiToken.TokenType tokenType,\n        address tokenPool\n    ) external override onlyController {\n        _tokenTypes[tokenHash] = tokenType;\n        _tokenPools[tokenHash] = tokenPool;\n    }\n\n    /**\n     * @dev get the token data for this token tokenhash\n     */\n    function getTokenData(uint256 tokenHash)\n        external\n        view\n        override\n        returns (INFTGemMultiToken.TokenType tokenType, address tokenPool)\n    {\n        tokenType = _tokenTypes[tokenHash];\n        tokenPool = _tokenPools[tokenHash];\n    }\n\n    /**\n     * @dev internal mint overridden to manage token holders and held tokens lists\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n    }\n\n    /**\n     * @dev internal minttbatch should account for managing lists\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n    }\n\n    /**\n     * @dev burn some amount of tokens. Only callable by token owner\n     */\n    function burn(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external override onlyController {\n        _burn(account, uint256(tokenHash), amount);\n    }\n\n    /**\n     * @dev internal burn overridden to track lists\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual override {\n        super._burn(account, id, amount);\n    }\n\n    /**\n     * @dev internal burnBatch should account for managing lists\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual override {\n        super._burnBatch(account, ids, amounts);\n    }\n\n    /**\n     * @dev we override this method in order to manager the token holder and held token lists\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            // prevent send if tokens are locked\n            if (from != address(0)) {\n                require(\n                    _tokenLocks[from][ids[i]] <= block.timestamp,\n                    \"TOKEN_LOCKED\"\n                );\n            }\n\n            // if this is not a mint then remove the held token id from lists if\n            // this is the last token if this type the sender owns\n            if (from != address(0) && balanceOf(from, ids[i]) == amounts[i]) {\n                // find and delete the token id from the token holders held tokens\n                _heldTokens[from].remove(ids[i]);\n                _tokenHolders[ids[i]].remove(from);\n            }\n\n            // if this is not a burn and receiver does not yet own token then\n            // add that account to the token for that id\n            if (to != address(0) && balanceOf(to, ids[i]) == 0) {\n                // insert the token id from the token holders held tokens\\\n                _heldTokens[to].insert(ids[i]);\n                _tokenHolders[ids[i]].insert(to);\n            }\n\n            // inc and dec balances for each token type\n            if (from == address(0)) {\n                _totalBalances[uint256(ids[i])] =\n                    _totalBalances[uint256(ids[i])] +\n                    (amounts[i]);\n            }\n            if (to == address(0)) {\n                _totalBalances[uint256(ids[i])] =\n                    _totalBalances[uint256(ids[i])] -\n                    (amounts[i]);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "src/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary Strings {\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d,\n        string memory _e\n    ) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(\n            _ba.length + _bb.length + _bc.length + _bd.length + _be.length\n        );\n        bytes memory babcde = bytes(abcde);\n        uint256 k = 0;\n        for (uint256 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (uint256 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (uint256 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (uint256 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (uint256 i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b)\n        internal\n        pure\n        returns (string memory)\n    {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function uint2str(uint256 _i)\n        internal\n        pure\n        returns (string memory _uintAsString)\n    {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "src/libs/AddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary AddressSet {\n    struct Set {\n        mapping(address => uint256) keyPointers;\n        address[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, address key) internal {\n        require(\n            !exists(self, key),\n            \"AddressSet: key already exists in the set.\"\n        );\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, address key) internal {\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\n        // require(\n        //     exists(self, key),\n        //     \"AddressSet: key does not exist in the set.\"\n        // );\n        if (!exists(self, key)) return;\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            address keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        delete self.keyList[self.keyList.length - 1];\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) internal view returns (uint256) {\n        return (self.keyList.length);\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, address key)\n        internal\n        view\n        returns (bool)\n    {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index)\n        internal\n        view\n        returns (address)\n    {\n        return self.keyList[index];\n    }\n}\n"
    },
    "src/libs/UInt256Set.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary UInt256Set {\n    struct Set {\n        mapping(uint256 => uint256) keyPointers;\n        uint256[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, uint256 key) internal {\n        require(\n            !exists(self, key),\n            \"UInt256Set: key already exists in the set.\"\n        );\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, uint256 key) internal {\n        // TODO: I commented this out do get a test to pass - need to figure out what is up here\n        // require(\n        //     exists(self, key),\n        //     \"UInt256Set: key does not exist in the set.\"\n        // );\n        if (!exists(self, key)) return;\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            uint256 keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        delete self.keyList[self.keyList.length - 1];\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) internal view returns (uint256) {\n        return (self.keyList.length);\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, uint256 key)\n        internal\n        view\n        returns (bool)\n    {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index)\n        internal\n        view\n        returns (uint256)\n    {\n        return self.keyList[index];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][account] = accountBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "src/pool/ComplexPoolLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\nimport \"../interfaces/ISwapQueryHelper.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/INFTComplexGemPool.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\nimport \"../libs/AddressSet.sol\";\n\nlibrary ComplexPoolLib {\n    using AddressSet for AddressSet.Set;\n\n    /**\n     * @dev Event generated when an NFT claim is created using base currency\n     */\n    event NFTGemClaimCreated(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 length,\n        uint256 quantity,\n        uint256 amountPaid\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is created using ERC20 tokens\n     */\n    event NFTGemERC20ClaimCreated(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 length,\n        address token,\n        uint256 quantity,\n        uint256 conversionRate\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is redeemed\n     */\n    event NFTGemClaimRedeemed(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 amountPaid,\n        uint256 quantity,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when an NFT erc20 claim is redeemed\n     */\n    event NFTGemERC20ClaimRedeemed(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        address token,\n        uint256 ethPrice,\n        uint256 tokenAmount,\n        uint256 quantity,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when a gem is created\n     */\n    event NFTGemCreated(\n        address account,\n        address pool,\n        uint256 claimHash,\n        uint256 gemHash,\n        uint256 quantity\n    );\n\n    /**\n     * @dev data describes complex pool\n     */\n    struct ComplexPoolData {\n        // governor and multitoken target\n        address pool;\n        address multitoken;\n        address governor;\n        address feeTracker;\n        address swapHelper;\n        uint256 category;\n        bool visible;\n        // it all starts with a symbol and a nams\n        string symbol;\n        string name;\n        string description;\n        // magic economy numbers\n        uint256 ethPrice;\n        uint256 minTime;\n        uint256 maxTime;\n        uint256 diffstep;\n        uint256 maxClaims;\n        uint256 maxQuantityPerClaim;\n        uint256 maxClaimsPerAccount;\n        bool validateerc20;\n        bool allowPurchase;\n        bool enabled;\n        INFTComplexGemPoolData.PriceIncrementType priceIncrementType;\n        mapping(uint256 => INFTGemMultiToken.TokenType) tokenTypes;\n        mapping(uint256 => uint256) tokenIds;\n        mapping(uint256 => address) tokenSources;\n        AddressSet.Set allowedTokenSources;\n        uint256[] tokenHashes;\n        // next ids of things\n        uint256 nextGemIdVal;\n        uint256 nextClaimIdVal;\n        uint256 totalStakedEth;\n        // records claim timestamp / ETH value / ERC token and amount sent\n        mapping(uint256 => uint256) claimLockTimestamps;\n        mapping(uint256 => address) claimLockToken;\n        mapping(uint256 => uint256) claimAmountPaid;\n        mapping(uint256 => uint256) claimQuant;\n        mapping(uint256 => uint256) claimTokenAmountPaid;\n        mapping(uint256 => bool) importedLegacyToken;\n        // input NFTs storage\n        mapping(uint256 => uint256) gemClaims;\n        mapping(uint256 => uint256[]) claimIds;\n        mapping(uint256 => uint256[]) claimQuantities;\n        mapping(address => bool) controllers;\n        mapping(address => uint256) claimsMade;\n        INFTComplexGemPoolData.InputRequirement[] inputRequirements;\n        AddressSet.Set allowedTokens;\n    }\n\n    function checkGemRequirement(\n        ComplexPoolData storage self,\n        uint256 _inputIndex,\n        address _holderAddress,\n        uint256 _quantity\n    ) internal view returns (address) {\n        address gemtoken;\n        int256 required = int256(\n            self.inputRequirements[_inputIndex].minVal * _quantity\n        );\n        uint256[] memory hashes = INFTGemMultiToken(\n            self.inputRequirements[_inputIndex].token\n        ).heldTokens(_holderAddress);\n        for (\n            uint256 _hashIndex = 0;\n            _hashIndex < hashes.length;\n            _hashIndex += 1\n        ) {\n            uint256 hashAt = hashes[_hashIndex];\n            if (\n                INFTComplexGemPoolData(self.inputRequirements[_inputIndex].pool)\n                .tokenType(hashAt) == INFTGemMultiToken.TokenType.GEM\n            ) {\n                gemtoken = self.inputRequirements[_inputIndex].token;\n                uint256 balance = IERC1155(\n                    self.inputRequirements[_inputIndex].token\n                ).balanceOf(_holderAddress, hashAt);\n                if (balance > uint256(required)) {\n                    balance = uint256(required);\n                }\n                if (balance == 0) {\n                    continue;\n                }\n                required = required - int256(balance);\n            }\n            if (\n                required == 0 &&\n                self.inputRequirements[_inputIndex].exactAmount == false\n            ) {\n                break;\n            }\n            if (required < 0) {\n                require(required == 0, \"EXACT_AMOUNT_REQUIRED\");\n            }\n        }\n        require(required == 0, \"UNMET_GEM_REQUIREMENT\");\n        return gemtoken;\n    }\n\n    /**\n     * @dev checks to see that account owns all the pool requirements needed to mint at least the given quantity of NFT\n     */\n    function requireInputReqs(\n        ComplexPoolData storage self,\n        address _holderAddress,\n        uint256 _quantity\n    ) public view {\n        for (\n            uint256 _inputIndex = 0;\n            _inputIndex < self.inputRequirements.length;\n            _inputIndex += 1\n        ) {\n            if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.ERC20\n            ) {\n                require(\n                    IERC20(self.inputRequirements[_inputIndex].token).balanceOf(\n                        _holderAddress\n                    ) >=\n                        self.inputRequirements[_inputIndex].minVal *\n                            (_quantity),\n                    \"UNMET_ERC20_REQUIREMENT\"\n                );\n            } else if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.ERC1155\n            ) {\n                require(\n                    IERC1155(self.inputRequirements[_inputIndex].token)\n                    .balanceOf(\n                        _holderAddress,\n                        self.inputRequirements[_inputIndex].tokenId\n                    ) >=\n                        self.inputRequirements[_inputIndex].minVal *\n                            (_quantity),\n                    \"UNMET_ERC1155_REQUIREMENT\"\n                );\n            } else if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.POOL\n            ) {\n                checkGemRequirement(\n                    self,\n                    _inputIndex,\n                    _holderAddress,\n                    _quantity\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Transfer a quantity of input reqs from to\n     */\n    function takeInputReqsFrom(\n        ComplexPoolData storage self,\n        uint256 _claimHash,\n        address _fromAddress,\n        uint256 _quantity\n    ) internal {\n        address gemtoken;\n        for (\n            uint256 _inputIndex = 0;\n            _inputIndex < self.inputRequirements.length;\n            _inputIndex += 1\n        ) {\n            if (!self.inputRequirements[_inputIndex].takeCustody) {\n                continue;\n            }\n            if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.ERC20\n            ) {\n                IERC20 token = IERC20(\n                    self.inputRequirements[_inputIndex].token\n                );\n                token.transferFrom(\n                    _fromAddress,\n                    self.pool,\n                    self.inputRequirements[_inputIndex].minVal * (_quantity)\n                );\n            } else if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.ERC1155\n            ) {\n                IERC1155 token = IERC1155(\n                    self.inputRequirements[_inputIndex].token\n                );\n                token.safeTransferFrom(\n                    _fromAddress,\n                    self.pool,\n                    self.inputRequirements[_inputIndex].tokenId,\n                    self.inputRequirements[_inputIndex].minVal * (_quantity),\n                    \"\"\n                );\n            } else if (\n                self.inputRequirements[_inputIndex].inputType ==\n                INFTComplexGemPool.RequirementType.POOL\n            ) {\n                gemtoken = checkGemRequirement(\n                    self,\n                    _inputIndex,\n                    _fromAddress,\n                    _quantity\n                );\n            }\n        }\n\n        if (self.claimIds[_claimHash].length > 0 && gemtoken != address(0)) {\n            IERC1155(gemtoken).safeBatchTransferFrom(\n                _fromAddress,\n                self.pool,\n                self.claimIds[_claimHash],\n                self.claimQuantities[_claimHash],\n                \"\"\n            );\n        }\n    }\n\n    /**\n     * @dev Return the returnable input requirements for claimhash to account\n     */\n    function returnInputReqsTo(\n        ComplexPoolData storage self,\n        uint256 _claimHash,\n        address _toAddress,\n        uint256 _quantity\n    ) internal {\n        address gemtoken;\n        for (uint256 i = 0; i < self.inputRequirements.length; i++) {\n            if (\n                self.inputRequirements[i].inputType ==\n                INFTComplexGemPool.RequirementType.ERC20 &&\n                self.inputRequirements[i].burn == false &&\n                self.inputRequirements[i].takeCustody == true\n            ) {\n                IERC20 token = IERC20(self.inputRequirements[i].token);\n                token.transferFrom(\n                    self.pool,\n                    _toAddress,\n                    self.inputRequirements[i].minVal * (_quantity)\n                );\n            } else if (\n                self.inputRequirements[i].inputType ==\n                INFTComplexGemPool.RequirementType.ERC1155 &&\n                self.inputRequirements[i].burn == false &&\n                self.inputRequirements[i].takeCustody == true\n            ) {\n                IERC1155 token = IERC1155(self.inputRequirements[i].token);\n                token.safeTransferFrom(\n                    self.pool,\n                    _toAddress,\n                    self.inputRequirements[i].tokenId,\n                    self.inputRequirements[i].minVal * (_quantity),\n                    \"\"\n                );\n            } else if (\n                self.inputRequirements[i].inputType ==\n                INFTComplexGemPool.RequirementType.POOL &&\n                self.inputRequirements[i].burn == false &&\n                self.inputRequirements[i].takeCustody == true\n            ) {\n                gemtoken = self.inputRequirements[i].token;\n            }\n        }\n        if (self.claimIds[_claimHash].length > 0 && gemtoken != address(0)) {\n            IERC1155(gemtoken).safeBatchTransferFrom(\n                self.pool,\n                _toAddress,\n                self.claimIds[_claimHash],\n                self.claimQuantities[_claimHash],\n                \"\"\n            );\n        }\n    }\n\n    /**\n     * @dev add an input requirement for this token\n     */\n    function addInputRequirement(\n        ComplexPoolData storage self,\n        address token,\n        address pool,\n        INFTComplexGemPool.RequirementType inputType,\n        uint256 tokenId,\n        uint256 minAmount,\n        bool takeCustody,\n        bool burn,\n        bool exactAmount\n    ) public {\n        require(token != address(0), \"INVALID_TOKEN\");\n        require(\n            inputType == INFTComplexGemPool.RequirementType.ERC20 ||\n                inputType == INFTComplexGemPool.RequirementType.ERC1155 ||\n                inputType == INFTComplexGemPool.RequirementType.POOL,\n            \"INVALID_INPUTTYPE\"\n        );\n        require(\n            (inputType == INFTComplexGemPool.RequirementType.POOL &&\n                pool != address(0)) ||\n                inputType != INFTComplexGemPool.RequirementType.POOL,\n            \"INVALID_POOL\"\n        );\n        require(\n            (inputType == INFTComplexGemPool.RequirementType.ERC20 &&\n                tokenId == 0) ||\n                inputType == INFTComplexGemPool.RequirementType.ERC1155 ||\n                (inputType == INFTComplexGemPool.RequirementType.POOL &&\n                    tokenId == 0),\n            \"INVALID_TOKENID\"\n        );\n        require(minAmount != 0, \"ZERO_AMOUNT\");\n        require(!(!takeCustody && burn), \"INVALID_TOKENSTATE\");\n        self.inputRequirements.push(\n            INFTComplexGemPoolData.InputRequirement(\n                token,\n                pool,\n                inputType,\n                tokenId,\n                minAmount,\n                takeCustody,\n                burn,\n                exactAmount\n            )\n        );\n    }\n\n    /**\n     * @dev update input requirement at index\n     */\n    function updateInputRequirement(\n        ComplexPoolData storage self,\n        uint256 _index,\n        address _tokenAddress,\n        address _poolAddress,\n        INFTComplexGemPool.RequirementType _inputRequirementType,\n        uint256 _tokenId,\n        uint256 _minAmount,\n        bool _takeCustody,\n        bool _burn,\n        bool _exactAmount\n    ) public {\n        require(_index < self.inputRequirements.length, \"OUT_OF_RANGE\");\n        require(_tokenAddress != address(0), \"INVALID_TOKEN\");\n        require(\n            _inputRequirementType == INFTComplexGemPool.RequirementType.ERC20 ||\n                _inputRequirementType ==\n                INFTComplexGemPool.RequirementType.ERC1155 ||\n                _inputRequirementType ==\n                INFTComplexGemPool.RequirementType.POOL,\n            \"INVALID_INPUTTYPE\"\n        );\n        require(\n            (_inputRequirementType == INFTComplexGemPool.RequirementType.POOL &&\n                _poolAddress != address(0)) ||\n                _inputRequirementType !=\n                INFTComplexGemPool.RequirementType.POOL,\n            \"INVALID_POOL\"\n        );\n        require(\n            (_inputRequirementType ==\n                INFTComplexGemPool.RequirementType.ERC20 &&\n                _tokenId == 0) ||\n                _inputRequirementType ==\n                INFTComplexGemPool.RequirementType.ERC1155 ||\n                (_inputRequirementType ==\n                    INFTComplexGemPool.RequirementType.POOL &&\n                    _tokenId == 0),\n            \"INVALID_TOKENID\"\n        );\n        require(_minAmount != 0, \"ZERO_AMOUNT\");\n        require(!(!_takeCustody && _burn), \"INVALID_TOKENSTATE\");\n        self.inputRequirements[_index] = INFTComplexGemPoolData\n        .InputRequirement(\n            _tokenAddress,\n            _poolAddress,\n            _inputRequirementType,\n            _tokenId,\n            _minAmount,\n            _takeCustody,\n            _burn,\n            _exactAmount\n        );\n    }\n\n    /**\n     * @dev count of input requirements\n     */\n    function allInputRequirementsLength(ComplexPoolData storage self)\n        public\n        view\n        returns (uint256)\n    {\n        return self.inputRequirements.length;\n    }\n\n    /**\n     * @dev input requirements at index\n     */\n    function allInputRequirements(ComplexPoolData storage self, uint256 _index)\n        public\n        view\n        returns (\n            address,\n            address,\n            INFTComplexGemPool.RequirementType,\n            uint256,\n            uint256,\n            bool,\n            bool,\n            bool\n        )\n    {\n        require(_index < self.inputRequirements.length, \"OUT_OF_RANGE\");\n        INFTComplexGemPoolData.InputRequirement memory req = self\n        .inputRequirements[_index];\n        return (\n            req.token,\n            req.pool,\n            req.inputType,\n            req.tokenId,\n            req.minVal,\n            req.takeCustody,\n            req.burn,\n            req.exactAmount\n        );\n    }\n\n    /**\n     * @dev attempt to create a claim using the given timeframe with count\n     */\n    function createClaims(\n        ComplexPoolData storage self,\n        uint256 _timeframe,\n        uint256 _count\n    ) public {\n        // enabled\n        require(self.enabled == true, \"DISABLED\");\n        // minimum timeframe\n        require(_timeframe >= self.minTime, \"TIMEFRAME_TOO_SHORT\");\n        // no ETH\n        require(msg.value != 0, \"ZERO_BALANCE\");\n        // zero qty\n        require(_count != 0, \"ZERO_QUANTITY\");\n        // maximum timeframe\n        require(\n            (self.maxTime != 0 && _timeframe <= self.maxTime) ||\n                self.maxTime == 0,\n            \"TIMEFRAME_TOO_LONG\"\n        );\n        // max quantity per claim\n        require(\n            (self.maxQuantityPerClaim != 0 &&\n                _count <= self.maxQuantityPerClaim) ||\n                self.maxQuantityPerClaim == 0,\n            \"MAX_QUANTITY_EXCEEDED\"\n        );\n        require(\n            (self.maxClaimsPerAccount != 0 &&\n                self.claimsMade[msg.sender] < self.maxClaimsPerAccount) ||\n                self.maxClaimsPerAccount == 0,\n            \"MAX_QUANTITY_EXCEEDED\"\n        );\n\n        uint256 adjustedBalance = msg.value / (_count);\n        // cost given this timeframe\n\n        uint256 cost = (self.ethPrice * (self.minTime)) / (_timeframe);\n        require(adjustedBalance >= cost, \"INSUFFICIENT_ETH\");\n\n        // get the nest claim hash, revert if no more claims\n        uint256 claimHash = nextClaimHash(self);\n        require(claimHash != 0, \"NO_MORE_CLAIMABLE\");\n\n        // require the user to have the input requirements\n        requireInputReqs(self, msg.sender, _count);\n\n        // mint the new claim to the caller's address\n        INFTGemMultiToken(self.multitoken).mint(msg.sender, claimHash, 1);\n        INFTGemMultiToken(self.multitoken).setTokenData(\n            claimHash,\n            INFTGemMultiToken.TokenType.CLAIM,\n            address(this)\n        );\n        addToken(self, claimHash, INFTGemMultiToken.TokenType.CLAIM);\n\n        // record the claim unlock time and cost paid for this claim\n        uint256 claimUnlockTimestamp = block.timestamp + (_timeframe);\n        self.claimLockTimestamps[claimHash] = claimUnlockTimestamp;\n        self.claimAmountPaid[claimHash] = cost * (_count);\n        self.claimQuant[claimHash] = _count;\n        self.claimsMade[msg.sender] = self.claimsMade[msg.sender] + (1);\n\n        // tranasfer NFT input requirements from user to pool\n        takeInputReqsFrom(self, claimHash, msg.sender, _count);\n\n        // emit an event about it\n        emit NFTGemClaimCreated(\n            msg.sender,\n            address(self.pool),\n            claimHash,\n            _timeframe,\n            _count,\n            cost\n        );\n\n        // increase the staked eth balance\n        self.totalStakedEth = self.totalStakedEth + (cost * (_count));\n\n        // return the extra to sender\n        if (msg.value > cost * (_count)) {\n            (bool success, ) = payable(msg.sender).call{\n                value: msg.value - (cost * (_count))\n            }(\"\");\n            require(success, \"REFUND_FAILED\");\n        }\n    }\n\n    function getPoolFee(ComplexPoolData storage self, address tokenUsed)\n        internal\n        view\n        returns (uint256)\n    {\n        // get the fee for this pool if it exists\n        uint256 poolDivFeeHash = uint256(\n            keccak256(abi.encodePacked(\"pool_fee\", address(self.pool)))\n        );\n        uint256 poolFee = INFTGemFeeManager(self.feeTracker).fee(\n            poolDivFeeHash\n        );\n        // get the pool fee for this token if it exists\n        uint256 poolTokenFeeHash = uint256(\n            keccak256(abi.encodePacked(\"pool_fee\", address(tokenUsed)))\n        );\n        uint256 poolTokenFee = INFTGemFeeManager(self.feeTracker).fee(\n            poolTokenFeeHash\n        );\n        // get the default fee amoutn for this token\n        uint256 defaultFeeHash = uint256(\n            keccak256(abi.encodePacked(\"pool_fee\"))\n        );\n        uint256 defaultFee = INFTGemFeeManager(self.feeTracker).fee(\n            defaultFeeHash\n        );\n        defaultFee = defaultFee == 0 ? 2000 : defaultFee;\n\n        // get the fee, preferring the token fee if available\n        uint256 feeNum = poolFee != poolTokenFee\n            ? (poolTokenFee != 0 ? poolTokenFee : poolFee)\n            : poolFee;\n\n        // set the fee to default if it is 0\n        return feeNum == 0 ? defaultFee : feeNum;\n    }\n\n    function getMinimumLiquidity(\n        ComplexPoolData storage self,\n        address tokenUsed\n    ) internal view returns (uint256) {\n        // get the fee for this pool if it exists\n        uint256 poolDivFeeHash = uint256(\n            keccak256(abi.encodePacked(\"min_liquidity\", address(self.pool)))\n        );\n        uint256 poolFee = INFTGemFeeManager(self.feeTracker).fee(\n            poolDivFeeHash\n        );\n        // get the pool fee for this token if it exists\n        uint256 poolTokenFeeHash = uint256(\n            keccak256(abi.encodePacked(\"min_liquidity\", address(tokenUsed)))\n        );\n        uint256 poolTokenFee = INFTGemFeeManager(self.feeTracker).fee(\n            poolTokenFeeHash\n        );\n        // get the default fee amoutn for this token\n        uint256 defaultFeeHash = uint256(\n            keccak256(abi.encodePacked(\"min_liquidity\"))\n        );\n        uint256 defaultFee = INFTGemFeeManager(self.feeTracker).fee(\n            defaultFeeHash\n        );\n        defaultFee = defaultFee == 0 ? 50 : defaultFee;\n\n        // get the fee, preferring the token fee if available\n        uint256 feeNum = poolFee != poolTokenFee\n            ? (poolTokenFee != 0 ? poolTokenFee : poolFee)\n            : poolFee;\n\n        // set the fee to default if it is 0\n        return feeNum == 0 ? defaultFee : feeNum;\n    }\n\n    /**\n     * @dev crate multiple gem claim using an erc20 token. this token must be tradeable in Uniswap or this call will fail\n     */\n    function createERC20Claims(\n        ComplexPoolData storage self,\n        address erc20token,\n        uint256 tokenAmount,\n        uint256 count\n    ) public {\n        // enabled\n        require(self.enabled == true, \"DISABLED\");\n        // must be a valid address\n        require(erc20token != address(0), \"INVALID_ERC20_TOKEN\");\n\n        // token is allowed\n        require(\n            (self.allowedTokens.count() > 0 &&\n                self.allowedTokens.exists(erc20token)) ||\n                self.allowedTokens.count() == 0,\n            \"TOKEN_DISALLOWED\"\n        );\n\n        // zero qty\n        require(count != 0, \"ZERO_QUANTITY\");\n\n        // max quantity per claim\n        require(\n            (self.maxQuantityPerClaim != 0 &&\n                count <= self.maxQuantityPerClaim) ||\n                self.maxQuantityPerClaim == 0,\n            \"MAX_QUANTITY_EXCEEDED\"\n        );\n        require(\n            (self.maxClaimsPerAccount != 0 &&\n                self.claimsMade[msg.sender] < self.maxClaimsPerAccount) ||\n                self.maxClaimsPerAccount == 0,\n            \"MAX_QUANTITY_EXCEEDED\"\n        );\n\n        // require the user to have the input requirements\n        requireInputReqs(self, msg.sender, count);\n\n        // Uniswap pool must exist\n        require(\n            ISwapQueryHelper(self.swapHelper).hasPool(erc20token) == true,\n            \"NO_UNISWAP_POOL\"\n        );\n\n        // must have an amount specified\n        require(tokenAmount >= 0, \"NO_PAYMENT_INCLUDED\");\n\n        // get a quote in ETH for the given token.\n        (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        ) = ISwapQueryHelper(self.swapHelper).coinQuote(\n            erc20token,\n            tokenAmount / (count)\n        );\n\n        // TODO: update liquidity multiple from fee manager\n        if (self.validateerc20 == true) {\n            uint256 minLiquidity = getMinimumLiquidity(self, erc20token);\n            // make sure the convertible amount is has reserves > 100x the token\n            require(\n                ethReserve >= ethereum * minLiquidity * (count),\n                \"INSUFFICIENT_ETH_LIQUIDITY\"\n            );\n\n            // make sure the convertible amount is has reserves > 100x the token\n            require(\n                tokenReserve >= tokenAmount * minLiquidity * (count),\n                \"INSUFFICIENT_TOKEN_LIQUIDITY\"\n            );\n        }\n\n        // make sure the convertible amount is less than max price\n        require(ethereum <= self.ethPrice, \"OVERPAYMENT\");\n\n        // calculate the maturity time given the converted eth\n        uint256 maturityTime = (self.ethPrice * (self.minTime)) / (ethereum);\n\n        // make sure the convertible amount is less than max price\n        require(maturityTime >= self.minTime, \"INSUFFICIENT_TIME\");\n\n        // get the next claim hash, revert if no more claims\n        uint256 claimHash = nextClaimHash(self);\n        require(claimHash != 0, \"NO_MORE_CLAIMABLE\");\n\n        // mint the new claim to the caller's address\n        INFTGemMultiToken(self.multitoken).mint(msg.sender, claimHash, 1);\n        INFTGemMultiToken(self.multitoken).setTokenData(\n            claimHash,\n            INFTGemMultiToken.TokenType.CLAIM,\n            address(this)\n        );\n        addToken(self, claimHash, INFTGemMultiToken.TokenType.CLAIM);\n\n        // record the claim unlock time and cost paid for this claim\n        uint256 claimUnlockTimestamp = block.timestamp + (maturityTime);\n        self.claimLockTimestamps[claimHash] = claimUnlockTimestamp;\n        self.claimAmountPaid[claimHash] = ethereum;\n        self.claimLockToken[claimHash] = erc20token;\n        self.claimTokenAmountPaid[claimHash] = tokenAmount;\n        self.claimQuant[claimHash] = count;\n        self.claimsMade[msg.sender] = self.claimsMade[msg.sender] + (1);\n\n        // tranasfer NFT input requirements from user to pool\n        takeInputReqsFrom(self, claimHash, msg.sender, count);\n\n        // increase staked eth amount\n        self.totalStakedEth = self.totalStakedEth + (ethereum);\n\n        // emit a message indicating that an erc20 claim has been created\n        emit NFTGemERC20ClaimCreated(\n            msg.sender,\n            address(self.pool),\n            claimHash,\n            maturityTime,\n            erc20token,\n            count,\n            ethereum\n        );\n\n        // transfer the caller's ERC20 tokens into the pool\n        IERC20(erc20token).transferFrom(\n            msg.sender,\n            address(self.pool),\n            tokenAmount\n        );\n    }\n\n    /**\n     * @dev collect an open claim (take custody of the funds the claim is redeeemable for and maybe a gem too)\n     */\n    function collectClaim(\n        ComplexPoolData storage self,\n        uint256 _claimHash,\n        bool _requireMature\n    ) public {\n        // enabled\n        require(self.enabled == true, \"DISABLED\");\n        // check the maturity of the claim - only issue gem if mature\n        uint256 unlockTime = self.claimLockTimestamps[_claimHash];\n        bool isMature = unlockTime < block.timestamp;\n        require(\n            !_requireMature || (_requireMature && isMature),\n            \"IMMATURE_CLAIM\"\n        );\n        __collectClaim(self, _claimHash);\n    }\n\n    /**\n     * @dev collect an open claim (take custody of the funds the claim is redeeemable for and maybe a gem too)\n     */\n    function __collectClaim(ComplexPoolData storage self, uint256 claimHash)\n        internal\n    {\n        // validation checks - disallow if not owner (holds coin with claimHash)\n        // or if the unlockTime amd unlockPaid data is in an invalid state\n        require(\n            IERC1155(self.multitoken).balanceOf(msg.sender, claimHash) == 1,\n            \"NOT_CLAIM_OWNER\"\n        );\n        uint256 unlockTime = self.claimLockTimestamps[claimHash];\n        uint256 unlockPaid = self.claimAmountPaid[claimHash];\n        require(unlockTime != 0 && unlockPaid > 0, \"INVALID_CLAIM\");\n\n        // grab the erc20 token info if there is any\n        address tokenUsed = self.claimLockToken[claimHash];\n        uint256 unlockTokenPaid = self.claimTokenAmountPaid[claimHash];\n\n        // check the maturity of the claim - only issue gem if mature\n        bool isMature = unlockTime < block.timestamp;\n\n        //  burn claim and transfer money back to user\n        INFTGemMultiToken(self.multitoken).burn(msg.sender, claimHash, 1);\n\n        // if they used erc20 tokens stake their claim, return their tokens\n        if (tokenUsed != address(0)) {\n            // calculate fee portion using fee tracker\n            uint256 feePortion = 0;\n            if (isMature == true) {\n                feePortion = unlockTokenPaid / getPoolFee(self, tokenUsed);\n            }\n            // assess a fee for minting the NFT. Fee is collectec in fee tracker\n            IERC20(tokenUsed).transferFrom(\n                address(self.pool),\n                self.feeTracker,\n                feePortion\n            );\n            // send the principal minus fees to the caller\n            IERC20(tokenUsed).transferFrom(\n                address(self.pool),\n                msg.sender,\n                unlockTokenPaid - (feePortion)\n            );\n\n            // emit an event that the claim was redeemed for ERC20\n            emit NFTGemERC20ClaimRedeemed(\n                msg.sender,\n                address(self.pool),\n                claimHash,\n                tokenUsed,\n                unlockPaid,\n                unlockTokenPaid,\n                self.claimQuant[claimHash],\n                feePortion\n            );\n        } else {\n            // calculate fee portion using fee tracker\n            uint256 feePortion = 0;\n            if (isMature == true) {\n                feePortion = unlockPaid / getPoolFee(self, address(0));\n            }\n            // transfer the ETH fee to fee tracker\n            payable(self.feeTracker).transfer(feePortion);\n\n            // transfer the ETH back to user\n            payable(msg.sender).transfer(unlockPaid - (feePortion));\n\n            // emit an event that the claim was redeemed for ETH\n            emit NFTGemClaimRedeemed(\n                msg.sender,\n                address(self.pool),\n                claimHash,\n                unlockPaid,\n                self.claimQuant[claimHash],\n                feePortion\n            );\n        }\n\n        // tranasfer NFT input requirements from pool to user\n        returnInputReqsTo(\n            self,\n            claimHash,\n            msg.sender,\n            self.claimQuant[claimHash]\n        );\n\n        // deduct the total staked ETH balance of the pool\n        self.totalStakedEth = self.totalStakedEth - (unlockPaid);\n\n        // if all this is happening before the unlocktime then we exit\n        // without minting a gem because the user is withdrawing early\n        if (!isMature) {\n            return;\n        }\n\n        // get the next gem hash, increase the staking sifficulty\n        // for the pool, and mint a gem token back to account\n        uint256 nextHash = nextGemHash(self);\n\n        // associate gem and claim\n        self.gemClaims[nextHash] = claimHash;\n\n        // mint the gem\n        INFTGemMultiToken(self.multitoken).mint(\n            msg.sender,\n            nextHash,\n            self.claimQuant[claimHash]\n        );\n        addToken(self, nextHash, INFTGemMultiToken.TokenType.GEM);\n\n        // emit an event about a gem getting created\n        emit NFTGemCreated(\n            msg.sender,\n            address(self.pool),\n            claimHash,\n            nextHash,\n            self.claimQuant[claimHash]\n        );\n    }\n\n    /**\n     * @dev purchase gem(s) at the listed pool price\n     */\n    function purchaseGems(\n        ComplexPoolData storage self,\n        address sender,\n        uint256 value,\n        uint256 count\n    ) public {\n        // enabled\n        require(self.enabled == true, \"DISABLED\");\n        // non-zero balance\n        require(value != 0, \"ZERO_BALANCE\");\n        // non-zero quantity\n        require(count != 0, \"ZERO_QUANTITY\");\n        // sufficient input eth\n        uint256 adjustedBalance = value / (count);\n        require(adjustedBalance >= self.ethPrice, \"INSUFFICIENT_ETH\");\n        require(self.allowPurchase == true, \"PURCHASE_DISALLOWED\");\n\n        // get the next gem hash, increase the staking sifficulty\n        // for the pool, and mint a gem token back to account\n        uint256 nextHash = nextGemHash(self);\n\n        // mint the gem\n        INFTGemMultiToken(self.multitoken).mint(sender, nextHash, count);\n        addToken(self, nextHash, INFTGemMultiToken.TokenType.GEM);\n\n        // transfer the funds for the gem to the fee tracker\n        payable(self.feeTracker).transfer(value);\n\n        // emit an event about a gem getting created\n        emit NFTGemCreated(sender, address(self.pool), 0, nextHash, count);\n    }\n\n    /**\n     * @dev create a token of token hash / token type\n     */\n    function addToken(\n        ComplexPoolData storage self,\n        uint256 tokenHash,\n        INFTGemMultiToken.TokenType tokenType\n    ) public {\n        require(\n            tokenType == INFTGemMultiToken.TokenType.CLAIM ||\n                tokenType == INFTGemMultiToken.TokenType.GEM,\n            \"INVALID_TOKENTYPE\"\n        );\n        self.tokenHashes.push(tokenHash);\n        self.tokenTypes[tokenHash] = tokenType;\n        self.tokenIds[tokenHash] = tokenType ==\n            INFTGemMultiToken.TokenType.CLAIM\n            ? nextClaimId(self)\n            : nextGemId(self);\n        INFTGemMultiToken(self.multitoken).setTokenData(\n            tokenHash,\n            tokenType,\n            address(this)\n        );\n        if (tokenType == INFTGemMultiToken.TokenType.GEM) {\n            increaseDifficulty(self);\n        }\n    }\n\n    /**\n     * @dev get the next claim id\n     */\n    function nextClaimId(ComplexPoolData storage self)\n        public\n        returns (uint256)\n    {\n        uint256 ncId = self.nextClaimIdVal;\n        self.nextClaimIdVal = self.nextClaimIdVal + (1);\n        return ncId;\n    }\n\n    /**\n     * @dev get the next gem id\n     */\n    function nextGemId(ComplexPoolData storage self) public returns (uint256) {\n        uint256 ncId = self.nextGemIdVal;\n        self.nextGemIdVal = self.nextGemIdVal + (1);\n        return ncId;\n    }\n\n    /**\n     * @dev increase the pool's difficulty by calculating the step increase portion and adding it to the eth price of the market\n     */\n    function increaseDifficulty(ComplexPoolData storage self) public {\n        if (\n            self.priceIncrementType ==\n            INFTComplexGemPoolData.PriceIncrementType.COMPOUND\n        ) {\n            uint256 diffIncrease = self.ethPrice / (self.diffstep);\n            self.ethPrice = self.ethPrice + (diffIncrease);\n        } else if (\n            self.priceIncrementType ==\n            INFTComplexGemPoolData.PriceIncrementType.INVERSELOG\n        ) {\n            uint256 diffIncrease = self.diffstep / (self.ethPrice);\n            self.ethPrice = self.ethPrice + (diffIncrease);\n        }\n    }\n\n    /**\n     * @dev the hash of the next gem to be minted\n     */\n    function nextGemHash(ComplexPoolData storage self)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        \"gem\",\n                        address(self.pool),\n                        self.nextGemIdVal\n                    )\n                )\n            );\n    }\n\n    /**\n     * @dev the hash of the next claim to be minted\n     */\n    function nextClaimHash(ComplexPoolData storage self)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            (self.maxClaims != 0 && self.nextClaimIdVal <= self.maxClaims) ||\n                self.maxClaims == 0\n                ? uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            \"claim\",\n                            address(self.pool),\n                            self.nextClaimIdVal\n                        )\n                    )\n                )\n                : 0;\n    }\n\n    /**\n     * @dev get the token hash at index\n     */\n    function allTokenHashes(ComplexPoolData storage self, uint256 ndx)\n        public\n        view\n        returns (uint256)\n    {\n        return self.tokenHashes[ndx];\n    }\n\n    /**\n     * @dev return the claim amount paid for this claim\n     */\n    function claimAmount(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.claimAmountPaid[claimHash];\n    }\n\n    /**\n     * @dev the claim quantity (count of gems staked) for the given claim hash\n     */\n    function claimQuantity(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.claimQuant[claimHash];\n    }\n\n    /**\n     * @dev the lock time for this claim hash. once past lock time a gem is minted\n     */\n    function claimUnlockTime(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.claimLockTimestamps[claimHash];\n    }\n\n    /**\n     * @dev return the claim token amount for this claim hash\n     */\n    function claimTokenAmount(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.claimTokenAmountPaid[claimHash];\n    }\n\n    /**\n     * @dev return the claim hash of the given gemhash\n     */\n    function gemClaimHash(ComplexPoolData storage self, uint256 gemHash)\n        public\n        view\n        returns (uint256)\n    {\n        return self.gemClaims[gemHash];\n    }\n\n    /**\n     * @dev return the token that was staked to create the given token hash. 0 if the native token\n     */\n    function stakedToken(ComplexPoolData storage self, uint256 claimHash)\n        public\n        view\n        returns (address)\n    {\n        return self.claimLockToken[claimHash];\n    }\n\n    /**\n     * @dev add a token that is allowed to be used to create a claim\n     */\n    function addAllowedToken(ComplexPoolData storage self, address token)\n        public\n    {\n        if (!self.allowedTokens.exists(token)) {\n            self.allowedTokens.insert(token);\n        }\n    }\n\n    /**\n     * @dev  remove a token that is allowed to be used to create a claim\n     */\n    function removeAllowedToken(ComplexPoolData storage self, address token)\n        public\n    {\n        if (self.allowedTokens.exists(token)) {\n            self.allowedTokens.remove(token);\n        }\n    }\n\n    /**\n     * @dev deposit into pool\n     */\n    function deposit(\n        ComplexPoolData storage self,\n        address erc20token,\n        uint256 tokenAmount\n    ) public {\n        if (erc20token == address(0)) {\n            require(msg.sender.balance >= tokenAmount, \"INSUFFICIENT_BALANCE\");\n            self.totalStakedEth = self.totalStakedEth + (msg.sender.balance);\n        } else {\n            require(\n                IERC20(erc20token).balanceOf(msg.sender) >= tokenAmount,\n                \"INSUFFICIENT_BALANCE\"\n            );\n            IERC20(erc20token).transferFrom(\n                msg.sender,\n                address(self.pool),\n                tokenAmount\n            );\n        }\n    }\n\n    /**\n     * @dev deposit NFT into pool\n     */\n    function depositNFT(\n        ComplexPoolData storage self,\n        address erc1155token,\n        uint256 tokenId,\n        uint256 tokenAmount\n    ) public {\n        require(\n            IERC1155(erc1155token).balanceOf(msg.sender, tokenId) >=\n                tokenAmount,\n            \"INSUFFICIENT_BALANCE\"\n        );\n        IERC1155(erc1155token).safeTransferFrom(\n            msg.sender,\n            address(self.pool),\n            tokenId,\n            tokenAmount,\n            \"\"\n        );\n    }\n\n    /**\n     * @dev withdraw pool contents\n     */\n    function withdraw(\n        ComplexPoolData storage self,\n        address erc20token,\n        address destination,\n        uint256 tokenAmount\n    ) public {\n        require(destination != address(0), \"ZERO_ADDRESS\");\n        require(\n            self.controllers[msg.sender] == true || msg.sender == self.governor,\n            \"UNAUTHORIZED\"\n        );\n        if (erc20token == address(0)) {\n            payable(destination).transfer(tokenAmount);\n        } else {\n            IERC20(erc20token).transferFrom(\n                address(self.pool),\n                address(destination),\n                tokenAmount\n            );\n        }\n    }\n\n    /**\n     * @dev withdraw pool NFT\n     */\n    function withdrawNFT(\n        ComplexPoolData storage self,\n        address erc1155token,\n        address destination,\n        uint256 tokenId,\n        uint256 tokenAmount\n    ) public {\n        require(\n            self.controllers[msg.sender] == true || msg.sender == self.governor,\n            \"UNAUTHORIZED\"\n        );\n        require(erc1155token != address(0), \"ZERO_ADDRESS\");\n        require(destination != address(0), \"ZERO_ADDRESS\");\n        require(\n            IERC1155(erc1155token).balanceOf(address(self.pool), tokenId) >=\n                tokenAmount,\n            \"INSUFFICIENT_BALANCE\"\n        );\n        IERC1155(erc1155token).safeTransferFrom(\n            address(self.pool),\n            address(destination),\n            tokenId,\n            tokenAmount,\n            \"\"\n        );\n    }\n\n    /**\n     * @dev mint the genesis gems earned by the pools creator and funder\n     */\n    function mintGenesisGems(\n        ComplexPoolData storage self,\n        address creator,\n        address funder\n    ) public {\n        require(self.multitoken != address(0), \"NO_MULTITOKEN\");\n        require(\n            creator != address(0) && funder != address(0),\n            \"ZERO_DESTINATION\"\n        );\n        require(self.nextGemIdVal == 0, \"ALREADY_MINTED\");\n\n        uint256 gemHash = nextGemHash(self);\n        INFTGemMultiToken(self.multitoken).mint(creator, gemHash, 1);\n        addToken(self, gemHash, INFTGemMultiToken.TokenType.GEM);\n        // emit an event about a gem getting created\n        emit NFTGemCreated(creator, address(self.pool), 0, gemHash, 1);\n\n        gemHash = nextGemHash(self);\n        INFTGemMultiToken(self.multitoken).mint(funder, gemHash, 1);\n        addToken(self, gemHash, INFTGemMultiToken.TokenType.GEM);\n        // emit an event about a gem getting created\n        emit NFTGemCreated(funder, address(self.pool), 0, gemHash, 1);\n    }\n}\n"
    },
    "src/interfaces/INFTComplexGemPoolData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./INFTGemMultiToken.sol\";\nimport \"./INFTComplexGemPool.sol\";\n\ninterface INFTComplexGemPoolData {\n    enum PriceIncrementType {\n        COMPOUND,\n        INVERSELOG,\n        NONE\n    }\n\n    /**\n     * @dev a requirement of erc20, erc1155, or nft gem\n     */\n    struct InputRequirement {\n        address token;\n        address pool;\n        INFTComplexGemPool.RequirementType inputType; // 1 = erc20, 2 = erc1155, 3 = pool\n        uint256 tokenId; // if erc20 slot 0 contains required amount\n        uint256 minVal;\n        bool takeCustody;\n        bool burn;\n        bool exactAmount;\n    }\n\n    /**\n     * @dev Event generated when an NFT claim is imported from a legacy contract\n     */\n    event NFTGemImported(\n        address indexed converter,\n        address indexed pool,\n        address oldPool,\n        address oldToken,\n        uint256 indexed gemHash,\n        uint256 quantity\n    );\n\n    function addInputRequirement(\n        address theToken,\n        address pool,\n        INFTComplexGemPool.RequirementType inputType,\n        uint256 theTokenId,\n        uint256 minAmount,\n        bool takeCustody,\n        bool burn,\n        bool exactAmount\n    ) external;\n\n    function updateInputRequirement(\n        uint256 ndx,\n        address theToken,\n        address pool,\n        INFTComplexGemPool.RequirementType inputType,\n        uint256 tid,\n        uint256 minAmount,\n        bool takeCustody,\n        bool burn,\n        bool exactAmount\n    ) external;\n\n    function allInputRequirementsLength() external returns (uint256);\n\n    function allInputRequirements(uint256 ndx)\n        external\n        view\n        returns (\n            address,\n            address,\n            INFTComplexGemPool.RequirementType,\n            uint256,\n            uint256,\n            bool,\n            bool,\n            bool\n        );\n\n    function settings()\n        external\n        view\n        returns (\n            string memory settingsSymbol,\n            string memory settingsName,\n            string memory settingsDescription,\n            uint256 settingsCategory,\n            uint256 settingsEthPrice,\n            uint256 settingsMinTime,\n            uint256 settingsMaxTime,\n            uint256 settingsDiffStep,\n            uint256 settingsMacClaims,\n            uint256 settingsMaxQuantityPerClaim,\n            uint256 settingsMaxClaimsPerAccount\n        );\n\n    function stats()\n        external\n        view\n        returns (\n            bool statsVisible,\n            uint256 statsClaimedCount,\n            uint256 statsMintedCount,\n            uint256 statsTotalStakedEth,\n            uint256 statsNextClaimHash,\n            uint256 statsNextGemHash,\n            uint256 statsNextClaimId,\n            uint256 statsNextGemId\n        );\n\n    function claim(uint256 claimHash)\n        external\n        view\n        returns (\n            uint256 claimClaimAmount,\n            uint256 claimClaimQuantity,\n            uint256 claimClaimUnlockTime,\n            uint256 claimClaimTokenAmount,\n            address claimStakedToken,\n            uint256 claimNextClaimId\n        );\n\n    function token(uint256 tokenHash)\n        external\n        view\n        returns (\n            INFTGemMultiToken.TokenType tokenTokenType,\n            uint256 tokenTokenId,\n            address tokenTokenSource\n        );\n\n    function addAllowedTokenSource(address allowedToken) external;\n\n    function removeAllowedTokenSource(address allowedToken) external;\n\n    function allowedTokenSources() external view returns (address[] memory);\n\n    function importLegacyGem(\n        address pool,\n        address legacyToken,\n        uint256 tokenHash,\n        address recipient\n    ) external;\n\n    function isLegacyGemImported(uint256 tokenhash)\n        external\n        view\n        returns (bool);\n\n    function setNextIds(uint256 _nextClaimId, uint256 _nextGemId) external;\n\n    function tokenHashes() external view returns (uint256[] memory);\n\n    function setTokenHashes(uint256[] memory inTokenHashes) external;\n\n    // pool is inited with these parameters. Once inited, all\n    // but ethPrice are immutable. ethPrice only increases. ONLY UP\n    function symbol() external view returns (string memory);\n\n    function ethPrice() external view returns (uint256);\n\n    function setVisible(bool isVisible) external;\n\n    function visible() external view returns (bool);\n\n    function setCategory(uint256 theCategory) external;\n\n    function category() external view returns (uint256);\n\n    function setDescription(string memory desc) external;\n\n    function description() external view returns (string memory);\n\n    // these describe the pools created contents over time. This is where\n    // you query to get information about a token that a pool created\n    function claimedCount() external view returns (uint256);\n\n    function claimAmount(uint256 claimId) external view returns (uint256);\n\n    function claimQuantity(uint256 claimId) external view returns (uint256);\n\n    function maxQuantityPerClaim() external view returns (uint256);\n\n    function maxClaimsPerAccount() external view returns (uint256);\n\n    function setMaxQuantityPerClaim(uint256 claimId) external;\n\n    function setMaxClaimsPerAccount(uint256 claimId) external;\n\n    function mintedCount() external view returns (uint256);\n\n    function totalStakedEth() external view returns (uint256);\n\n    function tokenId(uint256 tokenHash) external view returns (uint256);\n\n    function tokenType(uint256 tokenHash)\n        external\n        view\n        returns (INFTGemMultiToken.TokenType);\n\n    function allTokenHashesLength() external view returns (uint256);\n\n    function allTokenHashes(uint256 ndx) external view returns (uint256);\n\n    function nextClaimHash() external view returns (uint256);\n\n    function nextGemHash() external view returns (uint256);\n\n    function nextGemId() external view returns (uint256);\n\n    function nextClaimId() external view returns (uint256);\n\n    function setValidateErc20(bool) external;\n\n    function validateErc20() external view returns (bool);\n\n    function claimUnlockTime(uint256 claimId) external view returns (uint256);\n\n    function claimTokenAmount(uint256 claimId) external view returns (uint256);\n\n    function gemClaimHash(uint256 gemHash) external view returns (uint256);\n\n    function stakedToken(uint256 claimId) external view returns (address);\n\n    function allowedTokensLength() external view returns (uint256);\n\n    function allowedTokens(uint256 idx) external view returns (address);\n\n    function isTokenAllowed(address tkn) external view returns (bool);\n\n    function addAllowedToken(address tkn) external;\n\n    function removeAllowedToken(address tkn) external;\n\n    function allowPurchase() external view returns (bool);\n\n    function setAllowPurchase(bool allow) external;\n\n    function enabled() external view returns (bool);\n\n    function setEnabled(bool enable) external;\n\n    function priceIncrementType() external view returns (PriceIncrementType);\n\n    function setPriceIncrementType(PriceIncrementType incrementType) external;\n}\n"
    },
    "src/interfaces/ISwapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ISwapQueryHelper {\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function factory() external view returns (address);\n\n    function COIN() external pure returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function hasPool(address token) external view returns (bool);\n\n    function getReserves(address pair) external view returns (uint256, uint256);\n\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        returns (address[] memory);\n\n    function setFactory(address f) external;\n}\n"
    },
    "src/interfaces/INFTGemGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface INFTGemGovernor {\n    function createPool(\n        address owner,\n        address funder,\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external returns (address);\n\n    function createSystemPool(\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external returns (address);\n\n    function initialized() external view returns (bool);\n}\n"
    },
    "src/interfaces/INFTComplexGemPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface INFTComplexGemPool {\n    enum RequirementType {\n        ERC20,\n        ERC1155,\n        POOL\n    }\n\n    /**\n     * @dev Event generated when an NFT claim is created using ETH\n     */\n    event NFTGemClaimCreated(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 length,\n        uint256 quantity,\n        uint256 amountPaid\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is created using ERC20 tokens\n     */\n    event NFTGemERC20ClaimCreated(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 length,\n        address token,\n        uint256 quantity,\n        uint256 conversionRate\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is redeemed\n     */\n    event NFTGemClaimRedeemed(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        uint256 amountPaid,\n        uint256 quantity,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is redeemed\n     */\n    event NFTGemERC20ClaimRedeemed(\n        address indexed account,\n        address indexed pool,\n        uint256 indexed claimHash,\n        address token,\n        uint256 ethPrice,\n        uint256 tokenAmount,\n        uint256 quantity,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when a gem is created\n     */\n    event NFTGemCreated(\n        address account,\n        address pool,\n        uint256 claimHash,\n        uint256 gemHash,\n        uint256 quantity\n    );\n\n    function setMultiToken(address token) external;\n\n    function setGovernor(address addr) external;\n\n    function setFeeTracker(address addr) external;\n\n    function setSwapHelper(address addr) external;\n\n    function mintGenesisGems(address creator, address funder) external;\n\n    function createClaim(uint256 timeframe) external payable;\n\n    function createClaims(uint256 timeframe, uint256 count) external payable;\n\n    function createERC20Claim(address erc20token, uint256 tokenAmount) external;\n\n    function createERC20Claims(\n        address erc20token,\n        uint256 tokenAmount,\n        uint256 count\n    ) external;\n\n    function collectClaim(uint256 claimHash, bool requireMature) external;\n\n    function purchaseGems(uint256 count) external payable;\n\n    function initialize(\n        string memory,\n        string memory,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n"
    },
    "src/interfaces/INFTGemFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface INFTGemFeeManager {\n    event FeeChanged(\n        address indexed operator,\n        uint256 indexed feeHash,\n        uint256 value\n    );\n\n    function fee(uint256 feeTypeHash) external view returns (uint256);\n\n    function setFee(uint256 feeTypeHash, uint256 _fee) external;\n\n    function balanceOf(address token) external view returns (uint256);\n\n    function transferEth(address payable recipient, uint256 amount) external;\n\n    function transferToken(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external;\n}\n"
    },
    "src/governance/NFTGemGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../access/Controllable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTComplexGemPool.sol\";\nimport \"../interfaces/INFTGemPoolFactory.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\n/**\n * @dev The governor contract for the system. Can create system pools (public pools shown on bitgems sites)\n *      and user-owned pools (private pools not shown on the bitgem sites). All  privileged calls are made\n *      through this contract.\n */\ncontract NFTGemGovernor is Controllable, Initializable, INFTGemGovernor {\n    // the multitoken contract\n    address private multitoken;\n    // the gem pool factory contract\n    address private factory;\n    // the fee manager contract\n    address private feeTracker;\n    // the swap manager contract\n    address private swapHelper;\n\n    /**\n     * @dev contract constructor\n     */\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /**\n     * @dev init this smart contract. Can only be called once. Sets the related contracts.\n     */\n    function initialize(\n        address _multitoken,\n        address _factory,\n        address _feeTracker,\n        address _swapHelper\n    ) public initializer {\n        multitoken = _multitoken;\n        factory = _factory;\n        feeTracker = _feeTracker;\n        swapHelper = _swapHelper;\n    }\n\n    function initialized() external view override returns (bool) {\n        return\n            multitoken != address(0x0) &&\n            factory != address(0x0) &&\n            feeTracker != address(0x0) &&\n            swapHelper != address(0x0);\n    }\n\n    /**\n     * @dev associate the newly-created pool with its relations and give it the privileges\n     * @param creator the owner of the pool\n     * @param funder the funder of the pool\n     * @param pool the pool\n     */\n    function associatePool(\n        address creator,\n        address funder,\n        address pool\n    ) internal {\n        IControllable(multitoken).addController(pool);\n        IControllable(this).addController(pool);\n\n        //INFTGemMultiToken(multitoken).addProxyRegistry(pool);\n\n        INFTComplexGemPool(pool).setMultiToken(multitoken);\n        INFTComplexGemPool(pool).setSwapHelper(swapHelper);\n        INFTComplexGemPool(pool).setGovernor(address(this));\n        INFTComplexGemPool(pool).setFeeTracker(feeTracker);\n        INFTComplexGemPool(pool).mintGenesisGems(creator, funder);\n    }\n\n    /**\n     * @dev internal gem pool creator method\n     */\n    function _createPool(\n        address owner,\n        address funder,\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) internal returns (address pool) {\n        // use the gem pool factory to create a new pool\n        pool = INFTGemPoolFactory(factory).createNFTGemPool(\n            owner,\n            symbol,\n            name,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n            allowedToken\n        );\n        // associate the pool with its relations\n        associatePool(owner, funder, pool);\n    }\n\n    /**\n     * @dev create a new system pool - called by sysadmins to add public pools\n     */\n    function createSystemPool(\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external override onlyController returns (address pool) {\n        pool = _createPool(\n            msg.sender,\n            msg.sender,\n            symbol,\n            name,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n            allowedToken\n        );\n        // TODO mark the pool as a system pool\n    }\n\n    /**\n     * @dev create a new pool - public\n     */\n    function createPool(\n        address owner,\n        address funder,\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external override returns (address pool) {\n        //TODO: we may not need this here at all if a private pool is privately managed anyways\n        pool = _createPool(\n            owner,\n            funder,\n            symbol,\n            name,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n            allowedToken\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "src/interfaces/INFTGemPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface INFTGemPoolFactory {\n    /**\n     * @dev emitted when a new gem pool has been added to the system\n     */\n    event NFTGemPoolCreated(\n        address indexed gemPoolAddress,\n        string gemSymbol,\n        string gemName,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    );\n\n    /**\n     * @dev emitted when a new gem pool has been added to the system\n     */\n    event CustomNFTGemPoolCreated(\n        address indexed gemPoolAdress,\n        string gemSymbol,\n        string gemName\n    );\n\n    function nftGemPools() external view returns (address[] memory);\n\n    function getNFTGemPool(uint256 _symbolHash) external view returns (address);\n\n    function allNFTGemPools(uint256 idx) external view returns (address);\n\n    function allNFTGemPoolsLength() external view returns (uint256);\n\n    function createNFTGemPool(\n        address owner,\n        string memory gemSymbol,\n        string memory gemName,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    ) external returns (address payable);\n}\n"
    },
    "src/pool/NFTComplexGemPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\nimport \"../interfaces/INFTComplexGemPool.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/ISwapQueryHelper.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\n\nimport \"../libs/AddressSet.sol\";\n\nimport \"./NFTComplexGemPoolData.sol\";\n\ncontract NFTComplexGemPool is\n    NFTComplexGemPoolData,\n    INFTComplexGemPool,\n    IERC3156FlashLender,\n    ERC1155Holder\n{\n    using AddressSet for AddressSet.Set;\n    using ComplexPoolLib for ComplexPoolLib.ComplexPoolData;\n\n    /**\n     * @dev Add an address allowed to control this contract\n     */\n    function addController(address _controllerAddress) external {\n        require(\n            poolData.controllers[msg.sender] == true ||\n                address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        poolData.controllers[_controllerAddress] = true;\n    }\n\n    /**\n     * @dev Check if this address is a controller\n     */\n    function isController(address _controllerAddress)\n        external\n        view\n        returns (bool)\n    {\n        return poolData.controllers[_controllerAddress];\n    }\n\n    /**\n     * @dev Remove the sender's address from the list of controllers\n     */\n    function relinquishControl() external {\n        require(\n            poolData.controllers[msg.sender] == true ||\n                address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        delete poolData.controllers[msg.sender];\n    }\n\n    constructor() {\n        poolData.controllers[msg.sender] = true;\n    }\n\n    /**\n     * @dev initializer called when contract is deployed\n     */\n    function initialize(\n        string memory _symbol,\n        string memory _name,\n        uint256 _ethPrice,\n        uint256 _minTime,\n        uint256 _maxTime,\n        uint256 _diffstep,\n        uint256 _maxClaims,\n        address _allowedToken\n    ) external override onlyController {\n        poolData.pool = address(this);\n        poolData.symbol = _symbol;\n        poolData.name = _name;\n        poolData.ethPrice = _ethPrice;\n        poolData.minTime = _minTime;\n        poolData.maxTime = _maxTime;\n        poolData.diffstep = _diffstep;\n        poolData.maxClaims = _maxClaims;\n        poolData.visible = true;\n        poolData.enabled = true;\n        if (_allowedToken != address(0)) {\n            poolData.allowedTokens.insert(_allowedToken);\n        }\n    }\n\n    /**\n     * @dev set the governor. pool uses the governor to issue gov token issuance requests\n     */\n    function setGovernor(address _governorAddress) external override {\n        require(\n            poolData.controllers[msg.sender] =\n                true ||\n                msg.sender == poolData.governor,\n            \"UNAUTHORIZED\"\n        );\n        poolData.governor = _governorAddress;\n    }\n\n    /**\n     * @dev set the fee tracker. pool uses the  fee tracker to issue  fee tracker token issuance requests\n     */\n    function setFeeTracker(address _feeTrackerAddress) external override {\n        require(\n            poolData.controllers[msg.sender] =\n                true ||\n                msg.sender == poolData.governor,\n            \"UNAUTHORIZED\"\n        );\n        poolData.feeTracker = _feeTrackerAddress;\n    }\n\n    /**\n     * @dev set the multitoken that this pool will mint new tokens on. Must be a controller of the multitoken\n     */\n    function setMultiToken(address _multiTokenAddress) external override {\n        require(\n            poolData.controllers[msg.sender] =\n                true ||\n                msg.sender == poolData.governor,\n            \"UNAUTHORIZED\"\n        );\n        poolData.multitoken = _multiTokenAddress;\n    }\n\n    /**\n     * @dev set the AMM swap helper that gets token prices\n     */\n    function setSwapHelper(address _swapHelperAddress) external override {\n        require(\n            poolData.controllers[msg.sender] =\n                true ||\n                msg.sender == poolData.governor,\n            \"UNAUTHORIZED\"\n        );\n        poolData.swapHelper = _swapHelperAddress;\n    }\n\n    /**\n     * @dev mint the genesis gems earned by the pools creator and funder\n     */\n    function mintGenesisGems(address _creatorAddress, address _funderAddress)\n        external\n        override\n    {\n        // security checks for this method are in the library - this\n        // method  may only be  called one time per new pool creation\n        poolData.mintGenesisGems(_creatorAddress, _funderAddress);\n    }\n\n    /**\n     * @dev create a single claim with given timeframe\n     */\n    function createClaim(uint256 _timeframe) external payable override {\n        poolData.createClaims(_timeframe, 1);\n    }\n\n    /**\n     * @dev create multiple claims with given timeframe\n     */\n    function createClaims(uint256 _timeframe, uint256 _count)\n        external\n        payable\n        override\n    {\n        poolData.createClaims(_timeframe, _count);\n    }\n\n    /**\n     * @dev purchase gems\n     */\n    function purchaseGems(uint256 _count) external payable override {\n        poolData.purchaseGems(msg.sender, msg.value, _count);\n    }\n\n    /**\n     * @dev create a claim using a erc20 token\n     */\n    function createERC20Claim(address _erc20TokenAddress, uint256 _tokenAmount)\n        external\n        override\n    {\n        poolData.createERC20Claims(_erc20TokenAddress, _tokenAmount, 1);\n    }\n\n    /**\n     * @dev create a claim using a erc20 token\n     */\n    function createERC20Claims(\n        address _erc20TokenAddress,\n        uint256 _tokenAmount,\n        uint256 _count\n    ) external override {\n        poolData.createERC20Claims(_erc20TokenAddress, _tokenAmount, _count);\n    }\n\n    /**\n     * @dev collect an open claim (take custody of the funds the claim is redeemable for and maybe a gem too)\n     */\n    function collectClaim(uint256 _claimHash, bool _requireMature)\n        external\n        override\n    {\n        poolData.collectClaim(_claimHash, _requireMature);\n    }\n\n    /**\n     * @dev The maximum flash loan amount - 90% of available funds\n     */\n    function maxFlashLoan(address tokenAddress)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // if the token address is zero then get the FTM balance\n        // other wise get the token balance of the given token address\n        return\n            tokenAddress == address(0)\n                ? address(this).balance\n                : IERC20(tokenAddress).balanceOf(address(this));\n    }\n\n    /**\n     * @dev The flash loan fee - 0.1% of borrowed funds\n     */\n    function flashFee(address token, uint256 amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // get hash of flash fee key using token address\n        uint256 flashFeeHash = uint256(\n            keccak256(abi.encodePacked(\"flash_loan\", address(token)))\n        );\n        // get the flash fee from the storage\n        uint256 feeDiv = INFTGemFeeManager(poolData.feeTracker).fee(\n            flashFeeHash\n        );\n        // if the flash fee is not set, get the default fee\n        if (feeDiv == 0) {\n            flashFeeHash = uint256(keccak256(abi.encodePacked(\"flash_loan\")));\n            feeDiv = INFTGemFeeManager(poolData.feeTracker).fee(flashFeeHash);\n        }\n        // if no default fee, set the fee to 10000 (0.01%)\n        if (feeDiv == 0) {\n            feeDiv = 10000;\n        }\n        return amount / feeDiv;\n    }\n\n    /**\n     * @dev Perform a flash loan (borrow tokens from the controller and return them after a certain time)\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool) {\n        // get the fee of the flash loan\n        uint256 fee = flashFee(token, amount);\n\n        // get the receiver's address\n        address receiverAddress = address(receiver);\n\n        // no token address means we are sending FTM\n        if (token == address(0)) {\n            payable(receiverAddress).transfer(amount);\n        } else {\n            // else we are sending erc20 tokens\n            IERC20(token).transfer(receiverAddress, amount);\n        }\n\n        // get the balance of the lender - base token if address is 0\n        // or erc20 token if address is not 0\n        uint256 initialBalance = token == address(0)\n            ? address(this).balance\n            : IERC20(token).balanceOf(address(this));\n        // create success callback hash\n        bytes32 callbackSuccess = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n        // call the flash loan callback\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) ==\n                callbackSuccess,\n            \"FlashMinter: Callback failed\"\n        );\n\n        // check if the flash loan is finished\n        // first we get the balance of the lender\n        uint256 _allowance = address(this).balance;\n        if (token != address(0)) {\n            // if the token is erc20 we need\n            // to get the allowance of the token\n            _allowance = IERC20(token).allowance(\n                address(receiver),\n                address(this)\n            );\n        } else {\n            // if the token is FTM we check if the\n            // initia balance is greater than the\n            // allowance. If it is we set _allowance\n            // to zero to dissallow the loan. Other\n            if (initialBalance > _allowance) _allowance = 0;\n            else _allowance = _allowance - initialBalance;\n        }\n\n        // if the allowance is greater than the loan amount plus\n        // the fee then we can finish the flash loan\n        require(\n            _allowance >= (amount + fee),\n            \"FlashMinter: Repay not approved\"\n        );\n\n        return true;\n    }\n}\n"
    },
    "src/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "src/pool/NFTComplexGemPoolData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../libs/AddressSet.sol\";\n\nimport \"./ComplexPoolLib.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\nimport \"../interfaces/INFTGemPoolData.sol\";\n\ncontract NFTComplexGemPoolData is INFTComplexGemPoolData {\n    using AddressSet for AddressSet.Set;\n    using ComplexPoolLib for ComplexPoolLib.ComplexPoolData;\n\n    ComplexPoolLib.ComplexPoolData internal poolData;\n\n    /**\n     * @dev Throws if called by any account not in authorized list\n     */\n    modifier onlyController() {\n        require(\n            poolData.controllers[msg.sender] == true ||\n                msg.sender == poolData.governor ||\n                address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        _;\n    }\n\n    constructor() {\n        poolData.controllers[msg.sender] = true;\n        poolData.controllers[tx.origin] = true;\n    }\n\n    /**\n     * @dev all the tokenhashes (both claim and gem) for this pool\n     */\n    function tokenHashes() external view override returns (uint256[] memory) {\n        return poolData.tokenHashes;\n    }\n\n    /**\n     * @dev set all the token hashes for this pool\n     */\n    function setTokenHashes(uint256[] memory _tokenHashes)\n        external\n        override\n        onlyController\n    {\n        poolData.tokenHashes = _tokenHashes;\n    }\n\n    /**\n     * @dev The symbol for this pool / NFT\n     */\n    function symbol() external view override returns (string memory) {\n        return poolData.symbol;\n    }\n\n    /**\n     * @dev The ether price for this pool / NFT\n     */\n    function ethPrice() external view override returns (uint256) {\n        return poolData.ethPrice;\n    }\n\n    /**\n     * @dev max allowable quantity per claim\n     */\n    function maxQuantityPerClaim() external view override returns (uint256) {\n        return poolData.maxQuantityPerClaim;\n    }\n\n    /**\n     * @dev max claims that can be made on this NFT on any given account\n     */\n    function maxClaimsPerAccount() external view override returns (uint256) {\n        return poolData.maxClaimsPerAccount;\n    }\n\n    /**\n     * @dev update max quantity per claim\n     */\n    function setMaxQuantityPerClaim(uint256 _maxQuantityPerClaim)\n        external\n        override\n        onlyController\n    {\n        poolData.maxQuantityPerClaim = _maxQuantityPerClaim;\n    }\n\n    /**\n     * @dev update max claims that can be made on this NFT\n     */\n    function setMaxClaimsPerAccount(uint256 _maxClaimsPerAccount)\n        external\n        override\n        onlyController\n    {\n        poolData.maxClaimsPerAccount = _maxClaimsPerAccount;\n    }\n\n    /**\n     * @dev returns if pool allows purchase\n     */\n    function allowPurchase() external view override returns (bool) {\n        return poolData.allowPurchase;\n    }\n\n    /**\n     * @dev set whether pool allows purchase\n     */\n    function setAllowPurchase(bool _allowPurchase)\n        external\n        override\n        onlyController\n    {\n        poolData.allowPurchase = _allowPurchase;\n    }\n\n    /**\n     * @dev is pool enabled (taking claim requests)\n     */\n    function enabled() external view override returns (bool) {\n        return poolData.enabled;\n    }\n\n    /**\n     * @dev set the enabled status of this pool\n     */\n    function setEnabled(bool _enabled) external override onlyController {\n        poolData.enabled = _enabled;\n    }\n\n    /**\n     * @dev return the appreciation curve of this pool.\n     */\n    function priceIncrementType()\n        external\n        view\n        override\n        returns (PriceIncrementType)\n    {\n        return poolData.priceIncrementType;\n    }\n\n    /**\n     * @dev set the appreciation curve of this pool.\n     */\n    function setPriceIncrementType(PriceIncrementType _incrementType)\n        external\n        override\n        onlyController\n    {\n        poolData.priceIncrementType = _incrementType;\n    }\n\n    /**\n     * @dev return the number of claims made thus far\n     */\n    function claimedCount() external view override returns (uint256) {\n        return poolData.nextClaimIdVal;\n    }\n\n    /**\n     * @dev return the number of gems made thus far\n     */\n    function mintedCount() external view override returns (uint256) {\n        return poolData.nextGemIdVal;\n    }\n\n    /**\n     * @dev the total amopunt of staked eth in this pool\n     */\n    function totalStakedEth() external view override returns (uint256) {\n        return poolData.totalStakedEth;\n    }\n\n    /**\n     * @dev get token type of hash - 1 is for claim, 2 is for gem\n     */\n    function tokenType(uint256 _tokenHash)\n        external\n        view\n        override\n        returns (INFTGemMultiToken.TokenType)\n    {\n        return poolData.tokenTypes[_tokenHash];\n    }\n\n    /**\n     * @dev get the claim hash of the gem\n     */\n    function gemClaimHash(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.gemClaims[_claimHash];\n    }\n\n    /**\n     * @dev get token id (serial #) of the given token hash. 0 if not a token, 1 if claim, 2 if gem\n     */\n    function tokenId(uint256 _tokenHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.tokenIds[_tokenHash];\n    }\n\n    /**\n     * @dev returns a count of all token hashes\n     */\n    function allTokenHashesLength() external view override returns (uint256) {\n        return poolData.tokenHashes.length;\n    }\n\n    /**\n     * @dev get the token hash at index\n     */\n    function allTokenHashes(uint256 ndx)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.tokenHashes[ndx];\n    }\n\n    /**\n     * @dev return the next claim hash\n     */\n    function nextClaimHash() external view override returns (uint256) {\n        return poolData.nextClaimHash();\n    }\n\n    /**\n     * @dev return the next gem hash\n     */\n    function nextGemHash() external view override returns (uint256) {\n        return poolData.nextGemHash();\n    }\n\n    /**\n     * @dev return the next claim id\n     */\n    function nextClaimId() external view override returns (uint256) {\n        return poolData.nextClaimIdVal;\n    }\n\n    /**\n     * @dev return the next gem id\n     */\n    function nextGemId() external view override returns (uint256) {\n        return poolData.nextGemIdVal;\n    }\n\n    /**\n     * @dev return the count of allowed tokens\n     */\n    function allowedTokensLength() external view override returns (uint256) {\n        return poolData.allowedTokens.count();\n    }\n\n    /**\n     * @dev the allowed token address at index\n     */\n    function allowedTokens(uint256 _index)\n        external\n        view\n        override\n        returns (address)\n    {\n        return poolData.allowedTokens.keyAtIndex(_index);\n    }\n\n    /**\n     * @dev add an allowed token to the pool\n     */\n    function addAllowedToken(address _tokenAddress)\n        external\n        override\n        onlyController\n    {\n        poolData.allowedTokens.insert(_tokenAddress);\n    }\n\n    /**\n     * @dev add an allowed token to the pool\n     */\n    function removeAllowedToken(address _tokenAddress)\n        external\n        override\n        onlyController\n    {\n        poolData.allowedTokens.remove(_tokenAddress);\n    }\n\n    /**\n     * @dev is the token in the allowed tokens list\n     */\n    function isTokenAllowed(address _tokenAddress)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return poolData.allowedTokens.exists(_tokenAddress);\n    }\n\n    /**\n     * @dev the claim amount for the given claim id\n     */\n    function claimAmount(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.claimAmount(_claimHash);\n    }\n\n    /**\n     * @dev the claim quantity (count of gems staked) for the given claim id\n     */\n    function claimQuantity(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.claimQuantity(_claimHash);\n    }\n\n    /**\n     * @dev the lock time for this claim. once past lock time a gema is minted\n     */\n    function claimUnlockTime(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.claimUnlockTime(_claimHash);\n    }\n\n    /**\n     * @dev claim token amount if paid using erc20\n     */\n    function claimTokenAmount(uint256 _claimHash)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.claimTokenAmount(_claimHash);\n    }\n\n    /**\n     * @dev the staked token if staking with erc20\n     */\n    function stakedToken(uint256 _claimHash)\n        external\n        view\n        override\n        returns (address)\n    {\n        return poolData.stakedToken(_claimHash);\n    }\n\n    /**\n     * @dev set market visibility\n     */\n    function setVisible(bool _visible) external override onlyController {\n        poolData.visible = _visible;\n    }\n\n    /**\n     * @dev set market visibility\n     */\n    function visible() external view override returns (bool) {\n        return poolData.visible;\n    }\n\n    /**\n     * @dev set category category\n     */\n    function setCategory(uint256 _category) external override onlyController {\n        poolData.category = _category;\n    }\n\n    /**\n     * @dev get market category\n     */\n    function category() external view override returns (uint256) {\n        return poolData.category;\n    }\n\n    /**\n     * @dev set description\n     */\n    function setDescription(string memory desc)\n        external\n        override\n        onlyController\n    {\n        poolData.description = desc;\n    }\n\n    /**\n     * @dev get description\n     */\n    function description() external view override returns (string memory) {\n        return poolData.description;\n    }\n\n    /**\n     * @dev set validate erc20 token against AMM\n     */\n    function setValidateErc20(bool) external override onlyController {\n        poolData.validateerc20 = true;\n    }\n\n    /**\n     * @dev get validate erc20 token against AMM\n     */\n    function validateErc20() external view override returns (bool) {\n        return poolData.validateerc20;\n    }\n\n    /**\n     * @dev add an input requirement for this token\n     */\n    function addInputRequirement(\n        address _tokenAddress,\n        address _poolAddress,\n        INFTComplexGemPool.RequirementType _inputType,\n        uint256 _tokenId,\n        uint256 _minAmount,\n        bool _takeCustody,\n        bool _burn,\n        bool _exactAmount\n    ) external override {\n        poolData.addInputRequirement(\n            _tokenAddress,\n            _poolAddress,\n            _inputType,\n            _tokenId,\n            _minAmount,\n            _takeCustody,\n            _burn,\n            _exactAmount\n        );\n    }\n\n    /**\n     * @dev add an input requirement for this token\n     */\n    function updateInputRequirement(\n        uint256 _index,\n        address _tokenAddress,\n        address _poolAddress,\n        INFTComplexGemPool.RequirementType _inputType,\n        uint256 _tokenId,\n        uint256 _minAmount,\n        bool _takeCustody,\n        bool _burn,\n        bool _exactAmount\n    ) external override {\n        poolData.updateInputRequirement(\n            _index,\n            _tokenAddress,\n            _poolAddress,\n            _inputType,\n            _tokenId,\n            _minAmount,\n            _takeCustody,\n            _burn,\n            _exactAmount\n        );\n    }\n\n    /**\n     * @dev all Input Requirements Length\n     */\n    function allInputRequirementsLength()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return poolData.allInputRequirementsLength();\n    }\n\n    /**\n     * @dev all Input Requirements at element\n     */\n    function allInputRequirements(uint256 _index)\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            INFTComplexGemPool.RequirementType,\n            uint256,\n            uint256,\n            bool,\n            bool,\n            bool\n        )\n    {\n        return poolData.allInputRequirements(_index);\n    }\n\n    /**\n     * @dev add an allowed token source\n     */\n    function addAllowedTokenSource(address _allowedToken) external override {\n        if (!poolData.allowedTokenSources.exists(_allowedToken)) {\n            poolData.allowedTokenSources.insert(_allowedToken);\n        }\n    }\n\n    /**\n     * @dev remove an allowed token source\n     */\n    function removeAllowedTokenSource(address _allowedToken) external override {\n        if (poolData.allowedTokenSources.exists(_allowedToken)) {\n            poolData.allowedTokenSources.remove(_allowedToken);\n        }\n    }\n\n    /**\n     * @dev returns an array of all allowed token sources\n     */\n    function allowedTokenSources()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return poolData.allowedTokenSources.keyList;\n    }\n\n    /**\n     * @dev delegate proxy method for multitoken allow\n     */\n    function proxies(address) external view returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev these settings defines how the pool behaves\n     */\n    function settings()\n        external\n        view\n        override\n        returns (\n            string memory,\n            string memory,\n            string memory,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            poolData.symbol,\n            poolData.name,\n            poolData.description,\n            poolData.category,\n            poolData.ethPrice,\n            poolData.minTime,\n            poolData.maxTime,\n            poolData.diffstep,\n            poolData.maxClaims,\n            poolData.maxQuantityPerClaim,\n            poolData.maxClaimsPerAccount\n        );\n    }\n\n    /**\n     * @dev these stats reflect the current pool state\n     */\n    function stats()\n        external\n        view\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            poolData.visible,\n            poolData.nextClaimIdVal,\n            poolData.nextGemIdVal,\n            poolData.totalStakedEth,\n            poolData.nextClaimHash(),\n            poolData.nextGemHash(),\n            poolData.nextClaimIdVal,\n            poolData.nextGemIdVal\n        );\n    }\n\n    /**\n     * @dev return the claim details for the given claim hash\n     */\n    function claim(uint256 claimHash)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (\n            poolData.claimAmount(claimHash),\n            poolData.claimQuantity(claimHash),\n            poolData.claimUnlockTime(claimHash),\n            poolData.claimTokenAmount(claimHash),\n            poolData.stakedToken(claimHash),\n            poolData.nextClaimIdVal\n        );\n    }\n\n    /**\n     * @dev return the token data for the given hash\n     */\n    function token(uint256 _tokenHash)\n        external\n        view\n        override\n        returns (\n            INFTGemMultiToken.TokenType,\n            uint256,\n            address\n        )\n    {\n        return (\n            poolData.tokenTypes[_tokenHash],\n            poolData.tokenIds[_tokenHash],\n            poolData.tokenSources[_tokenHash]\n        );\n    }\n\n    /**\n     * @dev import the legacy gem\n     */\n    function importLegacyGem(\n        address _poolAddress,\n        address _legacyToken,\n        uint256 _tokenHash,\n        address _recipient\n    ) external override {\n        // this method is callable by anyone - this is used to import historical\n        // gems into the new contracts. A gem can only be imported in once\n        // per source\n        require(_tokenHash > 0, \"INVALID_TOKENHASH\");\n        require(_poolAddress > address(0), \"INVALID_POOL\");\n        require(_legacyToken > address(0), \"INVALID_TOKEN\");\n        require(_recipient > address(0), \"INVALID_RECIPIENT\");\n        require(\n            poolData.allowedTokenSources.exists(_legacyToken) == true,\n            \"INVALID_TOKENSOURCE\"\n        );\n        require(\n            poolData.importedLegacyToken[_tokenHash] == false,\n            \"ALREADY_IMPORTED\"\n        );\n\n        bytes32 importedSymHash = keccak256(\n            abi.encodePacked(INFTGemPoolData(_poolAddress).symbol())\n        );\n        bytes32 poolSymHash = keccak256(abi.encodePacked(poolData.symbol));\n        require(importedSymHash == poolSymHash, \"INVALID_POOLHASH\");\n\n        INFTGemMultiToken.TokenType importTokenType = INFTGemPoolData(\n            _poolAddress\n        ).tokenType(_tokenHash);\n        require(\n            importTokenType == INFTGemMultiToken.TokenType.GEM,\n            \"INVALID_TOKENTYPE\"\n        );\n\n        uint256 quantity = IERC1155(_legacyToken).balanceOf(\n            _recipient,\n            _tokenHash\n        );\n        uint256 importTokenId = INFTGemPoolData(_poolAddress).tokenId(\n            _tokenHash\n        );\n\n        if (quantity > 0) {\n            INFTGemMultiToken(poolData.multitoken).mint(\n                _recipient,\n                _tokenHash,\n                quantity\n            );\n            INFTGemMultiToken(poolData.multitoken).setTokenData(\n                _tokenHash,\n                INFTGemMultiToken.TokenType.GEM,\n                address(this)\n            );\n\n            poolData.tokenTypes[_tokenHash] = INFTGemMultiToken.TokenType.GEM;\n            poolData.tokenIds[_tokenHash] = importTokenId;\n            poolData.tokenSources[_tokenHash] = _legacyToken;\n            poolData.importedLegacyToken[_tokenHash] = true;\n\n            emit NFTGemImported(\n                msg.sender,\n                address(this),\n                _poolAddress,\n                _legacyToken,\n                _tokenHash,\n                quantity\n            );\n        }\n    }\n\n    /**\n     * @dev returns if legacy gem with given hash is imported\n     */\n    function isLegacyGemImported(uint256 _tokenhash)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return poolData.importedLegacyToken[_tokenhash];\n    }\n\n    /**\n     * @dev set the next claim and gem ids\n     */\n    function setNextIds(uint256 _nextClaimId, uint256 _nextGemId)\n        external\n        override\n        onlyController\n    {\n        poolData.nextClaimIdVal = _nextClaimId;\n        poolData.nextGemIdVal = _nextGemId;\n    }\n}\n"
    },
    "src/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "src/interfaces/INFTGemPoolData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./INFTGemMultiToken.sol\";\n\ninterface INFTGemPoolData {\n    // pool is inited with these parameters. Once inited, all\n    // but ethPrice are immutable. ethPrice only increases. ONLY UP\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function ethPrice() external view returns (uint256);\n\n    function minTime() external view returns (uint256);\n\n    function maxTime() external view returns (uint256);\n\n    function difficultyStep() external view returns (uint256);\n\n    function maxClaims() external view returns (uint256);\n\n    // these describe the pools created contents over time. This is where\n    // you query to get information about a token that a pool created\n    function claimedCount() external view returns (uint256);\n\n    function claimAmount(uint256 claimId) external view returns (uint256);\n\n    function claimQuantity(uint256 claimId) external view returns (uint256);\n\n    function mintedCount() external view returns (uint256);\n\n    function totalStakedEth() external view returns (uint256);\n\n    function tokenId(uint256 tokenHash) external view returns (uint256);\n\n    function tokenType(uint256 tokenHash)\n        external\n        view\n        returns (INFTGemMultiToken.TokenType);\n\n    function allTokenHashesLength() external view returns (uint256);\n\n    function allTokenHashes(uint256 ndx) external view returns (uint256);\n\n    function nextClaimHash() external view returns (uint256);\n\n    function nextGemHash() external view returns (uint256);\n\n    function nextGemId() external view returns (uint256);\n\n    function nextClaimId() external view returns (uint256);\n\n    function claimUnlockTime(uint256 claimId) external view returns (uint256);\n\n    function claimTokenAmount(uint256 claimId) external view returns (uint256);\n\n    function stakedToken(uint256 claimId) external view returns (address);\n\n    function allowedTokensLength() external view returns (uint256);\n\n    function allowedTokens(uint256 idx) external view returns (address);\n\n    function isTokenAllowed(address token) external view returns (bool);\n\n    function addAllowedToken(address token) external;\n\n    function removeAllowedToken(address token) external;\n}\n"
    },
    "src/tokens/WrappedTokenLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IERC20WrappedGem.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\n\n/**\n * @dev wrapped token library\n */\nlibrary WrappedTokenLib {\n    event Wrap(address indexed account, uint256 quantity);\n    event Unwrap(address indexed account, uint256 quantity);\n\n    /**\n     * @dev data struct for wrapped token\n     */\n    struct WrappedTokenData {\n        address erc1155token;\n        address erc20token;\n        address tokenPool;\n        uint256 index;\n        INFTGemMultiToken.TokenType tokenType;\n        uint256 rate;\n        uint256 wrappedBalance;\n        mapping(address => uint256[]) ids;\n        mapping(address => uint256[]) amounts;\n    }\n\n    /**\n     * @dev get pool balance (number of minted claims or gems) for given token pool, token type, for account\n     */\n    function getPoolTypeBalance(\n        address erc1155token,\n        address tokenPool,\n        INFTGemMultiToken.TokenType tokenType,\n        address account\n    ) public view returns (uint256 tq) {\n        uint256[] memory ht = INFTGemMultiToken(erc1155token).heldTokens(\n            account\n        );\n        for (uint256 i = ht.length - 1; i >= 0; i = i - 1) {\n            uint256 tokenHash = ht[i];\n            (\n                INFTGemMultiToken.TokenType _tokenType,\n                address _tokenPool\n            ) = INFTGemMultiToken(erc1155token).getTokenData(tokenHash);\n            if (_tokenType == tokenType && _tokenPool == tokenPool) {\n                uint256 oq = IERC1155(erc1155token).balanceOf(\n                    account,\n                    tokenHash\n                );\n                tq = tq + oq;\n            }\n            if (i == 0) break;\n        }\n    }\n\n    /**\n     * @dev transfer a given number of claims / gems from account to recipient\n     */\n    function transferPoolTypesFrom(\n        WrappedTokenData storage self,\n        address from,\n        address to,\n        uint256 quantity\n    ) public {\n        uint256 tq = quantity;\n        delete self.ids[to];\n        delete self.amounts[to];\n\n        uint256[] memory ht = INFTGemMultiToken(self.erc1155token).heldTokens(\n            from\n        );\n        for (uint256 i = ht.length - 1; i >= 0 && tq > 0; i = i - 1) {\n            uint256 tokenHash = ht[i];\n            (\n                INFTGemMultiToken.TokenType _tokenType,\n                address _tokenPool\n            ) = INFTGemMultiToken(self.erc1155token).getTokenData(tokenHash);\n            if (_tokenType == self.tokenType && _tokenPool == self.tokenPool) {\n                uint256 oq = IERC1155(self.erc1155token).balanceOf(\n                    from,\n                    tokenHash\n                );\n                uint256 toTransfer = oq > tq ? tq : oq;\n                self.ids[to].push(tokenHash);\n                self.amounts[to].push(toTransfer);\n                tq = tq - toTransfer;\n            }\n            if (i == 0) break;\n        }\n\n        require(tq == 0, \"INSUFFICIENT_GEMS\");\n\n        IERC1155(self.erc1155token).safeBatchTransferFrom(\n            from,\n            to,\n            self.ids[to],\n            self.amounts[to],\n            \"\"\n        );\n    }\n}\n"
    },
    "src/interfaces/IERC20WrappedGem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./IERC20WrappedERC1155.sol\";\n\n/**\n * @dev A wrapped gem is an erc20 wrapper around an erc1155 token type\n */\ninterface IERC20WrappedGem is IERC20WrappedERC1155 {\n\n}\n"
    },
    "src/interfaces/IERC20WrappedERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20WrappedERC1155 {\n    function wrap(uint256 quantity) external;\n\n    function unwrap(uint256 quantity) external;\n\n    function getReserves() external returns (uint256);\n\n    function getTokenAddress() external returns (address);\n\n    function getTokenId() external returns (uint256);\n\n    event Wrap(address indexed account, uint256 quantity);\n    event Unwrap(address indexed account, uint256 quantity);\n\n    function initialize(\n        string memory,\n        string memory,\n        address,\n        address,\n        uint8,\n        address\n    ) external;\n}\n"
    },
    "src/tokens/ERC20WrappedERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport \"../interfaces/IERC20WrappedERC1155.sol\";\nimport \"./WrappedTokenLib.sol\";\n\n/**\n * @dev Wrap a single ERC1155 token hash into an ERC20 token.\n */\ncontract ERC20WrappedERC1155 is ERC20, ERC1155Holder, IERC20WrappedERC1155 {\n    using WrappedTokenLib for WrappedTokenLib.WrappedTokenData;\n\n    WrappedTokenLib.WrappedTokenData internal tokenData;\n\n    /**\n     * @dev constructor sets up token parameters.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address erc1155Token,\n        uint256 tokenIndex,\n        uint256 exchangeRate\n    ) ERC20(name, symbol) {\n        tokenData.erc1155token = erc1155Token;\n        tokenData.tokenPool = address(0);\n        tokenData.index = tokenIndex;\n        tokenData.tokenType = INFTGemMultiToken.TokenType.GOVERNANCE;\n        tokenData.rate = exchangeRate;\n        _setupDecimals(decimals);\n    }\n\n    /**\n     * @dev initialize is a stub because this class is deployed by us with constructor params\n     */\n    function initialize(\n        string memory,\n        string memory,\n        address,\n        address,\n        uint8,\n        address\n    ) external override {\n        tokenData.erc20token = address(this);\n    }\n\n    /**\n     * @dev wrap a quantity of tokens by transferring ERC1155 to this contract and minting ERC20 token\n     */\n    function _wrap(uint256 quantity) internal {\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(\n            IERC1155(tokenData.erc1155token).balanceOf(\n                msg.sender,\n                tokenData.index\n            ) >= quantity,\n            \"INSUFFICIENT_ERC1155_BALANCE\"\n        );\n        IERC1155(tokenData.erc1155token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenData.index,\n            quantity,\n            \"\"\n        );\n        _mint(msg.sender, quantity * (tokenData.rate * 10**decimals()));\n    }\n\n    /**\n     * @dev wrap a quantity of erc1155 governance to erc20\n     */\n    function wrap(uint256 quantity) external virtual override {\n        _wrap(quantity);\n    }\n\n    /**\n     * @dev unwrap a quantity of wrapped erc20 governance to erc1155\n     */\n    function _unwrap(uint256 quantity) internal {\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(\n            IERC1155(tokenData.erc1155token).balanceOf(\n                address(this),\n                tokenData.index\n            ) >= quantity,\n            \"INSUFFICIENT_RESERVES\"\n        );\n        require(\n            balanceOf(msg.sender) >=\n                quantity * (tokenData.rate * 10**decimals()),\n            \"INSUFFICIENT_ERC20_BALANCE\"\n        );\n        _burn(msg.sender, quantity * (tokenData.rate * 10**decimals()));\n        IERC1155(tokenData.erc1155token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            tokenData.index,\n            quantity,\n            \"\"\n        );\n    }\n\n    /**\n     * @dev unwrap a quantity of wrapped erc20 governance to erc1155\n     */\n    function unwrap(uint256 quantity) external virtual override {\n        _unwrap(quantity);\n    }\n\n    /**\n     * @dev get reserves held in wrapper\n     */\n    function getReserves() external view override returns (uint256) {\n        return\n            IERC1155(tokenData.erc1155token).balanceOf(\n                address(this),\n                tokenData.index\n            );\n    }\n\n    /**\n     * @dev get the token address this wrapper is bound to\n     */\n    function getTokenAddress() external view override returns (address) {\n        return tokenData.erc1155token;\n    }\n\n    /**\n     * @dev get the token id this wrapper is bound to\n     */\n    function getTokenId() external view override returns (uint256) {\n        return tokenData.index;\n    }\n}\n"
    },
    "src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev sets the decimal value\n     */\n    function _setupDecimals(uint8 _value) internal {\n        _decimals = _value;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/tokens/ERC20WrappedGem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport \"./ERC20Constructorless.sol\";\n\nimport \"../interfaces/IERC20WrappedGem.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\nimport \"./WrappedTokenLib.sol\";\n\n/**\n * @dev Wraps a gem (erc1155 'gem' type issued by an NFTGemPool) into erc1155\n */\ncontract ERC20WrappedGem is\n    ERC20Constructorless,\n    ERC1155Holder,\n    IERC20WrappedGem,\n    Initializable\n{\n    using WrappedTokenLib for WrappedTokenLib.WrappedTokenData;\n    address internal _feeManager;\n\n    WrappedTokenLib.WrappedTokenData internal tokenData;\n\n    /**\n     * @dev initialize contract state\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address gemPool,\n        address gemToken,\n        uint8 decimals,\n        address feeManager\n    ) external override initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _feeManager = feeManager;\n        tokenData.erc1155token = gemToken;\n        tokenData.erc20token = address(this);\n        tokenData.tokenPool = gemPool;\n        tokenData.index = 0;\n        tokenData.rate = 1;\n        tokenData.tokenType = INFTGemMultiToken.TokenType.GEM;\n    }\n\n    /**\n     * @dev get fee to wrap tokens\n     */\n    function getWrapFee(uint256 totalQuantity)\n        internal\n        view\n        returns (uint256 fd)\n    {\n        uint256 thisWrapFeeHash = uint256(\n            keccak256(abi.encodePacked(\"wrap_gem\", address(this)))\n        );\n        fd = INFTGemFeeManager(_feeManager).fee(thisWrapFeeHash);\n        if (fd == 0) {\n            thisWrapFeeHash = uint256(keccak256(abi.encodePacked(\"wrap_gem\")));\n            fd = INFTGemFeeManager(_feeManager).fee(thisWrapFeeHash);\n        }\n        return fd != 0 ? totalQuantity / fd : 0;\n    }\n\n    /**\n     * @dev wrap gems to erc20\n     */\n    function wrap(uint256 quantity) external override {\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(\n            WrappedTokenLib.getPoolTypeBalance(\n                tokenData.erc1155token,\n                tokenData.tokenPool,\n                tokenData.tokenType,\n                msg.sender\n            ) >= quantity,\n            \"INSUFFICIENT_QUANTITY\"\n        );\n        uint256 tq = quantity * (tokenData.rate * 10**decimals());\n\n        uint256 fee = getWrapFee(tq);\n        uint256 userQty = tq - fee;\n\n        tokenData.transferPoolTypesFrom(msg.sender, address(this), quantity);\n        _mint(msg.sender, userQty);\n        _mint(_feeManager, fee);\n\n        tokenData.wrappedBalance = tokenData.wrappedBalance + quantity;\n\n        emit Wrap(msg.sender, quantity);\n    }\n\n    /**\n     * @dev unwrap wrapped gems\n     */\n    function unwrap(uint256 quantity) external override {\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(\n            balanceOf(msg.sender) * (10**decimals()) >= quantity,\n            \"INSUFFICIENT_QUANTITY\"\n        );\n\n        tokenData.transferPoolTypesFrom(address(this), msg.sender, quantity);\n        _burn(msg.sender, quantity * (10**decimals()));\n        tokenData.wrappedBalance = tokenData.wrappedBalance - (quantity);\n\n        emit Unwrap(msg.sender, quantity);\n    }\n\n    /**\n     * @dev get reserves held in wrapper\n     */\n    function getReserves() external view override returns (uint256) {\n        return tokenData.wrappedBalance;\n    }\n\n    /**\n     * @dev get the token address this wrapper is bound to\n     */\n    function getTokenAddress() external view override returns (address) {\n        return tokenData.erc1155token;\n    }\n\n    /**\n     * @dev get the token id this wrapper is bound to\n     */\n    function getTokenId() external view override returns (uint256) {\n        return tokenData.index;\n    }\n}\n"
    },
    "src/tokens/ERC20Constructorless.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Constructorless is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n\n    uint8 internal _decimals;\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/diagnostics/TokenPoolQuerier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"../interfaces/ITokenPoolQuerier.sol\";\nimport \"../interfaces/INFTComplexGemPoolData.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\n\ncontract TokenPoolQuerier is ITokenPoolQuerier {\n    function getOwnedTokens(\n        address gemPool,\n        address multitoken,\n        address account,\n        uint256 page,\n        uint256 count\n    )\n        external\n        view\n        override\n        returns (uint256[] memory claims, uint256[] memory gems)\n    {\n        uint256 allTokenHashesLength = INFTComplexGemPoolData(gemPool)\n        .allTokenHashesLength();\n        require((page * count) <= allTokenHashesLength, \"OUT_OF_RANGE\");\n\n        uint256 claimLen = 0;\n        uint256 gemLen = 0;\n\n        claims = new uint256[](count);\n        gems = new uint256[](count);\n\n        for (uint256 i = page * count; i < (page * count) + count; i++) {\n            if (i >= allTokenHashesLength) {\n                break;\n            }\n            uint256 claimHash = INFTComplexGemPoolData(gemPool).allTokenHashes(\n                i\n            );\n            INFTGemMultiToken.TokenType tokenType = INFTComplexGemPoolData(\n                gemPool\n            ).tokenType(claimHash);\n            uint256 bal = IERC1155(multitoken).balanceOf(account, claimHash);\n            if (bal == 0 || claimHash == 0 || claimHash == 1) continue;\n            else if (tokenType == INFTGemMultiToken.TokenType.CLAIM)\n                claims[claimLen++] = claimHash;\n            else if (tokenType == INFTGemMultiToken.TokenType.GEM)\n                gems[gemLen++] = claimHash;\n        }\n    }\n}\n"
    },
    "src/interfaces/ITokenPoolQuerier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITokenPoolQuerier {\n    function getOwnedTokens(\n        address gemPool,\n        address multitoken,\n        address account,\n        uint256 page,\n        uint256 count\n    ) external view returns (uint256[] memory claims, uint256[] memory gems);\n}\n"
    },
    "src/fees/NFTGemFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../access/Controllable.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\ncontract NFTGemFeeManager is Controllable, INFTGemFeeManager {\n    address private operator;\n\n    uint256 public constant MINIMUM_LIQUIDITY_HASH =\n        uint256(keccak256(\"min_liquidity\"));\n    uint256 public constant POOL_FEE_HASH =\n        uint256(keccak256(abi.encodePacked(\"pool_fee\")));\n    uint256 public constant WRAP_GEM_HASH =\n        uint256(keccak256(abi.encodePacked(\"wrap_gem\")));\n    uint256 public constant FLASH_LOAN_HASH =\n        uint256(keccak256(abi.encodePacked(\"flash_loan\")));\n\n    uint256 private constant MINIMUM_LIQUIDITY = 50;\n    uint256 private constant POOL_FEE = 2000;\n    uint256 private constant WRAP_GEM = 2000;\n    uint256 private constant FLASH_LOAN = 10000;\n\n    mapping(uint256 => uint256) private fees;\n\n    /**\n     * @dev constructor\n     */\n    constructor() {\n        _addController(msg.sender);\n        fees[MINIMUM_LIQUIDITY_HASH] = MINIMUM_LIQUIDITY;\n        fees[POOL_FEE_HASH] = POOL_FEE;\n        fees[WRAP_GEM_HASH] = WRAP_GEM;\n        fees[FLASH_LOAN_HASH] = FLASH_LOAN;\n    }\n\n    /**\n     * @dev receive funds\n     */\n    receive() external payable {\n        //\n    }\n\n    /**\n     * @dev Get the fee divisor for the specified token\n     */\n    function fee(uint256 feeHash)\n        external\n        view\n        override\n        returns (uint256 feeRet)\n    {\n        feeRet = fees[feeHash];\n    }\n\n    /**\n     * @dev Set the fee divisor for the specified token\n     */\n    function setFee(uint256 feeHash, uint256 _fee)\n        external\n        override\n        onlyController\n    {\n        fees[feeHash] = _fee;\n        emit FeeChanged(operator, feeHash, _fee);\n    }\n\n    /**\n     * @dev get the balance of this fee manager. Pass a zero address in for FTM balance\n     */\n    function balanceOf(address token) external view override returns (uint256) {\n        return\n            token == address(0)\n                ? address(this).balance\n                : IERC20(token).balanceOf(address(this));\n    }\n\n    /**\n     * @dev transfer ETH from this contract to the to given recipient\n     */\n    function transferEth(address payable recipient, uint256 amount)\n        external\n        override\n        onlyController\n    {\n        recipient.transfer(amount);\n    }\n\n    /**\n     * @dev transfer tokens from this contract to the to given recipient\n     */\n    function transferToken(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external override onlyController {\n        IERC20(token).transfer(recipient, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/tokens/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @dev a test token for whatever. mints 1m tokens to caller\n */\ncontract TestToken is ERC20 {\n    constructor(string memory symbol, string memory name) ERC20(symbol, name) {\n        _mint(msg.sender, 1000000 ether);\n    }\n}\n"
    },
    "src/factories/ERC20GemTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"../tokens/ERC20WrappedGem.sol\";\n\nimport \"../interfaces/IERC20GemTokenFactory.sol\";\nimport \"../interfaces/IERC20WrappedGem.sol\";\n\ncontract ERC20GemTokenFactory is IERC20GemTokenFactory {\n    address private operator;\n\n    mapping(uint256 => address) private _getItem;\n    address[] private _allItems;\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function getItem(uint256 _symbolHash)\n        external\n        view\n        override\n        returns (address gemPool)\n    {\n        gemPool = _getItem[_symbolHash];\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function items() external view override returns (address[] memory) {\n        return _allItems;\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function allItems(uint256 idx)\n        external\n        view\n        override\n        returns (address gemPool)\n    {\n        gemPool = _allItems[idx];\n    }\n\n    /**\n     * @dev number of quantized addresses\n     */\n    function allItemsLength() external view override returns (uint256) {\n        return _allItems.length;\n    }\n\n    /**\n     * @dev deploy a new erc20 token using create2\n     */\n    function createItem(\n        string memory tokenSymbol,\n        string memory tokenName,\n        address poolAddress,\n        address tokenAddress,\n        uint8 decimals,\n        address feeManager\n    ) external override returns (address payable gemToken) {\n        bytes32 salt = keccak256(abi.encodePacked(tokenSymbol));\n        require(_getItem[uint256(salt)] == address(0), \"GEMTOKEN_EXISTS\"); // single check is sufficient\n        require(poolAddress != address(0), \"INVALID_POOL\");\n\n        // create the quantized erc20 token using create2, which lets us determine the\n        // quantized erc20 address of a token without interacting with the contract itself\n        bytes memory bytecode = type(ERC20WrappedGem).creationCode;\n\n        // use create2 to deploy the quantized erc20 contract\n        gemToken = payable(Create2.deploy(0, salt, bytecode));\n\n        // initialize the erc20 contract with the relevant addresses which it proxies\n        IERC20WrappedGem(gemToken).initialize(\n            tokenName,\n            tokenSymbol,\n            poolAddress,\n            tokenAddress,\n            decimals,\n            feeManager\n        );\n\n        // insert the erc20 contract address into lists - one that maps source to quantized,\n        _getItem[uint256(salt)] = gemToken;\n        _allItems.push(gemToken);\n\n        // emit an event about the new pool being created\n        emit ERC20GemTokenCreated(\n            gemToken,\n            poolAddress,\n            tokenSymbol,\n            ERC20(gemToken).symbol()\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "src/interfaces/IERC20GemTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface IERC20GemTokenFactory {\n    /**\n     * @dev emitted when a new gem pool has been added to the system\n     */\n    event ERC20GemTokenCreated(\n        address tokenAddress,\n        address poolAddress,\n        string tokenSymbol,\n        string poolSymbol\n    );\n\n    function getItem(uint256 _symbolHash) external view returns (address);\n\n    function items() external view returns (address[] memory);\n\n    function allItems(uint256 idx) external view returns (address);\n\n    function allItemsLength() external view returns (uint256);\n\n    function createItem(\n        string memory tokenSymbol,\n        string memory tokenName,\n        address poolAddress,\n        address tokenAddress,\n        uint8 decimals,\n        address feeManager\n    ) external returns (address payable);\n}\n"
    },
    "src/factories/NFTGemPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"../interfaces/IControllable.sol\";\nimport \"../pool/NFTComplexGemPool.sol\";\nimport \"../pool/ComplexPoolLib.sol\";\n\nimport \"../interfaces/INFTGemPoolFactory.sol\";\n\ncontract NFTGemPoolFactory is INFTGemPoolFactory {\n    mapping(uint256 => address) private _getNFTGemPool;\n    address[] private _allNFTGemPools;\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function getNFTGemPool(uint256 _symbolHash)\n        external\n        view\n        override\n        returns (address gemPool)\n    {\n        gemPool = _getNFTGemPool[_symbolHash];\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function nftGemPools() external view override returns (address[] memory) {\n        return _allNFTGemPools;\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function allNFTGemPools(uint256 idx)\n        external\n        view\n        override\n        returns (address gemPool)\n    {\n        gemPool = _allNFTGemPools[idx];\n    }\n\n    /**\n     * @dev number of quantized addresses\n     */\n    function allNFTGemPoolsLength() external view override returns (uint256) {\n        return _allNFTGemPools.length;\n    }\n\n    /**\n     * @dev deploy a new erc20 token using create2\n     */\n    function createNFTGemPool(\n        address owner,\n        string memory gemSymbol,\n        string memory gemName,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    ) external override returns (address payable gemPool) {\n        // create the lookup hash for the given symbol\n        // and check if it already exists\n        bytes32 salt = keccak256(abi.encodePacked(gemSymbol));\n        require(_getNFTGemPool[uint256(salt)] == address(0), \"GEMPOOL_EXISTS\"); // single check is sufficient\n\n        // validation checks to make sure values are sane\n        require(ethPrice != 0, \"INVALID_PRICE\");\n        require(minTime != 0, \"INVALID_MIN_TIME\");\n        require(diffstep != 0, \"INVALID_DIFFICULTY_STEP\");\n\n        // create the gem pool using create2, which lets us determine the\n        // address of a gem pool without interacting with the contract itself\n        bytes memory bytecode = type(NFTComplexGemPool).creationCode;\n\n        // use create2 to deploy the gem pool contract\n        gemPool = payable(Create2.deploy(0, salt, bytecode));\n\n        // set the controller of the gem pool\n        IControllable(gemPool).addController(owner);\n\n        // initialize the erc20 contract with the relevant addresses which it proxies\n        NFTComplexGemPool(gemPool).initialize(\n            gemSymbol,\n            gemName,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxMint,\n            allowedToken\n        );\n\n        // insert the erc20 contract address into lists\n        _getNFTGemPool[uint256(salt)] = gemPool;\n        _allNFTGemPools.push(gemPool);\n\n        // emit an event about the new pool being created\n        emit NFTGemPoolCreated(\n            gemPool,\n            gemSymbol,\n            gemName,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxMint,\n            allowedToken\n        );\n    }\n}\n"
    },
    "src/swap/uniswap/UniswapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./UniswapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\nimport \"../../access/Controllable.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract UniswapQueryHelper is ISwapQueryHelper, Controllable {\n    address private customFactory;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return UniswapLib.ethQuote(token, tokenAmount);\n    }\n\n    function __factory() internal view returns (address fac) {\n        fac = customFactory != address(0)\n            ? customFactory\n            : UniswapLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external view override returns (address fac) {\n        fac = __factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = UniswapLib.WETH();\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        override\n        returns (address pair)\n    {\n        pair = UniswapLib.getPair(__factory(), tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = UniswapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return UniswapLib.hasPool(token);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        return UniswapLib.getPathForETHToToken(token);\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address f) external override onlyController {\n        customFactory = f;\n    }\n}\n"
    },
    "src/swap/uniswap/UniswapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary UniswapLib {\n    address public constant UNISWAP_ROUTER_ADDRESS =\n        0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function ethQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        (tokenReserve, ethReserve, ) = IUniswapV2Pair(_pair).getReserves();\n        ethereum = quote(tokenAmount, tokenReserve, ethReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WETH() external pure returns (address weth) {\n        weth = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair = IUniswapV2Factory(_factory).getPair(tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB, ) = IUniswapV2Pair(pair).getReserves();\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForETHToToken(address token)\n        external\n        pure\n        returns (address[] memory)\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "src/swap/sushiswap/SushiSwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary SushiSwapLib {\n    address public constant UNISWAP_ROUTER_ADDRESS =\n        0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function ethQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        (tokenReserve, ethReserve, ) = IUniswapV2Pair(_pair).getReserves();\n        ethereum = quote(tokenAmount, tokenReserve, ethReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WETH() external pure returns (address weth) {\n        weth = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair = IUniswapV2Factory(_factory).getPair(tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB, ) = IUniswapV2Pair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForETHToToken(address token)\n        external\n        pure\n        returns (address[] memory)\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\n            UNISWAP_ROUTER_ADDRESS\n        );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "src/swap/sushiswap/SushiSwapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./SushiSwapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\nimport \"../../access/Controllable.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract SushiSwapQueryHelper is ISwapQueryHelper, Controllable {\n    address private customFactory;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return SushiSwapLib.ethQuote(token, tokenAmount);\n    }\n\n    function __factory() internal view returns (address fac) {\n        fac = customFactory != address(0)\n            ? customFactory\n            : SushiSwapLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external view override returns (address fac) {\n        fac = __factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = SushiSwapLib.WETH();\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        override\n        returns (address pair)\n    {\n        pair = SushiSwapLib.getPair(__factory(), tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = SushiSwapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return SushiSwapLib.hasPool(token);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        return SushiSwapLib.getPathForETHToToken(token);\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address f) external override onlyController {\n        customFactory = f;\n    }\n}\n"
    },
    "src/swap/pangolin/PangolinQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./PangolinLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\nimport \"../../access/Controllable.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract PangolinQueryHelper is ISwapQueryHelper, Controllable {\n    address private _routerAddress;\n\n    address public constant PANGOLIN_ROUTER_ADDRESS =\n        0xefa94DE7a4656D787667C749f7E1223D71E9FD88;\n    address public constant FUJI_PANGOLIN_ROUTER_ADDRESS =\n        0xE4A575550C2b460d2307b82dCd7aFe84AD1484dd;\n\n    constructor() {\n        _routerAddress = PANGOLIN_ROUTER_ADDRESS;\n    }\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return PangolinLib.avaxQuote(token, tokenAmount);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = PangolinLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = PangolinLib.WAVAX();\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return PangolinLib.hasPool(token);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        override\n        returns (address pair)\n    {\n        address _factory = PangolinLib.factory();\n        pair = PangolinLib.getPair(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = PangolinLib.getReserves(pair);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        return PangolinLib.getPathForAVAXoToken(token);\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address) external override {}\n}\n"
    },
    "src/swap/pangolin/PangolinLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\";\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinFactory.sol\";\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinPair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary PangolinLib {\n    address public constant PANGOLIN_ROUTER_ADDRESS =\n        0xefa94DE7a4656D787667C749f7E1223D71E9FD88;\n    address public constant FUJI_PANGOLIN_ROUTER_ADDRESS =\n        0xE4A575550C2b460d2307b82dCd7aFe84AD1484dd;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function avaxQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 avalanche,\n            uint256 tokenReserve,\n            uint256 avaxReserve\n        )\n    {\n        IPangolinRouter uniswapRouter = IPangolinRouter(\n            PANGOLIN_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WAVAX = uniswapRouter.WAVAX();\n        address _pair = IPangolinFactory(_factory).getPair(token, _WAVAX);\n        (tokenReserve, avaxReserve, ) = IPangolinPair(_pair).getReserves();\n        avalanche = quote(tokenAmount, tokenReserve, avaxReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WAVAX() external pure returns (address wavax) {\n        wavax = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS).WAVAX();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IPangolinRouter uniswapRouter = IPangolinRouter(\n            PANGOLIN_ROUTER_ADDRESS\n        );\n        address _factory = uniswapRouter.factory();\n        address _WAVAX = uniswapRouter.WAVAX();\n        address _pair = IPangolinFactory(_factory).getPair(token, _WAVAX);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs wavax\n     */\n    function getPair(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair = IPangolinFactory(_factory).getPair(tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB, ) = IPangolinPair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"40231f6b438bce0797c9ada29b718a87ea0a5cea3fe9a771abdd76bd41a3e545\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for avalanche to the given token\n     */\n    function getPathForAVAXoToken(address token)\n        external\n        pure\n        returns (address[] memory)\n    {\n        IPangolinRouter uniswapRouter = IPangolinRouter(\n            PANGOLIN_ROUTER_ADDRESS\n        );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WAVAX();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IPangolinRouter {\n    function factory() external pure returns (address);\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountAVAX);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPangolinFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinPair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPangolinPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/swap/pancakeswap/PancakeSwapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"./PancakeSwapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract PancakeSwapQueryHelper is ISwapQueryHelper {\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return PancakeSwapLib.coinQuote(token, tokenAmount);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = PancakeSwapLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = PancakeSwapLib.COIN();\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return PancakeSwapLib.hasPool(token);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        override\n        returns (address pair)\n    {\n        address _factory = PancakeSwapLib.factory();\n        pair = PancakeSwapLib.getPair(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = PancakeSwapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        return PancakeSwapLib.getPathForCoinToToken(token);\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address) external override {}\n}\n"
    },
    "src/swap/pancakeswap/PancakeSwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol\";\nimport \"@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakeFactory.sol\";\nimport \"@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol\";\n\n/**\n * @dev pancake helpers\n */\nlibrary PancakeSwapLib {\n    address public constant PANCAKE_ROUTER_ADDRESS =\n        0xBCfCcbde45cE874adCB698cC183deBcF17952812;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 coin,\n            uint256 tokenReserve,\n            uint256 coinReserve\n        )\n    {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\n            PANCAKE_ROUTER_ADDRESS\n        );\n        address _factory = pancakeRouter.factory();\n        address _COIN = pancakeRouter.WETH();\n        address _pair = IPancakeFactory(_factory).getPair(token, _COIN);\n        (tokenReserve, coinReserve, ) = IPancakePair(_pair).getReserves();\n        coin = quote(tokenAmount, tokenReserve, coinReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure returns (address wavax) {\n        wavax = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\n            PANCAKE_ROUTER_ADDRESS\n        );\n        address _factory = pancakeRouter.factory();\n        address _WAVAX = pancakeRouter.WETH();\n        address _pair = IPancakeFactory(_factory).getPair(token, _WAVAX);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs wavax\n     */\n    function getPair(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair = IPancakeFactory(_factory).getPair(tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address pair)\n        external\n        view\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB, ) = IPancakePair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            _factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"d0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for coin to the given token\n     */\n    function getPathForCoinToToken(address token)\n        external\n        pure\n        returns (address[] memory)\n    {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(\n            PANCAKE_ROUTER_ADDRESS\n        );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = pancakeRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\nimport './IPancakeRouter01.sol';\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
    },
    "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakeFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "pancakeswap-peripheral/contracts/interfaces/IPancakeRouter01.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n"
    },
    "src/swap/mock/MockQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/ISwapQueryHelper.sol\";\n\n/**\n * @dev Mock helper for local network\n */\ncontract MockQueryHelper is ISwapQueryHelper {\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address, uint256 tokenAmount)\n        external\n        pure\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        return (tokenAmount / (10), tokenAmount * (200), tokenAmount * (20));\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = address(0);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = address(99);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address, address)\n        external\n        pure\n        override\n        returns (address pair)\n    {\n        pair = address(0);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(address)\n        external\n        pure\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = (0, 0);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address) external pure override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address)\n        external\n        pure\n        override\n        returns (address[] memory)\n    {\n        address[] memory _mock;\n        return _mock;\n    }\n\n    /**\n     * @dev set factory\n     */\n    function setFactory(address) external override {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}