{
  "language": "Solidity",
  "sources": {
    "src/access/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IControllable.sol\";\n\nabstract contract Controllable is IControllable {\n    mapping(address => bool) _controllers;\n\n    /**\n     * @dev Throws if called by any account not in authorized list\n     */\n    modifier onlyController() {\n        require(\n            _controllers[msg.sender] == true || address(this) == msg.sender,\n            \"Controllable: caller is not a controller\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Add an address allowed to control this contract\n     */\n    function _addController(address _controller) internal {\n        _controllers[_controller] = true;\n    }\n\n    /**\n     * @dev Add an address allowed to control this contract\n     */\n    function addController(address _controller) external override onlyController {\n        _controllers[_controller] = true;\n    }\n\n    /**\n     * @dev Check if this address is a controller\n     */\n    function isController(address _address) external view override returns (bool allowed) {\n        allowed = _controllers[_address];\n    }\n\n    /**\n     * @dev Check if this address is a controller\n     */\n    function relinquishControl() external view override onlyController {\n        _controllers[msg.sender];\n    }\n}\n"
    },
    "src/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface IControllable {\n    event ControllerAdded(address indexed contractAddress, address indexed controllerAddress);\n    event ControllerRemoved(address indexed contractAddress, address indexed controllerAddress);\n\n    function addController(address controller) external;\n\n    function isController(address controller) external view returns (bool);\n\n    function relinquishControl() external;\n}\n"
    },
    "src/tokens/NFTGemMultiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../libs/Strings.sol\";\nimport \"../libs/SafeMath.sol\";\nimport \"./ERC1155Pausable.sol\";\nimport \"./ERC1155Holder.sol\";\nimport \"../access/Controllable.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\n\ncontract OwnableDelegateProxy {}\n\ncontract ProxyRegistry {\n    mapping(address => OwnableDelegateProxy) public proxies;\n}\n\ncontract NFTGemMultiToken is ERC1155Pausable, ERC1155Holder, INFTGemMultiToken, Controllable {\n    using SafeMath for uint256;\n    using Strings for string;\n\n    // allows opensea to\n    address private constant OPENSEA_REGISTRY_ADDRESS = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\n    address[] private proxyRegistries;\n    address private registryManager;\n\n    mapping(uint256 => uint256) private _totalBalances;\n    mapping(address => mapping(uint256 => uint256)) private _tokenLocks;\n\n    mapping(address => uint256[]) private _heldTokens;\n    mapping(uint256 => address[]) private _tokenHolders;\n\n    /**\n     * @dev Contract initializer.\n     */\n    constructor() ERC1155(\"https://metadata.bitgem.co/\") {\n        _addController(msg.sender);\n        registryManager = msg.sender;\n        proxyRegistries.push(OPENSEA_REGISTRY_ADDRESS);\n    }\n\n    function lock(uint256 token, uint256 timestamp) external override {\n        require(_tokenLocks[_msgSender()][token] < timestamp, \"ALREADY_LOCKED\");\n        _tokenLocks[_msgSender()][timestamp] = timestamp;\n    }\n\n    function unlockTime(address account, uint256 token) external view override returns (uint256 theTime) {\n        theTime = _tokenLocks[account][token];\n    }\n\n    /**\n     * @dev Returns the metadata URI for this token type\n     */\n    function uri(uint256 _id) public view override(ERC1155) returns (string memory) {\n        require(_totalBalances[_id] != 0, \"NFTGemMultiToken#uri: NONEXISTENT_TOKEN\");\n        return Strings.strConcat(ERC1155Pausable(this).uri(_id), Strings.uint2str(_id));\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function allHeldTokens(address holder, uint256 _idx) external view override returns (uint256) {\n        return _heldTokens[holder][_idx];\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function allHeldTokensLength(address holder) external view override returns (uint256) {\n        return _heldTokens[holder].length;\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function allTokenHolders(uint256 _token, uint256 _idx) external view override returns (address) {\n        return _tokenHolders[_token][_idx];\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function allTokenHoldersLength(uint256 _token) external view override returns (uint256) {\n        return _tokenHolders[_token].length;\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function totalBalances(uint256 _id) external view override returns (uint256) {\n        return _totalBalances[_id];\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function allProxyRegistries(uint256 _idx) external view override returns (address) {\n        return proxyRegistries[_idx];\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function getRegistryManager() external view override returns (address) {\n        return registryManager;\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function setRegistryManager(address newManager) external override {\n        require(msg.sender == registryManager, \"UNAUTHORIZED\");\n        require(newManager != address(0), \"UNAUTHORIZED\");\n        registryManager = newManager;\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function allProxyRegistriesLength() external view override returns (uint256) {\n        return proxyRegistries.length;\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function addProxyRegistry(address registry) external override {\n        require(msg.sender == registryManager, \"UNAUTHORIZED\");\n        proxyRegistries.push(registry);\n    }\n\n    /**\n     * @dev Returns the total balance minted of this type\n     */\n    function removeProxyRegistryAt(uint256 index) external override {\n        require(msg.sender == registryManager, \"UNAUTHORIZED\");\n        require(index < proxyRegistries.length, \"INVALID_INDEX\");\n        proxyRegistries[index] = proxyRegistries[proxyRegistries.length - 1];\n        delete proxyRegistries[proxyRegistries.length - 1];\n    }\n\n    /**\n     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.\n     */\n    function isApprovedForAll(address _owner, address _operator) public view override returns (bool isOperator) {\n        // Whitelist OpenSea proxy contract for easy trading.\n        for(uint256 i = 0; i < proxyRegistries.length; i++) {\n            ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistries[i]);\n            if (address(proxyRegistry.proxies(_owner)) == _operator) {\n                return true;\n            }\n        }\n        return ERC1155.isApprovedForAll(_owner, _operator);\n    }\n\n    /**\n     * @dev mint some amount of tokens. Only callable by token owner\n     */\n    function mint(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external override onlyController {\n        _mint(account, uint256(tokenHash), amount, \"0x0\");\n    }\n\n    /**\n     * @dev internal mint overridden to manage token holders and held tokens lists\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n        super._mint(account, id, amount, data);\n    }\n\n    /**\n     * @dev internal minttbatch should account for managing lists\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._mintBatch(to, ids, amounts, data);\n    }\n\n    /**\n     * @dev mint some amount of tokens. Only callable by token owner\n     */\n    function burn(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external override onlyController {\n        _burn(account, uint256(tokenHash), amount);\n    }\n\n    /**\n     * @dev internal burn overridden to track lists\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual override {\n        super._burn(account, id, amount);\n    }\n\n    /**\n     * @dev internal burnBatch should account for managing lists\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual override {\n        super._burnBatch(account, ids, amounts);\n    }\n\n    /**\n     * @dev intercepting token transfers to manage a list of zero-token holders\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            // prevent send if tokens are locked\n            if (from != address(0)) {\n                require(_tokenLocks[from][ids[i]] <= block.timestamp, \"TOKEN_LOCKED\");\n            }\n\n            // if this is not a mint then remove the held token id from lists if\n            // this is the last token if this type the sender owns\n            if (from != address(0) && balanceOf(from, ids[i]) - amounts[i] == 0) {\n                // remove from heldTokens\n                for (uint256 j = 0; j < _heldTokens[from].length; j++) {\n                    if (_heldTokens[from][j] == ids[i]) {\n                        _heldTokens[from][j] = _heldTokens[from][_heldTokens[from].length - 1];\n                        delete _heldTokens[from][_heldTokens[from].length - 1];\n                    }\n                }\n                // remove from tokenHolders\n                for (uint256 j = 0; j < _tokenHolders[ids[i]].length; j++) {\n                    if (_tokenHolders[ids[i]][j] == from) {\n                        _tokenHolders[ids[i]][j] = _tokenHolders[ids[i]][_tokenHolders[ids[i]].length - 1];\n                        delete _tokenHolders[ids[i]][_tokenHolders[ids[i]].length - 1];\n                    }\n                }\n            }\n\n            // if this is not a burn and receiver does not yet own token then\n            // add that account to the token for that id\n            if (to != address(0) && balanceOf(to, ids[i]) == 0) {\n                _heldTokens[to].push(ids[i]);\n                _tokenHolders[ids[i]].push(to);\n            }\n\n            // inc and dec balances for each token type\n            if (from == address(0)) {\n                _totalBalances[uint256(ids[i])] = _totalBalances[uint256(ids[i])].add(amounts[i]);\n            }\n            if (to == address(0)) {\n                _totalBalances[uint256(ids[i])] = _totalBalances[uint256(ids[i])].sub(amounts[i]);\n            }\n        }\n    }\n}\n"
    },
    "src/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nlibrary Strings {\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d,\n        string memory _e\n    ) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint256 k = 0;\n        for (uint256 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (uint256 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (uint256 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (uint256 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (uint256 i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "src/libs/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "src/tokens/ERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./ERC1155.sol\";\nimport \"../utils/Pausable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "src/tokens/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "src/interfaces/INFTGemMultiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface INFTGemMultiToken {\n    // called by controller to mint a claim or a gem\n    function mint(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external;\n\n    // called by controller to burn a claim\n    function burn(\n        address account,\n        uint256 tokenHash,\n        uint256 amount\n    ) external;\n\n    function allHeldTokens(address holder, uint256 _idx) external view returns (uint256);\n\n    function allHeldTokensLength(address holder) external view returns (uint256);\n\n    function allTokenHolders(uint256 _token, uint256 _idx) external view returns (address);\n\n    function allTokenHoldersLength(uint256 _token) external view returns (uint256);\n\n    function totalBalances(uint256 _id) external view returns (uint256);\n\n    function allProxyRegistries(uint256 _idx) external view returns (address);\n\n    function allProxyRegistriesLength() external view returns (uint256);\n\n    function addProxyRegistry(address registry) external;\n\n    function removeProxyRegistryAt(uint256 index) external;\n\n    function getRegistryManager() external view returns (address);\n\n    function setRegistryManager(address newManager) external;\n\n    function lock(uint256 token, uint256 timeframe) external;\n\n    function unlockTime(address account, uint256 token) external view returns (uint256);\n}\n"
    },
    "src/tokens/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/IERC1155MetadataURI.sol\";\nimport \"../interfaces//IERC1155Receiver.sol\";\nimport \"../utils/Context.sol\";\nimport \"../introspection/ERC165.sol\";\nimport \"../libs/SafeMath.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) internal _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(amount, \"ERC1155: burn amount exceeds balance\");\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) internal pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "src/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "src/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/interfaces/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "src/interfaces/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "src/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "src/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor() {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "src/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/tokens/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IERC1155Receiver.sol\";\nimport \"../introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    constructor() {\n        _registerInterface(\n            ERC1155Receiver(address(0)).onERC1155Received.selector ^\n                ERC1155Receiver(address(0)).onERC1155BatchReceived.selector\n        );\n    }\n}\n"
    },
    "src/tokens/ERC20WrappedGem.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../libs/SafeMath.sol\";\nimport \"./ERC20.sol\";\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/INFTGemPoolData.sol\";\nimport \"../interfaces/IERC20WrappedGem.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\n\nimport \"./ERC1155Holder.sol\";\n\ncontract ERC20WrappedGem is ERC20, ERC1155Holder, IERC20WrappedGem {\n    using SafeMath for uint256;\n\n    address private token;\n    address private pool;\n    uint256 private rate;\n\n    uint256[] private ids;\n    uint256[] private amounts;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address gemPool,\n        address gemToken,\n        uint8 decimals\n    ) ERC20(name, symbol) {\n        token = gemToken;\n        pool = gemPool;\n        _setupDecimals(decimals);\n    }\n\n    function _transferERC1155(address from, address to, uint256 quantity) internal {\n\n        uint256 tq = quantity;\n        delete ids;\n        delete amounts;\n\n        for(uint256 i = 0; i < INFTGemMultiToken(token).allHeldTokensLength(from) && tq > 0; i = i.add(1)) {\n            uint256 tokenHash = INFTGemMultiToken(token).allHeldTokens(msg.sender, i);\n            if(INFTGemPoolData(pool).tokenType(tokenHash) == 2) {\n                uint256 oq = IERC1155(token).balanceOf(msg.sender, tokenHash);\n                uint256 toTransfer = oq > tq ? tq : oq;\n                ids.push(tokenHash);\n                amounts.push(toTransfer);\n                tq = tq.sub(toTransfer);\n            }\n        }\n\n        require(tq == 0, \"INSUFFICIENT_GEMS\");\n\n        IERC1155(token).safeBatchTransferFrom(from, to, ids, amounts, \"\");\n\n    }\n\n    function wrap(uint256 quantity) external override {\n\n        require(quantity != 0, \"ZERO_QUANTITY\");\n\n        _transferERC1155(msg.sender, address(this), quantity);\n        _mint(msg.sender, quantity.mul(10 ** decimals()));\n        emit Wrap(msg.sender, quantity);\n\n    }\n\n    function unwrap(uint256 quantity) external override {\n\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(balanceOf(msg.sender).mul(10 ** decimals()) >= quantity, \"INSUFFICIENT_QUANTITY\");\n\n        _transferERC1155(address(this), msg.sender, quantity);\n        _burn(msg.sender, quantity.mul(10 ** decimals()));\n        emit Unwrap(msg.sender, quantity);\n\n    }\n}\n"
    },
    "src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../utils/Context.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../libs/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/interfaces/INFTGemPoolData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface INFTGemPoolData {\n\n    // pool is inited with these parameters. Once inited, all\n    // but ethPrice are immutable. ethPrice only increases. ONLY UP\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function ethPrice() external view returns (uint256);\n    function minTime() external view returns (uint256);\n    function maxTime() external view returns (uint256);\n    function difficultyStep() external view returns (uint256);\n    function maxClaims() external view returns (uint256);\n\n    // these describe the pools created contents over time. This is where\n    // you query to get information about a token that a pool created\n    function claimedCount() external view returns (uint256);\n    function claimAmount(uint256 claimId) external view returns (uint256);\n    function claimQuantity(uint256 claimId) external view returns (uint256);\n    function mintedCount() external view returns (uint256);\n    function totalStakedEth() external view returns (uint256);\n    function tokenId(uint256 tokenHash) external view returns (uint256);\n    function tokenType(uint256 tokenHash) external view returns (uint8);\n    function allTokenHashesLength() external view returns (uint256);\n    function allTokenHashes(uint256 ndx) external view returns (uint256);\n    function nextClaimHash() external view returns (uint256);\n    function nextGemHash() external view returns (uint256);\n    function nextGemId() external view returns (uint256);\n    function nextClaimId() external view returns (uint256);\n\n    function claimUnlockTime(uint256 claimId) external view returns (uint256);\n    function claimTokenAmount(uint256 claimId) external view returns (uint256);\n    function stakedToken(uint256 claimId) external view returns (address);\n\n    function allowedTokensLength() external view returns (uint256);\n    function allowedTokens(uint256 idx) external view returns (address);\n    function isTokenAllowed(address token) external view returns (bool);\n    function addAllowedToken(address token) external;\n    function removeAllowedToken(address token) external;\n}\n"
    },
    "src/interfaces/IERC20WrappedGem.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20WrappedGem {\n\n    function wrap(uint256 quantity) external;\n    function unwrap(uint256 quantity) external;\n\n    event Wrap(address indexed account, uint256 quantity);\n    event Unwrap(address indexed account, uint256 quantity);\n\n}\n"
    },
    "src/tokens/ERC20WrappedERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../libs/SafeMath.sol\";\nimport \"./ERC20.sol\";\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"./ERC1155Holder.sol\";\n\ncontract ERC20WrappedERC1155 is ERC20, ERC1155Holder {\n    using SafeMath for uint256;\n\n    address private token;\n    uint256 private index;\n    uint256 private rate;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address erc1155Token,\n        uint256 tokenIndex,\n        uint256 exchangeRate\n    ) ERC20(name, symbol) {\n        token = erc1155Token;\n        index = tokenIndex;\n        rate = exchangeRate;\n        _setupDecimals(decimals);\n    }\n\n    function wrap(uint256 quantity) external {\n\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(IERC1155(token).balanceOf(msg.sender, index) >= quantity, \"INSUFFICIENT_ERC1155_BALANCE\");\n\n        IERC1155(token).safeTransferFrom(msg.sender, address(this), index, quantity, \"\");\n        _mint(msg.sender, quantity.mul(rate));\n\n    }\n\n    function unwrap(uint256 quantity) external {\n\n        require(quantity != 0, \"ZERO_QUANTITY\");\n        require(balanceOf(msg.sender) >= quantity.mul(rate), \"INSUFFICIENT_ERC20_BALANCE\");\n\n        _burn(msg.sender, quantity.mul(rate));\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, index, quantity, \"\");\n\n    }\n}\n"
    },
    "src/tokens/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    constructor(string memory symbol, string memory name) ERC20(symbol, name) {\n        _mint(msg.sender, 1000000 ether);\n    }\n}\n"
    },
    "src/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "src/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24;\n\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "src/governance/NFTGemGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../access/Controllable.sol\";\nimport \"../utils/Initializable.sol\";\n\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/IProposalFactory.sol\";\nimport \"../interfaces/IProposal.sol\";\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/INFTGemPoolFactory.sol\";\nimport \"../interfaces/INFTGemPool.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\nimport \"../interfaces/IProposalData.sol\";\n\nimport \"../libs/SafeMath.sol\";\nimport \"../governance/GovernanceLib.sol\";\nimport \"../governance/ProposalsLib.sol\";\n\nimport \"hardhat/console.sol\";\n\n\ncontract NFTGemGovernor is Initializable, Controllable, INFTGemGovernor {\n    using SafeMath for uint256;\n\n    address private multitoken;\n    address private factory;\n    address private feeTracker;\n    address private proposalFactory;\n    address private swapHelper;\n\n    uint256 private constant GOVERNANCE = 0;\n    uint256 private constant FUEL = 1;\n    uint256 private constant GOV_TOKEN_INITIAL = 500000;\n    uint256 private constant GOV_TOKEN_MAX     = 1000000;\n\n    bool private governanceIssued;\n\n    /**\n     * @dev contract controller\n     */\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /**\n     * @dev init this smart contract\n     */\n    function initialize(\n        address _multitoken,\n        address _factory,\n        address _feeTracker,\n        address _proposalFactory,\n        address _swapHelper\n    ) external override initializer {\n        multitoken = _multitoken;\n        factory = _factory;\n        feeTracker = _feeTracker;\n        proposalFactory = _proposalFactory;\n        swapHelper = _swapHelper;\n    }\n\n    /**\n     * @dev create proposal vote tokens\n     */\n    function createProposalVoteTokens(uint256 proposalHash) external override onlyController {\n        GovernanceLib.createProposalVoteTokens(multitoken, proposalHash);\n    }\n\n    /**\n     * @dev destroy proposal vote tokens\n     */\n    function destroyProposalVoteTokens(uint256 proposalHash) external override onlyController {\n        GovernanceLib.destroyProposalVoteTokens(multitoken, proposalHash);\n    }\n\n    /**\n     * @dev execute proposal\n     */\n    function executeProposal(address propAddress) external override onlyController {\n        ProposalsLib.executeProposal(multitoken, factory, address(this), feeTracker, swapHelper, propAddress);\n    }\n\n    /**\n     * @dev issue initial governance tokens\n     */\n    function issueInitialGovernanceTokens(address receiver) external override returns (uint256) {\n        require(!governanceIssued, \"ALREADY_ISSUED\");\n        INFTGemMultiToken(multitoken).mint(receiver, GOVERNANCE, GOV_TOKEN_INITIAL);\n        governanceIssued = true;\n        emit GovernanceTokenIssued(receiver, GOV_TOKEN_INITIAL);\n    }\n\n    /**\n     * @dev maybe issue a governance token to receiver\n     */\n    function maybeIssueGovernanceToken(address receiver) external override onlyController returns (uint256) {\n        uint256 totalSupplyOf = INFTGemMultiToken(multitoken).totalBalances(GOVERNANCE);\n        if (totalSupplyOf >= GOV_TOKEN_MAX) {\n            return 0;\n        }\n        INFTGemMultiToken(multitoken).mint(receiver, GOVERNANCE, 1);\n        emit GovernanceTokenIssued(receiver, 1);\n    }\n\n    /**\n     * @dev shhh\n     */\n    function issueFuelToken(address receiver, uint256 amount) external override onlyController returns (uint256) {\n        INFTGemMultiToken(multitoken).mint(receiver, FUEL, amount);\n    }\n\n    /**\n     * @dev create a new pool - public, only callable by a controller of this contract\n     */\n    function createSystemPool(\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external override onlyController returns (address pool) {\n        pool = GovernanceLib.createPool(\n            factory,\n            symbol,\n            name,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n            allowedToken\n        );\n        // associate the pool with its relations\n        associatePool(msg.sender, msg.sender, pool);\n    }\n\n    /**\n     * @dev associate the pool with its relations\n     */\n    function associatePool(\n        address creator,\n        address funder,\n        address pool\n    ) internal {\n        IControllable(multitoken).addController(pool);\n        IControllable(this).addController(pool);\n        INFTGemPool(pool).setMultiToken(multitoken);\n        INFTGemPool(pool).setSwapHelper(swapHelper);\n        INFTGemPool(pool).setGovernor(address(this));\n        INFTGemPool(pool).setFeeTracker(feeTracker);\n        INFTGemPool(pool).mintGenesisGems(creator, funder);\n    }\n\n    /**\n     * @dev create a new pool - public, only callable by a controller of this contract\n     */\n    function createPool(\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external override onlyController returns (address pool) {\n        pool = GovernanceLib.createPool(\n            factory,\n            symbol,\n            name,\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n            allowedToken\n        );\n        // associate the pool with its relations\n        associatePool(IProposal(pool).creator(), IProposal(pool).funder(), pool);\n    }\n\n    /**\n     * @dev create a proposal to create a new pool\n     */\n    function createNewPoolProposal(\n        address submitter,\n        string memory title,\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTIme,\n        uint256 maxTime,\n        uint256 diffStep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external override returns (address proposal) {\n        proposal = ProposalsLib.createNewPoolProposal(\n            symbol,\n            name,\n            ethPrice,\n            minTIme,\n            maxTime,\n            diffStep,\n            maxClaims,\n            allowedToken\n        );\n        ProposalsLib.associateProposal(\n            address(this),\n            multitoken,\n            proposalFactory,\n            submitter,\n            IProposal.ProposalType.CREATE_POOL,\n            title,\n            proposal\n        );\n    }\n\n    /**\n     * @dev create a proposal to change fees for a token / pool\n     */\n    function createChangeFeeProposal(\n        address submitter,\n        string memory title,\n        address token,\n        address pool,\n        uint256 feeDivisor\n    ) external override returns (address proposal) {\n        proposal = ProposalsLib.createChangeFeeProposal(token, pool, feeDivisor);\n        ProposalsLib.associateProposal(\n            address(this),\n            multitoken,\n            proposalFactory,\n            submitter,\n            IProposal.ProposalType.CHANGE_FEE,\n            title,\n            proposal\n        );\n    }\n\n    /**\n     * @dev create a proposal to craete a project funding proposal\n     */\n    function createFundProjectProposal(\n        address submitter,\n        string memory title,\n        address receiver,\n        string memory descriptionUrl,\n        uint256 ethAmount\n    ) external override returns (address proposal) {\n        proposal = ProposalsLib.createFundProjectProposal(receiver, descriptionUrl, ethAmount);\n        ProposalsLib.associateProposal(\n            address(this),\n            multitoken,\n            proposalFactory,\n            submitter,\n            IProposal.ProposalType.FUND_PROJECT,\n            title,\n            proposal\n        );\n    }\n\n    /**\n     * @dev create a proposal to update the allowlist of a token/pool\n     */\n    function createUpdateAllowlistProposal(\n        address submitter,\n        string memory title,\n        address token,\n        address pool,\n        bool newStatus\n    ) external override returns (address proposal) {\n        proposal = ProposalsLib.createUpdateAllowlistProposal(token, pool, newStatus);\n        ProposalsLib.associateProposal(\n            address(this),\n            multitoken,\n            proposalFactory,\n            submitter,\n            IProposal.ProposalType.UPDATE_ALLOWLIST,\n            title,\n            proposal\n        );\n    }\n}\n"
    },
    "src/interfaces/IProposalFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n\nimport \"./IProposal.sol\";\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface IProposalFactory {\n    /**\n     * @dev emitted when a new gem pool proposal has been added to the system\n     */\n    event ProposalCreated(address creator, uint256 proposalType, address proposal);\n\n    event ProposalFunded(uint256 indexed proposalHash, address indexed funder, uint256 expDate);\n\n    event ProposalExecuted(uint256 indexed proposalHash, address pool);\n\n    event ProposalClosed(uint256 indexed proposalHash, address pool);\n\n    function getProposal(uint256 _symbolHash) external view returns (address);\n\n    function allProposals(uint256 idx) external view returns (address);\n\n    function allProposalsLength() external view returns (uint256);\n\n    function createProposal(\n        address submitter,\n        string memory title,\n        address proposalData,\n        IProposal.ProposalType proposalType\n    ) external returns (address payable);\n}\n"
    },
    "src/interfaces/IProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface IProposal {\n    enum ProposalType {CREATE_POOL, FUND_PROJECT, CHANGE_FEE, UPDATE_ALLOWLIST, TRANSFER_POOL_FUNDS, CREATE_CUSTOM_POOL}\n\n    enum ProposalStatus {NOT_FUNDED, ACTIVE, PASSED, FAILED, EXECUTED, CLOSED}\n\n    event ProposalCreated(address creator, address pool, uint256 proposalHash);\n\n    event ProposalExecuted(uint256 proposalHash);\n\n    event ProposalClosed(uint256 proposalHash);\n\n    function creator() external view returns (address);\n\n    function title() external view returns (string memory);\n\n    function funder() external view returns (address);\n\n    function expiration() external view returns (uint256);\n\n    function status() external view returns (ProposalStatus);\n\n    function proposalData() external view returns (address);\n\n    function proposalType() external view returns (ProposalType);\n\n    function setMultiToken(address token) external;\n\n    function setGovernor(address gov) external;\n\n    function fund() external payable;\n\n    function execute() external;\n\n    function close() external;\n\n    function initialize(\n        address,\n        string memory,\n        address,\n        ProposalType\n    ) external;\n}\n"
    },
    "src/interfaces/INFTGemPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface INFTGemPoolFactory {\n    /**\n     * @dev emitted when a new gem pool has been added to the system\n     */\n    event NFTGemPoolCreated(\n        string gemSymbol,\n        string gemName,\n        uint256 ethPrice,\n        uint256 mintTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    );\n\n    /**\n     * @dev emitted when a new custom gem pool has been added to the system\n     */\n    event CustomNFTGemPoolCreated(\n        string gemSymbol,\n        string gemName\n    );\n\n    function getNFTGemPool(uint256 _symbolHash) external view returns (address);\n\n    function allNFTGemPools(uint256 idx) external view returns (address);\n\n    function allNFTGemPoolsLength() external view returns (uint256);\n\n    function createNFTGemPool(\n        string memory gemSymbol,\n        string memory gemName,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    ) external returns (address payable);\n\n    function createCustomNFTGemPool(\n        bytes memory bytecode,\n        string memory gemSymbol,\n        string memory gemName\n    ) external returns (address payable);\n\n\n}\n"
    },
    "src/interfaces/INFTGemPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Interface for a Bitgem staking pool\n */\ninterface INFTGemPool {\n\n    /**\n     * @dev Event generated when an NFT claim is created using ETH\n     */\n    event NFTGemClaimCreated(address account, address pool, uint256 claimHash, uint256 length, uint256 quantity, uint256 amountPaid);\n\n    /**\n     * @dev Event generated when an NFT claim is created using ERC20 tokens\n     */\n    event NFTGemERC20ClaimCreated(\n        address account,\n        address pool,\n        uint256 claimHash,\n        uint256 length,\n        address token,\n        uint256 quantity,\n        uint256 conversionRate\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is redeemed\n     */\n    event NFTGemClaimRedeemed(\n        address account,\n        address pool,\n        uint256 claimHash,\n        uint256 amountPaid,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when an NFT claim is redeemed\n     */\n    event NFTGemERC20ClaimRedeemed(\n        address account,\n        address pool,\n        uint256 claimHash,\n        address token,\n        uint256 ethPrice,\n        uint256 tokenAmount,\n        uint256 feeAssessed\n    );\n\n    /**\n     * @dev Event generated when a gem is created\n     */\n    event NFTGemCreated(address account, address pool, uint256 claimHash, uint256 gemHash, uint256 quantity);\n\n    function setMultiToken(address token) external;\n\n    function setGovernor(address addr) external;\n\n    function setFeeTracker(address addr) external;\n\n    function setSwapHelper(address addr) external;\n\n    function mintGenesisGems(address creator, address funder) external;\n\n    function createClaim(uint256 timeframe) external payable;\n\n    function createClaims(uint256 timeframe, uint256 count) external payable;\n\n    function createERC20Claim(address erc20token, uint256 tokenAmount) external;\n\n    function createERC20Claims(address erc20token, uint256 tokenAmount, uint256 count) external;\n\n    function collectClaim(uint256 claimHash) external;\n\n    function transferFunds(address token, address receiver, uint256 amount) external;\n\n    function initialize(\n        string memory,\n        string memory,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        address\n    ) external;\n}\n"
    },
    "src/interfaces/INFTGemGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface INFTGemGovernor {\n    event GovernanceTokenIssued(address indexed receiver, uint256 amount);\n    event FeeUpdated(address indexed proposal, address indexed token, uint256 newFee);\n    event AllowList(address indexed proposal, address indexed token, bool isBanned);\n    event ProjectFunded(address indexed proposal, address indexed receiver, uint256 received);\n    event StakingPoolCreated(\n        address indexed proposal,\n        address indexed pool,\n        string symbol,\n        string name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffStep,\n        uint256 maxClaims,\n        address alllowedToken\n    );\n\n    function initialize(\n        address _multitoken,\n        address _factory,\n        address _feeTracker,\n        address _proposalFactory,\n        address _swapHelper\n    ) external;\n\n    function createProposalVoteTokens(uint256 proposalHash) external;\n\n    function destroyProposalVoteTokens(uint256 proposalHash) external;\n\n    function executeProposal(address propAddress) external;\n\n    function issueInitialGovernanceTokens(address receiver) external returns (uint256);\n\n    function maybeIssueGovernanceToken(address receiver) external returns (uint256);\n\n    function issueFuelToken(address receiver, uint256 amount) external returns (uint256);\n\n    function createPool(\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external returns (address);\n\n    function createSystemPool(\n        string memory symbol,\n        string memory name,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n        address allowedToken\n    ) external returns (address);\n\n    function createNewPoolProposal(\n        address,\n        string memory,\n        string memory,\n        string memory,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        address\n    ) external returns (address);\n\n    function createChangeFeeProposal(\n        address,\n        string memory,\n        address,\n        address,\n        uint256\n    ) external returns (address);\n\n    function createFundProjectProposal(\n        address,\n        string memory,\n        address,\n        string memory,\n        uint256\n    ) external returns (address);\n\n    function createUpdateAllowlistProposal(\n        address,\n        string memory,\n        address,\n        address,\n        bool\n    ) external returns (address);\n}\n"
    },
    "src/interfaces/INFTGemFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface INFTGemFeeManager {\n\n    event DefaultFeeDivisorChanged(address indexed operator, uint256 oldValue, uint256 value);\n    event FeeDivisorChanged(address indexed operator, address indexed token, uint256 oldValue, uint256 value);\n    event ETHReceived(address indexed manager, address sender, uint256 value);\n    event LiquidityChanged(address indexed manager, uint256 oldValue, uint256 value);\n\n    function liquidity(address token) external view returns (uint256);\n\n    function defaultLiquidity() external view returns (uint256);\n\n    function setDefaultLiquidity(uint256 _liquidityMult) external returns (uint256);\n\n    function feeDivisor(address token) external view returns (uint256);\n\n    function defaultFeeDivisor() external view returns (uint256);\n\n    function setFeeDivisor(address token, uint256 _feeDivisor) external returns (uint256);\n\n    function setDefaultFeeDivisor(uint256 _feeDivisor) external returns (uint256);\n\n    function ethBalanceOf() external view returns (uint256);\n\n    function balanceOF(address token) external view returns (uint256);\n\n    function transferEth(address payable recipient, uint256 amount) external;\n\n    function transferToken(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external;\n\n}\n"
    },
    "src/interfaces/IProposalData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface ICreatePoolProposalData {\n    function data()\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n\n            address\n        );\n}\n\ninterface IChangeFeeProposalData {\n    function data()\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256\n        );\n}\n\ninterface IFundProjectProposalData {\n    function data()\n        external\n        view\n        returns (\n            address,\n            string memory,\n            uint256\n        );\n}\n\ninterface IUpdateAllowlistProposalData {\n    function data()\n        external\n        view\n        returns (\n            address,\n            address,\n            bool\n        );\n}\n\ninterface ITransferPoolFundsProposalData {\n    function data()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256\n        );\n}\n\ninterface ICreateCustomGemPoolProposalData {\n    function data()\n        external\n        view\n        returns (\n            bytes memory,\n            string memory,\n            string memory\n        );\n}\n"
    },
    "src/governance/GovernanceLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemPoolFactory.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/INFTGemPool.sol\";\nimport \"../interfaces/IProposal.sol\";\nimport \"../interfaces/IProposalData.sol\";\n\n\nlibrary GovernanceLib {\n\n    // calculates the CREATE2 address for the quantized erc20 without making any external calls\n    function addressOfPropoal(\n        address factory,\n        address submitter,\n        string memory title\n    ) public pure returns (address govAddress) {\n        govAddress = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        factory,\n                        keccak256(abi.encodePacked(submitter, title)),\n                        hex\"74f827a6bb3b7ed4cd86bd3c09b189a9496bc40d83635649e1e4df1c4e836ebf\" // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev create vote tokens to vote on given proposal\n     */\n    function createProposalVoteTokens(address multitoken, uint256 proposalHash) external {\n        for (uint256 i = 0; i < INFTGemMultiToken(multitoken).allTokenHoldersLength(0); i++) {\n            address holder = INFTGemMultiToken(multitoken).allTokenHolders(0, i);\n            INFTGemMultiToken(multitoken).mint(holder, proposalHash,\n                IERC1155(multitoken).balanceOf(holder, 0)\n            );\n        }\n    }\n\n    /**\n     * @dev destroy the vote tokens for the given proposal\n     */\n    function destroyProposalVoteTokens(address multitoken, uint256 proposalHash) external {\n        for (uint256 i = 0; i < INFTGemMultiToken(multitoken).allTokenHoldersLength(0); i++) {\n            address holder = INFTGemMultiToken(multitoken).allTokenHolders(0, i);\n            INFTGemMultiToken(multitoken).burn(holder, proposalHash,\n                IERC1155(multitoken).balanceOf(holder, proposalHash)\n            );\n        }\n    }\n\n        /**\n     * @dev execute craete pool proposal\n     */\n    function execute(\n        address factory,\n        address proposalAddress) public returns (address newPool) {\n\n        // get the data for the new pool from the proposal\n        address proposalData = IProposal(proposalAddress).proposalData();\n\n        (\n            string memory symbol,\n            string memory name,\n\n            uint256 ethPrice,\n            uint256 minTime,\n            uint256 maxTime,\n            uint256 diffStep,\n            uint256 maxClaims,\n\n            address allowedToken\n        ) = ICreatePoolProposalData(proposalData).data();\n\n        // create the new pool\n        newPool = createPool(\n            factory,\n\n            symbol,\n            name,\n\n            ethPrice,\n            minTime,\n            maxTime,\n            diffStep,\n            maxClaims,\n\n            allowedToken\n        );\n    }\n\n    /**\n     * @dev create a new pool\n     */\n    function createPool(\n        address factory,\n\n        string memory symbol,\n        string memory name,\n\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxClaims,\n\n        address allowedToken\n    ) public returns (address pool) {\n        pool = INFTGemPoolFactory(factory).createNFTGemPool(\n            symbol,\n            name,\n\n            ethPrice,\n            minTime,\n            maxTime,\n            diffstep,\n            maxClaims,\n\n            allowedToken\n        );\n    }\n\n    /**\n     * @dev create a new custom pool\n     */\n    function createCustomPool(\n        address factory,\n\n        bytes memory bytecode,\n        string memory symbol,\n        string memory name\n\n    ) public returns (address pool) {\n        pool = INFTGemPoolFactory(factory).createCustomNFTGemPool(\n            bytecode,\n            symbol,\n            name\n        );\n    }\n\n}\n"
    },
    "src/governance/ProposalsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IProposalFactory.sol\";\nimport \"../interfaces/IProposal.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\nimport \"../interfaces/INFTGemPoolData.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\n\nimport \"../governance/ChangeFeeProposalData.sol\";\nimport \"../governance/CreatePoolProposalData.sol\";\nimport \"../governance/FundProjectProposalData.sol\";\nimport \"../governance/UpdateAllowlistProposalData.sol\";\n\nimport \"./GovernanceLib.sol\";\n\nlibrary ProposalsLib {\n    event GovernanceTokenIssued(address indexed receiver, uint256 amount);\n    event FeeUpdated(address indexed proposal, address indexed token, uint256 newFee);\n    event AllowList(address indexed proposal, address indexed pool, address indexed token, bool isBanned);\n    event ProjectFunded(address indexed proposal, address indexed receiver, uint256 received);\n\n    // create a proposal and associate it with passed-in proposal data\n    function associateProposal(\n        address governor,\n        address multitoken,\n        address proposalFactory,\n        address submitter,\n        IProposal.ProposalType propType,\n        string memory title,\n        address data\n    ) internal returns (address p) {\n        p = IProposalFactory(proposalFactory).createProposal(submitter, title, data, propType);\n        IProposal(p).setMultiToken(multitoken);\n        IProposal(p).setGovernor(governor);\n        IControllable(multitoken).addController(p);\n        IControllable(governor).addController(p);\n    }\n\n    // create a new pool proposal\n    function createNewPoolProposal(\n        string memory symbol,\n        string memory name,\n\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffStep,\n        uint256 maxClaims,\n\n        address allowedToken\n    ) public returns (address) {\n        return\n            address(\n                new CreatePoolProposalData(\n                    symbol,\n                    name,\n\n                    ethPrice,\n                    minTime,\n                    maxTime,\n                    diffStep,\n                    maxClaims,\n\n                    allowedToken\n                )\n            );\n    }\n\n    // create a fee change proposal\n    function createChangeFeeProposal(\n        address token,\n        address pool,\n        uint256 feeDivisor\n    ) public returns (address) {\n        return address(\n            new ChangeFeeProposalData(\n                token,\n                pool,\n                feeDivisor));\n    }\n\n    // create a project funding proposal\n    function createFundProjectProposal(\n        address receiver,\n        string memory descriptionUrl,\n        uint256 ethAmount\n    ) public returns (address) {\n        return address(new FundProjectProposalData(\n            receiver,\n            descriptionUrl,\n            ethAmount));\n    }\n\n    // create an allowlist modify proposal\n    function createUpdateAllowlistProposal(\n        address token,\n        address pool,\n        bool newStatus\n    ) public returns (address) {\n        return address(new UpdateAllowlistProposalData(token, pool, newStatus));\n    }\n\n    /**\n     * @dev execute this proposal if it is in the right state. Anyone can execute a proposal\n     */\n    function executeProposal(\n        address multitoken,\n        address factory,\n        address governor,\n        address feeTracker,\n        address swapHelper,\n        address proposalAddress\n    ) external {\n        require(proposalAddress != address(0), \"INVALID_PROPOSAL\");\n        require(IProposal(proposalAddress).status() == IProposal.ProposalStatus.PASSED, \"PROPOSAL_NOT_PASSED\");\n        address prop = IProposal(proposalAddress).proposalData();\n        require(prop != address(0), \"INVALID_PROPOSAL_DATA\");\n\n        // craete a new NFT mining pool\n        if (IProposal(proposalAddress).proposalType() == IProposal.ProposalType.CREATE_POOL) {\n            address pool = GovernanceLib.execute(factory, proposalAddress);\n            IControllable(multitoken).addController(pool);\n            IControllable(governor).addController(pool);\n            INFTGemPool(pool).setMultiToken(multitoken);\n            INFTGemPool(pool).setSwapHelper(swapHelper);\n            INFTGemPool(pool).setGovernor(address(this));\n            INFTGemPool(pool).setFeeTracker(feeTracker);\n            INFTGemPool(pool).mintGenesisGems(IProposal(proposalAddress).creator(), IProposal(proposalAddress).funder());\n        }\n        // fund a project\n        else if (IProposal(proposalAddress).proposalType() == IProposal.ProposalType.FUND_PROJECT) {\n            (address receiver, , uint256 amount) = IFundProjectProposalData(prop).data();\n            INFTGemFeeManager(feeTracker).transferEth(payable(receiver), amount);\n            emit ProjectFunded(address(proposalAddress), address(receiver), amount);\n        }\n        // change a fee\n        else if (IProposal(proposalAddress).proposalType() == IProposal.ProposalType.CHANGE_FEE) {\n            require(prop != address(0), \"INVALID_PROPOSAL_DATA\");\n            address proposalData = IProposal(proposalAddress).proposalData();\n            (address token, address pool, uint256 feeDiv) = IChangeFeeProposalData(proposalData).data();\n            require(feeDiv != 0, \"INVALID_FEE\");\n            if (token != address(0)) INFTGemFeeManager(feeTracker).setFeeDivisor(token, feeDiv);\n            if (pool != address(0)) INFTGemFeeManager(feeTracker).setFeeDivisor(pool, feeDiv);\n            if (token == address(0) && pool == address(0)) {\n                INFTGemFeeManager(feeTracker).setDefaultFeeDivisor(feeDiv);\n            }\n        }\n        // modify the allowlist\n        else if (IProposal(proposalAddress).proposalType() == IProposal.ProposalType.UPDATE_ALLOWLIST) {\n            address proposalData = IProposal(proposalAddress).proposalData();\n            (address token, address pool, bool isAllowed) = IUpdateAllowlistProposalData(proposalData).data();\n            require(token != address(0), \"INVALID_TOKEN\");\n            if (isAllowed) {\n                INFTGemPoolData(pool).addAllowedToken(token);\n                emit AllowList(proposalAddress, pool, token, isAllowed);\n            } else {\n                INFTGemPoolData(pool).removeAllowedToken(token);\n            }\n        }\n\n        // transfer pool funds\n        else if (IProposal(proposalAddress).proposalType() == IProposal.ProposalType.TRANSFER_POOL_FUNDS) {\n            address proposalData = IProposal(proposalAddress).proposalData();\n            (address token, address pool, address recipient, uint amount) = ITransferPoolFundsProposalData(proposalData).data();\n            require(token != address(0), \"INVALID_TOKEN\");\n            require(pool != address(0), \"INVALID_POOL\");\n            INFTGemPool(pool).transferFunds(token, recipient, amount);\n        }\n\n        // transfer pool funds\n        else if (IProposal(proposalAddress).proposalType() == IProposal.ProposalType.CREATE_CUSTOM_POOL) {\n            address proposalData = IProposal(proposalAddress).proposalData();\n            (bytes memory bytecode, string memory symbol, string memory name) = ICreateCustomGemPoolProposalData(proposalData).data();\n            address pool = GovernanceLib.createCustomPool(factory, bytecode, symbol, name);\n            IControllable(multitoken).addController(pool);\n            IControllable(governor).addController(pool);\n            INFTGemPool(pool).setMultiToken(multitoken);\n            INFTGemPool(pool).setSwapHelper(swapHelper);\n            INFTGemPool(pool).setGovernor(address(this));\n            INFTGemPool(pool).setFeeTracker(feeTracker);\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "src/governance/ChangeFeeProposalData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IProposalData.sol\";\n\ncontract ChangeFeeProposalData is IChangeFeeProposalData {\n    address private token;\n    address private pool;\n    uint256 private feeDivisor;\n\n    constructor(\n        address _token,\n        address _pool,\n        uint256 _feeDivisor\n    ) {\n        token = _token;\n        pool = _pool;\n        feeDivisor = _feeDivisor;\n    }\n\n    function data()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (token, pool, feeDivisor);\n    }\n}\n"
    },
    "src/governance/CreatePoolProposalData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IProposalData.sol\";\n\ncontract CreatePoolProposalData is ICreatePoolProposalData {\n    \n    string private symbol;\n    string private name;\n    \n    uint256 private ethPrice;\n    uint256 private minTime;\n    uint256 private maxTime;\n    uint256 private diffstep;\n    uint256 private maxClaims;\n    \n    address private allowedToken;\n\n    constructor(\n        string memory _symbol,\n        string memory _name,\n\n        uint256 _ethPrice,\n        uint256 _minTIme,\n        uint256 _maxTime,\n        uint256 _diffStep,\n        uint256 _maxCLaim,\n        \n        address _allowedToken\n    ) {\n        symbol = _symbol;\n        name = _name;\n        ethPrice = _ethPrice;\n        minTime = _minTIme;\n        maxTime = _maxTime;\n        diffstep = _diffStep;\n        maxClaims = _maxCLaim;\n        allowedToken = _allowedToken;\n    }\n\n    function data()\n        external\n        view\n        override\n        returns (\n            string memory,\n            string memory,\n\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            \n            address\n        )\n    {\n        return (\n            symbol, \n            name, \n            \n            ethPrice, \n            minTime, \n            maxTime, \n            diffstep, \n            maxClaims, \n            \n            allowedToken);\n\n    }\n}\n"
    },
    "src/governance/FundProjectProposalData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IProposalData.sol\";\n\ncontract FundProjectProposalData is IFundProjectProposalData {\n    address private receiver;\n    string private descriptionUrl;\n    uint256 private ethAmount;\n\n    constructor(\n        address _receiver,\n        string memory _descriptionUrl,\n        uint256 _ethAmount\n    ) {\n        receiver = _receiver;\n        descriptionUrl = _descriptionUrl;\n        ethAmount = _ethAmount;\n    }\n\n    function data()\n        external\n        view\n        override\n        returns (\n            address,\n            string memory,\n            uint256\n        )\n    {\n        return (receiver, descriptionUrl, ethAmount);\n    }\n}\n"
    },
    "src/governance/UpdateAllowlistProposalData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IProposalData.sol\";\n\ncontract UpdateAllowlistProposalData is IUpdateAllowlistProposalData {\n    address private token;\n    address private pool;\n    bool private newStatus;\n\n    constructor(\n        address _token,\n        address _pool,\n        bool _newStatus\n    ) {\n        token = _token;\n        pool = _pool;\n        newStatus = _newStatus;\n    }\n\n    function data()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            bool\n        )\n    {\n        return (token, pool, newStatus);\n    }\n}\n"
    },
    "src/governance/TransferPoolFundsProposalData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IProposalData.sol\";\n\ncontract TransferPoolFundsProposalData is ITransferPoolFundsProposalData {\n    address private token;\n    address private pool;\n    address private destination;\n    uint256 private amount;\n\n    constructor(\n        address _token,\n        address _pool,\n        address _destination,\n        uint256 _amount\n    ) {\n        token = _token;\n        pool = _pool;\n        destination = _destination;\n        amount = _amount;\n    }\n\n    function data()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            address,\n            uint256\n        )\n    {\n        return (token, pool, destination, amount);\n    }\n}\n"
    },
    "src/governance/CreateCustomGemPoolProposalData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IProposalData.sol\";\n\ncontract CreateCustomGemPoolProposalData is ICreateCustomGemPoolProposalData {\n\n    string private symbol;\n    string private name;\n    bytes private bytecode;\n\n    constructor(\n        bytes memory _bytecode,\n        string memory _symbol,\n        string memory _name\n    ) {\n        bytecode = _bytecode;\n        symbol = _symbol;\n        name = _name;\n    }\n\n    function data()\n        external\n        view\n        override\n        returns (\n            bytes memory,\n            string memory,\n            string memory\n        )\n    {\n        return (bytecode, symbol, name);\n    }\n}\n"
    },
    "src/governance/Proposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../utils/Initializable.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/INFTGemPool.sol\";\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/IProposal.sol\";\nimport \"../interfaces/IProposalFactory.sol\";\nimport \"../tokens/ERC1155Holder.sol\";\nimport \"../libs/SafeMath.sol\";\n\ncontract Proposal is Initializable, ERC1155Holder, IProposal {\n    using SafeMath for uint256;\n\n    uint256 private constant MONTH = 2592000;\n    uint256 private constant PROPOSAL_COST = 1 ether;\n\n    string private _title;\n    address private _creator;\n    address private _funder;\n    address private _multitoken;\n    address private _governor;\n    uint256 private _expiration;\n\n    address private _proposalData;\n    ProposalType private _proposalType;\n\n    bool private _funded;\n    bool private _executed;\n    bool private _closed;\n\n    constructor() {}\n\n    function initialize(\n        address __creator,\n        string memory __title,\n        address __proposalData,\n        ProposalType __proposalType\n    ) external override initializer {\n        _title = __title;\n        _creator = __creator;\n        _proposalData = __proposalData;\n        _proposalType = __proposalType;\n    }\n\n    function setMultiToken(address token) external override {\n        require(_multitoken == address(0), \"IMMUTABLE\");\n        _multitoken = token;\n    }\n\n    function setGovernor(address gov) external override {\n        require(_governor == address(0), \"IMMUTABLE\");\n        _governor = gov;\n    }\n\n    function title() external view override returns (string memory) {\n        return _title;\n    }\n\n    function creator() external view override returns (address) {\n        return _creator;\n    }\n\n    function funder() external view override returns (address) {\n        return _creator;\n    }\n\n    function expiration() external view override returns (uint256) {\n        return _expiration;\n    }\n\n    function _status() internal view returns (ProposalStatus curCtatus) {\n        curCtatus = ProposalStatus.ACTIVE;\n        if (!_funded) {\n            curCtatus = ProposalStatus.NOT_FUNDED;\n        } else if (_executed) {\n            curCtatus = ProposalStatus.EXECUTED;\n        } else if (_closed) {\n            curCtatus = ProposalStatus.CLOSED;\n        } else {\n            uint256 totalVotesSupply = INFTGemMultiToken(_multitoken).totalBalances(uint256(address(this)));\n            uint256 totalVotesInFavor = IERC1155(_multitoken).balanceOf(address(this), uint256(address(this)));\n            uint256 votesToPass = totalVotesSupply.div(2).add(1);\n            curCtatus = totalVotesInFavor >= votesToPass ? ProposalStatus.PASSED : ProposalStatus.ACTIVE;\n            if (block.timestamp > _expiration) {\n                curCtatus = totalVotesInFavor >= votesToPass ? ProposalStatus.PASSED : ProposalStatus.FAILED;\n            }\n        }\n\n    }\n\n    function status() external view override returns (ProposalStatus curCtatus) {\n        curCtatus = _status();\n    }\n\n    function proposalData() external view override returns (address) {\n        return _proposalData;\n    }\n\n    function proposalType() external view override returns (ProposalType) {\n        return _proposalType;\n    }\n\n    function fund() external payable override {\n        // ensure we cannot fund while in an invalida state\n        require(!_funded, \"ALREADY_FUNDED\");\n        require(!_closed, \"ALREADY_CLOSED\");\n        require(!_executed, \"ALREADY_EXECUTED\");\n        require(msg.value >= PROPOSAL_COST, \"MISSING_FEE\");\n\n        // proposal is now funded and clock starts ticking\n        _funded = true;\n        _expiration = block.timestamp + MONTH;\n        _funder = msg.sender;\n\n        // create the vote tokens that will be used to vote on the proposal.\n        INFTGemGovernor(_governor).createProposalVoteTokens(uint256(address(this)));\n\n        // check for overpayment and if found then return remainder to user\n        uint256 overpayAmount = msg.value.sub(PROPOSAL_COST);\n        if (overpayAmount > 0) {\n            (bool success, ) = payable(msg.sender).call{value: overpayAmount}(\"\");\n            require(success, \"REFUND_FAILED\");\n        }\n    }\n\n    function execute() external override {\n        // ensure we are funded and open and not executed\n        require(_funded, \"NOT_FUNDED\");\n        require(!_closed, \"IS_CLOSED\");\n        require(!_executed, \"IS_EXECUTED\");\n        require(_status() == ProposalStatus.PASSED, \"IS_FAILED\");\n\n        // create the vote tokens that will be used to vote on the proposal.\n        INFTGemGovernor(_governor).executeProposal(address(this));\n\n        // this proposal is now executed\n        _executed = true;\n\n        // dewstroy the now-useless vote tokens used to vote for this proposal\n        INFTGemGovernor(_governor).destroyProposalVoteTokens(uint256(address(this)));\n\n        // refurn the filing fee to the funder of the proposal\n        (bool success, ) = _funder.call{value: PROPOSAL_COST}(\"\");\n        require(success, \"EXECUTE_FAILED\");\n    }\n\n    function close() external override {\n        // ensure we are funded and open and not executed\n        require(_funded, \"NOT_FUNDED\");\n        require(!_closed, \"IS_CLOSED\");\n        require(!_executed, \"IS_EXECUTED\");\n        require(block.timestamp > _expiration, \"IS_ACTIVE\");\n        require(_status() == ProposalStatus.FAILED, \"IS_PASSED\");\n\n        // this proposal is now closed - no action was taken\n        _closed = true;\n\n        // destroy the now-useless vote tokens used to vote for this proposal\n        INFTGemGovernor(_governor).destroyProposalVoteTokens(uint256(address(this)));\n\n        // send the proposal funder their filing fee back\n        (bool success, ) = _funder.call{value: PROPOSAL_COST}(\"\");\n        require(success, \"EXECUTE_FAILED\");\n    }\n}\n"
    },
    "src/factories/ProposalFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/IProposal.sol\";\nimport \"../interfaces/IProposalFactory.sol\";\nimport \"../access/Controllable.sol\";\nimport \"../libs/Create2.sol\";\nimport \"../governance/GovernanceLib.sol\";\nimport \"../governance/Proposal.sol\";\n\ncontract ProposalFactory is Controllable, IProposalFactory {\n    address private operator;\n\n    mapping(uint256 => address) private _getProposal;\n    address[] private _allProposals;\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /**\n     * @dev get the proposal for this\n     */\n    function getProposal(uint256 _symbolHash) external view override returns (address proposal) {\n        proposal = _getProposal[_symbolHash];\n    }\n\n    /**\n     * @dev get the proposal for this\n     */\n    function allProposals(uint256 idx) external view override returns (address proposal) {\n        proposal = _allProposals[idx];\n    }\n\n    /**\n     * @dev number of quantized addresses\n     */\n    function allProposalsLength() external view override returns (uint256 proposal) {\n        proposal = _allProposals.length;\n    }\n\n    /**\n     * @dev deploy a new proposal using create2\n     */\n    function createProposal(\n        address submitter,\n        string memory title,\n        address proposalData,\n        IProposal.ProposalType proposalType\n    ) external override onlyController returns (address payable proposal) {\n\n        // make sure this proposal doesnt already exist\n        bytes32 salt = keccak256(abi.encodePacked(submitter, title));\n        require(_getProposal[uint256(salt)] == address(0), \"PROPOSAL_EXISTS\"); // single check is sufficient\n\n        // create the quantized erc20 token using create2, which lets us determine the\n        // quantized erc20 address of a token without interacting with the contract itself\n        bytes memory bytecode = type(Proposal).creationCode;\n\n        // use create2 to deploy the quantized erc20 contract\n        proposal = payable(Create2.deploy(0, salt, bytecode));\n\n        // initialize  the proposal with submitter, proposal type, and proposal data\n        Proposal(proposal).initialize(submitter, title, proposalData, IProposal.ProposalType(proposalType));\n\n        // add teh new proposal to our lists for management\n        _getProposal[uint256(salt)] = proposal;\n        _allProposals.push(proposal);\n\n        // emit an event about the new proposal being created\n        emit ProposalCreated(submitter, uint256(proposalType), proposal);\n    }\n}\n"
    },
    "src/libs/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "src/factories/NFTGemPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../access/Controllable.sol\";\nimport \"../pool/NFTGemPool.sol\";\nimport \"../libs/Create2.sol\";\nimport \"../interfaces/INFTGemPoolFactory.sol\";\n\ncontract NFTGemPoolFactory is Controllable, INFTGemPoolFactory {\n    address private operator;\n\n    mapping(uint256 => address) private _getNFTGemPool;\n    address[] private _allNFTGemPools;\n\n    constructor() {\n        _addController(msg.sender);\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function getNFTGemPool(uint256 _symbolHash) external view override returns (address gemPool) {\n        gemPool = _getNFTGemPool[_symbolHash];\n    }\n\n    /**\n     * @dev get the quantized token for this\n     */\n    function allNFTGemPools(uint256 idx) external view override returns (address gemPool) {\n        gemPool = _allNFTGemPools[idx];\n    }\n\n    /**\n     * @dev number of quantized addresses\n     */\n    function allNFTGemPoolsLength() external view override returns (uint256) {\n        return _allNFTGemPools.length;\n    }\n\n    /**\n     * @dev deploy a new erc20 token using create2\n     */\n    function createNFTGemPool(\n        string memory gemSymbol,\n        string memory gemName,\n        uint256 ethPrice,\n        uint256 minTime,\n        uint256 maxTime,\n        uint256 diffstep,\n        uint256 maxMint,\n        address allowedToken\n    ) external override onlyController returns (address payable gemPool) {\n        bytes32 salt = keccak256(abi.encodePacked(gemSymbol));\n        require(_getNFTGemPool[uint256(salt)] == address(0), \"GEMPOOL_EXISTS\"); // single check is sufficient\n\n        // validation checks to make sure values are sane\n        require(ethPrice != 0, \"INVALID_PRICE\");\n        require(minTime != 0, \"INVALID_MIN_TIME\");\n        require(diffstep != 0, \"INVALID_DIFFICULTY_STEP\");\n\n        // create the quantized erc20 token using create2, which lets us determine the\n        // quantized erc20 address of a token without interacting with the contract itself\n        bytes memory bytecode = type(NFTGemPool).creationCode;\n\n        // use create2 to deploy the quantized erc20 contract\n        gemPool = payable(Create2.deploy(0, salt, bytecode));\n\n        // initialize the erc20 contract with the relevant addresses which it proxies\n        NFTGemPool(gemPool).initialize(gemSymbol, gemName, ethPrice, minTime, maxTime, diffstep, maxMint, allowedToken);\n\n        // insert the erc20 contract address into lists - one that maps source to quantized,\n        _getNFTGemPool[uint256(salt)] = gemPool;\n        _allNFTGemPools.push(gemPool);\n\n        // emit an event about the new pool being created\n        emit NFTGemPoolCreated(gemSymbol, gemName, ethPrice, minTime, maxTime, diffstep, maxMint, allowedToken);\n    }\n\n    /**\n     * @dev deploy a new erc20 token using create2\n     */\n    function createCustomNFTGemPool(\n        bytes memory bytecode,\n        string memory gemSymbol,\n        string memory gemName\n    ) external override onlyController returns (address payable gemPool) {\n        bytes32 salt = keccak256(abi.encodePacked(gemSymbol));\n        require(_getNFTGemPool[uint256(salt)] == address(0), \"GEMPOOL_EXISTS\"); // single check is sufficient\n\n       // use create2 to deploy the quantized erc20 contract\n        gemPool = payable(Create2.deploy(0, salt, bytecode));\n\n        // insert the erc20 contract address into lists - one that maps source to quantized,\n        _getNFTGemPool[uint256(salt)] = gemPool;\n        _allNFTGemPools.push(gemPool);\n\n        // emit an event about the new pool being created\n        emit CustomNFTGemPoolCreated(gemSymbol, gemName);\n    }\n}\n"
    },
    "src/pool/NFTGemPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../utils/Initializable.sol\";\nimport \"../interfaces/INFTGemMultiToken.sol\";\nimport \"../interfaces/INFTGemFeeManager.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/INFTGemPool.sol\";\nimport \"../interfaces/INFTGemGovernor.sol\";\nimport \"../interfaces/ISwapQueryHelper.sol\";\n\nimport \"../libs/SafeMath.sol\";\nimport \"./NFTGemPoolData.sol\";\n\ncontract NFTGemPool is Initializable, NFTGemPoolData, INFTGemPool {\n    using SafeMath for uint256;\n\n    // governor and multitoken target\n    address private _multitoken;\n    address private _governor;\n    address private _feeTracker;\n    address private _swapHelper;\n\n    /**\n     * @dev initializer called when contract is deployed\n     */\n    function initialize (\n        string memory __symbol,\n        string memory __name,\n        uint256 __ethPrice,\n        uint256 __minTime,\n        uint256 __maxTime,\n        uint256 __diffstep,\n        uint256 __maxClaims,\n        address __allowedToken\n    ) external override initializer {\n        _symbol = __symbol;\n        _name = __name;\n        _ethPrice = __ethPrice;\n        _minTime = __minTime;\n        _maxTime = __maxTime;\n        _diffstep = __diffstep;\n        _maxClaims = __maxClaims;\n\n        if(__allowedToken != address(0)) {\n            _allowedTokens.push(__allowedToken);\n            _isAllowedMap[__allowedToken] = true;\n        }\n    }\n\n    /**\n     * @dev set the governor. pool uses the governor to issue gov token issuance requests\n     */\n    function setGovernor(address addr) external override {\n        require(_governor == address(0), \"IMMUTABLE\");\n        _governor = addr;\n    }\n\n    /**\n     * @dev set the fee tracker that the pool uses to determine what fees to charge\n     */\n    function setFeeTracker(address addr) external override {\n        require(_feeTracker == address(0), \"IMMUTABLE\");\n        _feeTracker = addr;\n    }\n\n    /**\n     * @dev set the multitoken that this pool will mint new tokens on. Must be a controller of the multitoken\n     */\n    function setMultiToken(address token) external override {\n        require(_multitoken == address(0), \"IMMUTABLE\");\n        _multitoken = token;\n    }\n\n    /**\n     * @dev set the swap helper that this pool will mint new tokens on. Must be a controller of the multitoken\n     */\n    function setSwapHelper(address helper) external override {\n        require(_swapHelper == address(0), \"IMMUTABLE\");\n        _swapHelper = helper;\n    }\n\n    /**\n     * @dev mint the genesis gems earned by the pools creator and funder\n     */\n    function mintGenesisGems(address creator, address funder) external override {\n        require(_multitoken != address(0), \"NO_MULTITOKEN\");\n        require(creator != address(0) && funder != address(0), \"ZERO_DESTINATION\");\n        require(_nextGemId == 0, \"ALREADY_MINTED\");\n\n        uint256 gemHash = _nextGemHash();\n        INFTGemMultiToken(_multitoken).mint(creator, gemHash, 1);\n        _addToken(gemHash, 2);\n\n        gemHash = _nextGemHash();\n        INFTGemMultiToken(_multitoken).mint(creator, gemHash, 1);\n        _addToken(gemHash, 2);\n    }\n\n    /**\n     * @dev the external version of creating a claim\n     */\n    function createClaim(uint256 timeframe) external payable override {\n        _createClaim(timeframe);\n    }\n\n    /**\n     * @dev the external version of creating multiple claims\n     */\n    function createClaims(uint256 timeframe, uint256 count) external payable override {\n        _createClaims(timeframe, count);\n    }\n\n    /**\n     * @dev create a claim using a erc20 token\n     */\n    function createERC20Claim(address erc20token, uint256 tokenAmount) external override {\n        _createERC20Claim(erc20token, tokenAmount);\n    }\n\n    /**\n     * @dev create claims using a erc20 token\n     */\n    function createERC20Claims(address erc20token, uint256 tokenAmount, uint256 count) external override {\n        _createERC20Claims(erc20token, tokenAmount, count);\n    }\n\n\n    /**\n     * @dev default receive. tries to issue a claim given the received ETH or revert\n     */\n    receive() external payable {\n        uint256 incomingEth = msg.value;\n\n        // compute the mimimum cost of a claim and revert if not enough sent\n        uint256 minClaimCost = _ethPrice.div(_maxTime).mul(_minTime);\n        require(incomingEth >= minClaimCost, \"INSUFFICIENT_ETH\");\n\n        // compute the minimum actual claim time\n        uint256 actualClaimTime = _minTime;\n\n        // refund ETH above max claim cost\n        if (incomingEth <= _ethPrice)  {\n            actualClaimTime = _ethPrice.div(incomingEth).mul(_minTime);\n        }\n\n        // create the claim using minimum possible claim time\n        _createClaim(actualClaimTime);\n    }\n\n    /**\n     * @dev attempt to create a claim using the given timeframe\n     */\n    function _createClaim(uint256 timeframe) internal {\n        // minimum timeframe\n        require(timeframe >= _minTime, \"TIMEFRAME_TOO_SHORT\");\n\n        // maximum timeframe\n        require((_maxTime != 0 && timeframe <= _maxTime) || _maxTime == 0, \"TIMEFRAME_TOO_LONG\");\n\n        // cost given this timeframe\n        uint256 cost = _ethPrice.mul(_minTime).div(timeframe);\n        require(msg.value > cost, \"INSUFFICIENT_ETH\");\n\n        // get the nest claim hash, revert if no more claims\n        uint256 claimHash = _nextClaimHash();\n        require(claimHash != 0, \"NO_MORE_CLAIMABLE\");\n\n        // mint the new claim to the caller's address\n        INFTGemMultiToken(_multitoken).mint(msg.sender, claimHash, 1);\n        _addToken(claimHash, 1);\n\n        // record the claim unlock time and cost paid for this claim\n        uint256 _claimUnlockTime = block.timestamp.add(timeframe);\n        claimLockTimestamps[claimHash] = _claimUnlockTime;\n        claimAmountPaid[claimHash] = cost;\n        claimQuant[claimHash] = 1;\n\n        // increase the staked eth balance\n        _totalStakedEth = _totalStakedEth.add(cost);\n\n        // maybe mint a governance token for the claimant\n        INFTGemGovernor(_governor).maybeIssueGovernanceToken(msg.sender);\n        INFTGemGovernor(_governor).issueFuelToken(msg.sender, cost);\n\n        emit NFTGemClaimCreated(msg.sender, address(this), claimHash, timeframe, 1, cost);\n\n        // refund any overpaid amount\n        if (msg.value > cost) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value.sub(cost)}(\"\");\n            require(success, \"REFUND_FAILED\");\n        }\n    }\n\n    /**\n     * @dev attempt to create a claim using the given timeframe, for the given count of tokens\n     */\n    function _createClaims(uint256 timeframe, uint256 count) internal {\n        // minimum timeframe\n        require(timeframe >= _minTime, \"TIMEFRAME_TOO_SHORT\");\n        // no ETH\n        require(msg.value != 0, \"ZERO_BALANCE\");\n        // zero qty\n        require(count != 0, \"ZERO_QUANTITY\");\n        // maximum timeframe\n        require((_maxTime != 0 && timeframe <= _maxTime) || _maxTime == 0, \"TIMEFRAME_TOO_LONG\");\n\n        // adjusted balance - we just need to figure out if portion given for one will work for all\n        uint256 adjustedBalance = msg.value.div(count);\n\n        // cost given this timeframe\n        uint256 cost = _ethPrice.mul(_minTime).div(timeframe);\n        require(adjustedBalance >= cost, \"INSUFFICIENT_ETH\");\n\n        // get the nest claim hash, revert if no more claims\n        uint256 claimHash = _nextClaimHash();\n        require(claimHash != 0, \"NO_MORE_CLAIMABLE\");\n\n        // mint the new claim to the caller's address\n        INFTGemMultiToken(_multitoken).mint(msg.sender, claimHash, 1);\n        _addToken(claimHash, 1);\n\n        // record the claim unlock time and cost paid for this claim\n        uint256 _claimUnlockTime = block.timestamp.add(timeframe);\n        claimLockTimestamps[claimHash] = _claimUnlockTime;\n        claimAmountPaid[claimHash] = cost.mul(count);\n        claimQuant[claimHash] = count;\n\n        // maybe mint a governance token for the claimant\n        INFTGemGovernor(_governor).maybeIssueGovernanceToken(msg.sender);\n        INFTGemGovernor(_governor).issueFuelToken(msg.sender, cost);\n\n        emit NFTGemClaimCreated(msg.sender, address(this), claimHash, timeframe, count, cost);\n\n        // increase the staked eth balance\n        _totalStakedEth = _totalStakedEth.add(cost.mul(count));\n\n        if (msg.value > cost.mul(count)) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value.sub(cost.mul(count))}(\"\");\n            require(success, \"REFUND_FAILED\");\n        }\n    }\n\n    /**\n     * @dev crate a gem claim using an erc20 token. this token must be tradeable in Uniswap or this call will fail\n     */\n    function _createERC20Claim(address erc20token, uint256 tokenAmount) internal {\n        // must be a valid address\n        require(erc20token != address(0), \"INVALID_ERC20_TOKEN\");\n\n        // token is allowed\n        require((_allowedTokens.length > 0 && _isAllowedMap[erc20token]) || _allowedTokens.length == 0, \"TOKEN_DISALLOWED\");\n\n        // Uniswap pool must exist\n        require(ISwapQueryHelper(_swapHelper).hasPool(erc20token) == true, \"NO_UNISWAP_POOL\");\n\n        // must have an amount specified\n        require(tokenAmount >= 0, \"NO_PAYMENT_INCLUDED\");\n\n        // get a quote in ETH for the given token.\n        (uint256 ethereum, uint256 tokenReserve, uint256 ethReserve) = ISwapQueryHelper(_swapHelper).coinQuote(erc20token, tokenAmount);\n\n        // get the min liquidity from fee tracker\n        uint256 liquidity = INFTGemFeeManager(_feeTracker).liquidity(erc20token);\n\n        // make sure the convertible amount is has reserves > 100x the token\n        require(ethReserve >= ethereum.mul(liquidity), \"INSUFFICIENT_ETH_LIQUIDITY\");\n\n        // make sure the convertible amount is has reserves > 100x the token\n        require(tokenReserve >= tokenAmount.mul(liquidity), \"INSUFFICIENT_TOKEN_LIQUIDITY\");\n\n        // make sure the convertible amount is less than max price\n        require(ethereum <= _ethPrice, \"OVERPAYMENT\");\n\n        // calculate the maturity time given the converted eth\n        uint256 maturityTime = _ethPrice.mul(_minTime).div(ethereum);\n\n        // make sure the convertible amount is less than max price\n        require(maturityTime >= _minTime, \"INSUFFICIENT_TIME\");\n\n        // get the next claim hash, revert if no more claims\n        uint256 claimHash = _nextClaimHash();\n        require(claimHash != 0, \"NO_MORE_CLAIMABLE\");\n\n        // transfer the caller's ERC20 tokens into the pool\n        IERC20(erc20token).transferFrom(msg.sender, address(this), tokenAmount);\n\n        // mint the new claim to the caller's address\n        INFTGemMultiToken(_multitoken).mint(msg.sender, claimHash, 1);\n        _addToken(claimHash, 1);\n\n        // record the claim unlock time and cost paid for this claim\n        uint256 _claimUnlockTime = block.timestamp.add(maturityTime);\n        claimLockTimestamps[claimHash] = _claimUnlockTime;\n        claimAmountPaid[claimHash] = ethereum;\n        claimLockToken[claimHash] = erc20token;\n        claimTokenAmountPaid[claimHash] = tokenAmount;\n        claimQuant[claimHash] = 1;\n\n        _totalStakedEth = _totalStakedEth.add(ethereum);\n\n        // maybe mint a governance token for the claimant\n        INFTGemGovernor(_governor).maybeIssueGovernanceToken(msg.sender);\n        INFTGemGovernor(_governor).issueFuelToken(msg.sender, ethereum);\n\n        // emit a message indicating that an erc20 claim has been created\n        emit NFTGemERC20ClaimCreated(msg.sender, address(this), claimHash, maturityTime, erc20token, 1, ethereum);\n    }\n\n    /**\n     * @dev crate multiple gem claim using an erc20 token. this token must be tradeable in Uniswap or this call will fail\n     */\n    function _createERC20Claims(address erc20token, uint256 tokenAmount, uint256 count) internal {\n        // must be a valid address\n        require(erc20token != address(0), \"INVALID_ERC20_TOKEN\");\n\n        // token is allowed\n        require((_allowedTokens.length > 0 && _isAllowedMap[erc20token]) || _allowedTokens.length == 0, \"TOKEN_DISALLOWED\");\n\n        // zero qty\n        require(count != 0, \"ZERO_QUANTITY\");\n\n        // Uniswap pool must exist\n        require(ISwapQueryHelper(_swapHelper).hasPool(erc20token) == true, \"NO_UNISWAP_POOL\");\n\n        // must have an amount specified\n        require(tokenAmount >= 0, \"NO_PAYMENT_INCLUDED\");\n\n        // get a quote in ETH for the given token.\n        (uint256 ethereum, uint256 tokenReserve, uint256 ethReserve) = ISwapQueryHelper(_swapHelper).coinQuote(\n            erc20token,\n            tokenAmount.div(count)\n        );\n\n        // make sure the convertible amount is has reserves > 100x the token\n        require(ethReserve >= ethereum.mul(100).mul(count), \"INSUFFICIENT_ETH_LIQUIDITY\");\n\n        // make sure the convertible amount is has reserves > 100x the token\n        require(tokenReserve >= tokenAmount.mul(100).mul(count), \"INSUFFICIENT_TOKEN_LIQUIDITY\");\n\n        // make sure the convertible amount is less than max price\n        require(ethereum <= _ethPrice, \"OVERPAYMENT\");\n\n        // calculate the maturity time given the converted eth\n        uint256 maturityTime = _ethPrice.mul(_minTime).div(ethereum);\n\n        // make sure the convertible amount is less than max price\n        require(maturityTime >= _minTime, \"INSUFFICIENT_TIME\");\n\n        // get the next claim hash, revert if no more claims\n        uint256 claimHash = _nextClaimHash();\n        require(claimHash != 0, \"NO_MORE_CLAIMABLE\");\n\n        // mint the new claim to the caller's address\n        INFTGemMultiToken(_multitoken).mint(msg.sender, claimHash, 1);\n        _addToken(claimHash, 1);\n\n        // record the claim unlock time and cost paid for this claim\n        uint256 _claimUnlockTime = block.timestamp.add(maturityTime);\n        claimLockTimestamps[claimHash] = _claimUnlockTime;\n        claimAmountPaid[claimHash] = ethereum;\n        claimLockToken[claimHash] = erc20token;\n        claimTokenAmountPaid[claimHash] = tokenAmount;\n        claimQuant[claimHash] = count;\n\n        // increase staked eth amount\n        _totalStakedEth = _totalStakedEth.add(ethereum);\n\n        // maybe mint a governance token for the claimant\n        INFTGemGovernor(_governor).maybeIssueGovernanceToken(msg.sender);\n        INFTGemGovernor(_governor).issueFuelToken(msg.sender, ethereum);\n\n        // emit a message indicating that an erc20 claim has been created\n        emit NFTGemERC20ClaimCreated(msg.sender, address(this), claimHash, maturityTime, erc20token, count, ethereum);\n\n        // transfer the caller's ERC20 tokens into the pool\n        IERC20(erc20token).transferFrom(msg.sender, address(this), tokenAmount);\n    }\n\n    /**\n     * @dev collect an open claim (take custody of the funds the claim is redeeemable for and maybe a gem too)\n     */\n    function collectClaim(uint256 claimHash) external override {\n        // validation checks - disallow if not owner (holds coin with claimHash)\n        // or if the unlockTime amd unlockPaid data is in an invalid state\n        require(IERC1155(_multitoken).balanceOf(msg.sender, claimHash) == 1, \"NOT_CLAIM_OWNER\");\n        uint256 unlockTime = claimLockTimestamps[claimHash];\n        uint256 unlockPaid = claimAmountPaid[claimHash];\n        require(unlockTime != 0 && unlockPaid > 0, \"INVALID_CLAIM\");\n\n        // grab the erc20 token info if there is any\n        address tokenUsed = claimLockToken[claimHash];\n        uint256 unlockTokenPaid = claimTokenAmountPaid[claimHash];\n\n        // check the maturity of the claim - only issue gem if mature\n        bool isMature = unlockTime < block.timestamp;\n\n        //  burn claim and transfer money back to user\n        INFTGemMultiToken(_multitoken).burn(msg.sender, claimHash, 1);\n\n        // if they used erc20 tokens stake their claim, return their tokens\n        if (tokenUsed != address(0)) {\n            // calculate fee portion using fee tracker\n            uint256 feePortion = 0;\n            if (isMature == true) {\n                uint256 poolDiv = INFTGemFeeManager(_feeTracker).feeDivisor(address(this));\n                uint256 divisor = INFTGemFeeManager(_feeTracker).feeDivisor(tokenUsed);\n                uint256 feeNum = poolDiv != divisor ? divisor : poolDiv;\n                feePortion = unlockTokenPaid.div(feeNum);\n            }\n            // assess a fee for minting the NFT. Fee is collectec in fee tracker\n            IERC20(tokenUsed).transferFrom(address(this), _feeTracker, feePortion);\n            // send the principal minus fees to the caller\n            IERC20(tokenUsed).transferFrom(address(this), msg.sender, unlockTokenPaid.sub(feePortion));\n\n            // emit an event that the claim was redeemed for ERC20\n            emit NFTGemERC20ClaimRedeemed(\n                msg.sender,\n                address(this),\n                claimHash,\n                tokenUsed,\n                unlockPaid,\n                unlockTokenPaid,\n                feePortion\n            );\n        } else {\n            // calculate fee portion using fee tracker\n            uint256 feePortion = 0;\n            if (isMature == true) {\n                uint256 divisor = INFTGemFeeManager(_feeTracker).feeDivisor(address(0));\n                feePortion = unlockPaid.div(divisor);\n            }\n            // transfer the ETH fee to fee tracker\n            payable(_feeTracker).transfer(feePortion);\n            // transfer the ETH back to user\n            payable(msg.sender).transfer(unlockPaid.sub(feePortion));\n\n            // emit an event that the claim was redeemed for ETH\n            emit NFTGemClaimRedeemed(msg.sender, address(this), claimHash, unlockPaid, feePortion);\n        }\n\n        // deduct the total staked ETH balance of the pool\n        _totalStakedEth = _totalStakedEth.sub(unlockPaid);\n\n        // if all this is happening before the unlocktime then we exit\n        // without minting a gem because the user is withdrawing early\n        if (!isMature) {\n            return;\n        }\n\n        // get the next gem hash, increase the staking sifficulty\n        // for the pool, and mint a gem token back to account\n        uint256 nextHash = this.nextGemHash();\n\n        // mint the gem\n        INFTGemMultiToken(_multitoken).mint(msg.sender, nextHash, claimQuant[claimHash]);\n        _addToken(nextHash, 2);\n\n        // maybe mint a governance token\n        INFTGemGovernor(_governor).maybeIssueGovernanceToken(msg.sender);\n        INFTGemGovernor(_governor).issueFuelToken(msg.sender, unlockPaid);\n\n        // emit an event about a gem getting created\n        emit NFTGemCreated(msg.sender, address(this), claimHash, nextHash, claimQuant[claimHash]);\n    }\n\n    /**\n     * @dev governance-driven\n     */\n    function transferFunds(address token, address receiver, uint256 amount) external override {\n\n        require(msg.sender == _governor, \"UNAUTHORIZED_NAUGHTY\");\n        require(token != address(0), \"LOL_MINT_NO\");\n        require(receiver != address(0), \"NOT_UR_MONEY_2_BURN\");\n        require(amount != 0, \"CANNOT_SEND_ZERO_THINGS_GENIUS\");\n\n        if(token == address(0)) {\n            // transfer the ETH  to the receiver\n            payable(receiver).transfer(amount);\n        } else {\n            // transfer the tokens  to the receiver\n            IERC20(token).transfer(receiver, amount);\n        }\n\n    }\n}\n"
    },
    "src/interfaces/ISwapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface ISwapQueryHelper {\n\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function factory() external pure returns (address);\n\n    function COIN() external pure returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function hasPool(address token) external view returns (bool);\n\n    function getReserves(\n        address pair\n    ) external view returns (uint256, uint256);\n\n    function pairFor(\n        address tokenA,\n        address tokenB\n    ) external pure returns (address);\n\n    function getPathForCoinToToken(address token) external pure returns (address[] memory);\n\n}\n"
    },
    "src/pool/NFTGemPoolData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../libs/SafeMath.sol\";\nimport \"../utils/Initializable.sol\";\nimport \"../interfaces/INFTGemPoolData.sol\";\n\n\ncontract NFTGemPoolData is INFTGemPoolData, Initializable {\n    using SafeMath for uint256;\n\n    // it all starts with a symbol and a nams\n    string internal _symbol;\n    string internal _name;\n\n    // magic economy numbers\n    uint256 internal _ethPrice;\n    uint256 internal _minTime;\n    uint256 internal _maxTime;\n    uint256 internal _diffstep;\n    uint256 internal _maxClaims;\n\n    mapping(uint256 => uint8) internal _tokenTypes;\n    mapping(uint256 => uint256) internal _tokenIds;\n    uint256[] internal _tokenHashes;\n\n    // next ids of things\n    uint256 internal _nextGemId;\n    uint256 internal _nextClaimId;\n    uint256 internal _totalStakedEth;\n\n    // records claim timestamp / ETH value / ERC token and amount sent\n    mapping(uint256 => uint256) internal claimLockTimestamps;\n    mapping(uint256 => address) internal claimLockToken;\n    mapping(uint256 => uint256) internal claimAmountPaid;\n    mapping(uint256 => uint256) internal claimQuant;\n    mapping(uint256 => uint256) internal claimTokenAmountPaid;\n\n    address[] internal _allowedTokens;\n    mapping(address => bool) internal _isAllowedMap;\n\n    constructor() {}\n\n    /**\n     * @dev The symbol for this pool / NFT\n     */\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev The name for this pool / NFT\n     */\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev The ether price for this pool / NFT\n     */\n    function ethPrice() external view override returns (uint256) {\n        return _ethPrice;\n    }\n\n    /**\n     * @dev min time to stake in this pool to earn an NFT\n     */\n    function minTime() external view override returns (uint256) {\n        return _minTime;\n    }\n\n    /**\n     * @dev max time to stake in this pool to earn an NFT\n     */\n    function maxTime() external view override returns (uint256) {\n        return _maxTime;\n    }\n\n    /**\n     * @dev difficulty step increase for this pool.\n     */\n    function difficultyStep() external view override returns (uint256) {\n        return _diffstep;\n    }\n\n    /**\n     * @dev max claims that can be made on this NFT\n     */\n    function maxClaims() external view override returns (uint256) {\n        return _maxClaims;\n    }\n\n    /**\n     * @dev number of claims made thus far\n     */\n    function claimedCount() external view override returns (uint256) {\n        return _nextClaimId;\n    }\n\n    /**\n     * @dev the number of gems minted in this\n     */\n    function mintedCount() external view override returns (uint256) {\n        return _nextGemId;\n    }\n\n    /**\n     * @dev the number of gems minted in this\n     */\n    function totalStakedEth() external view override returns (uint256) {\n        return _totalStakedEth;\n    }\n\n    /**\n     * @dev get token type of hash - 1 is for claim, 2 is for gem\n     */\n    function tokenType(uint256 tokenHash) external view override returns (uint8) {\n        return _tokenTypes[tokenHash];\n    }\n\n    /**\n     * @dev get token id (serial #) of the given token hash. 0 if not a token, 1 if claim, 2 if gem\n     */\n    function tokenId(uint256 tokenHash) external view override returns (uint256) {\n        return _tokenIds[tokenHash];\n    }\n\n    /**\n     * @dev get token id (serial #) of the given token hash. 0 if not a token, 1 if claim, 2 if gem\n     */\n    function allTokenHashesLength() external view override returns (uint256) {\n        return _tokenHashes.length;\n    }\n\n    /**\n     * @dev get token id (serial #) of the given token hash. 0 if not a token, 1 if claim, 2 if gem\n     */\n    function allTokenHashes(uint256 ndx) external view override returns (uint256) {\n        return _tokenHashes[ndx];\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function nextClaimHash() external view override returns (uint256) {\n        return _nextClaimHash();\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function nextGemHash() external view override returns (uint256) {\n        return _nextGemHash();\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function nextClaimId() external view override returns (uint256) {\n        return _nextClaimId;\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function nextGemId() external view override returns (uint256) {\n        return _nextGemId;\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function allowedTokensLength() external view override returns (uint256) {\n        return _allowedTokens.length;\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function allowedTokens(uint256 idx) external view override returns (address) {\n        return _allowedTokens[idx];\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function isTokenAllowed(address token) external view override returns (bool) {\n        return _isAllowedMap[token];\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function addAllowedToken(address token) external override {\n        if(!_isAllowedMap[token]) {\n            _allowedTokens.push(token);\n            _isAllowedMap[token] = true;\n        }\n    }\n\n    /**\n     * @dev the external version of the above\n     */\n    function removeAllowedToken(address token) external override {\n        if(_isAllowedMap[token]) {\n            for(uint256 i = 0; i < _allowedTokens.length; i++) {\n                if(_allowedTokens[i] == token) {\n                   _allowedTokens[i] = _allowedTokens[_allowedTokens.length - 1];\n                    delete _allowedTokens[_allowedTokens.length - 1];\n                    _isAllowedMap[token] = false;\n                    return;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev the claim amount for the given claim id\n     */\n    function claimAmount(uint256 claimHash) external view override returns (uint256) {\n        return claimAmountPaid[claimHash];\n    }\n\n    /**\n     * @dev the claim quantity (count of gems staked) for the given claim id\n     */\n    function claimQuantity(uint256 claimHash) external view override returns (uint256) {\n        return claimQuant[claimHash];\n    }\n\n    /**\n     * @dev the lock time for this claim. once past lock time a gema is minted\n     */\n    function claimUnlockTime(uint256 claimHash) external view override returns (uint256) {\n        return claimLockTimestamps[claimHash];\n    }\n\n    /**\n     * @dev claim token amount if paid using erc20\n     */\n    function claimTokenAmount(uint256 claimHash) external view override returns (uint256) {\n        return claimTokenAmountPaid[claimHash];\n    }\n\n    /**\n     * @dev the staked token if staking with erc20\n     */\n    function stakedToken(uint256 claimHash) external view override returns (address) {\n        return claimLockToken[claimHash];\n    }\n\n    /**\n     * @dev get token id (serial #) of the given token hash. 0 if not a token, 1 if claim, 2 if gem\n     */\n    function _addToken(uint256 tokenHash, uint8 tt) internal {\n        require(tt == 1 || tt == 2, \"INVALID_TOKENTYPE\");\n        _tokenHashes.push(tokenHash);\n        _tokenTypes[tokenHash] = tt;\n        _tokenIds[tokenHash] = tt == 1 ? __nextClaimId() : __nextGemId();\n        if(tt == 2) {\n            _increaseDifficulty();\n        }\n    }\n\n    /**\n     * @dev get the next claim id\n     */\n    function __nextClaimId() private returns (uint256) {\n        uint256 ncId = _nextClaimId;\n        _nextClaimId = _nextClaimId.add(1);\n        return ncId;\n    }\n\n    /**\n     * @dev get the next gem id\n     */\n    function __nextGemId() private returns (uint256) {\n        uint256 ncId = _nextGemId;\n        _nextGemId = _nextGemId.add(1);\n        return ncId;\n    }\n\n    /**\n     * @dev increase the pool's difficulty by calculating the step increase portion and adding it to the eth price of the market\n     */\n    function _increaseDifficulty() private {\n        uint256 diffIncrease = _ethPrice.div(_diffstep);\n        _ethPrice = _ethPrice.add(diffIncrease);\n    }\n\n    /**\n     * @dev the hash of the next gem to be minted\n     */\n    function _nextGemHash() internal view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(\"gem\", address(this), _nextGemId)));\n    }\n\n    /**\n     * @dev the hash of the next claim to be minted\n     */\n    function _nextClaimHash() internal view returns (uint256) {\n        return\n            (_maxClaims != 0 && _nextClaimId <= _maxClaims) || _maxClaims == 0\n                ? uint256(keccak256(abi.encodePacked(\"claim\", address(this), _nextClaimId)))\n                : 0;\n    }\n\n}\n"
    },
    "src/swap/uniswap/UniswapQueryHelper.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./UniswapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract UniswapQueryHelper is ISwapQueryHelper {\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n       return UniswapLib.ethQuote(token, tokenAmount);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = UniswapLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = UniswapLib.WETH();\n    }\n\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB) external view override returns (address pair) {\n        address _factory = UniswapLib.factory();\n        pair = UniswapLib.getPair(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address pair\n    ) external view override returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB) = UniswapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address tokenA,\n        address tokenB\n    ) external pure override returns (address pair) {\n        address _factory = UniswapLib.factory();\n        pair = UniswapLib.pairFor(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return UniswapLib.hasPool(token);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token) external pure override returns (address[] memory) {\n        return UniswapLib.getPathForETHToToken(token);\n    }\n\n}\n"
    },
    "src/swap/uniswap/UniswapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary UniswapLib {\n\n    address public constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function ethQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        (tokenReserve, ethReserve, ) = IUniswapV2Pair(_pair).getReserves();\n        ethereum = quote(tokenAmount, tokenReserve, ethReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WETH() external pure returns (address weth) {\n        weth = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address _factory, address tokenA, address tokenB) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair =\n            IUniswapV2Factory(_factory).getPair(\n                tokenA,\n                tokenB\n            );\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address pair\n    ) external view returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB, ) = IUniswapV2Pair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        _factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForETHToToken(address token) external pure returns (address[] memory) {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "src/swap/funiswap/FuniswapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary FuniswapLib {\n\n    address public constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function ethQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        (tokenReserve, ethReserve, ) = IUniswapV2Pair(_pair).getReserves();\n        ethereum = quote(tokenAmount, tokenReserve, ethReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WETH() external pure returns (address weth) {\n        weth = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n        address _factory = uniswapRouter.factory();\n        address _WETH = uniswapRouter.WETH();\n        address _pair = IUniswapV2Factory(_factory).getPair(token, _WETH);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address _factory, address tokenA, address tokenB) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair =\n            IUniswapV2Factory(_factory).getPair(\n                tokenA,\n                tokenB\n            );\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address pair\n    ) external view returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB, ) = IUniswapV2Pair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        _factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForETHToToken(address token) external pure returns (address[] memory) {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "src/swap/funiswap/FuniswapQueryHelper.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./FuniswapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\n\n/**\n * @dev Funiswap helpers\n */\ncontract FuniswapQueryHelper is ISwapQueryHelper {\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n       return FuniswapLib.ethQuote(token, tokenAmount);\n    }\n\n    /**\n     * @dev does a Funiswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = FuniswapLib.factory();\n    }\n\n    /**\n     * @dev does a Funiswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = FuniswapLib.WETH();\n    }\n\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB) external view override returns (address pair) {\n        address _factory = FuniswapLib.factory();\n        pair = FuniswapLib.getPair(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address pair\n    ) external view override returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB) = FuniswapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address tokenA,\n        address tokenB\n    ) external pure override returns (address pair) {\n        address _factory = FuniswapLib.factory();\n        pair = FuniswapLib.pairFor(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return FuniswapLib.hasPool(token);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token) external pure override returns (address[] memory) {\n        return FuniswapLib.getPathForETHToToken(token);\n    }\n\n}\n"
    },
    "src/swap/pangolin/PangolinQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./PangolinLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\nimport \"../../access/Controllable.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract PangolinQueryHelper is ISwapQueryHelper, Controllable {\n\n    address private _routerAddress;\n\n    address public constant PANGOLIN_ROUTER_ADDRESS = 0xefa94DE7a4656D787667C749f7E1223D71E9FD88;\n    address public constant FUJI_PANGOLIN_ROUTER_ADDRESS = 0xE4A575550C2b460d2307b82dCd7aFe84AD1484dd;\n\n    constructor() {\n        _routerAddress = PANGOLIN_ROUTER_ADDRESS;\n    }\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n       return PangolinLib.avaxQuote(token, tokenAmount);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = PangolinLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = PangolinLib.WAVAX();\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return PangolinLib.hasPool(token);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB) external view override returns (address pair) {\n        address _factory = PangolinLib.factory();\n        pair = PangolinLib.getPair(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address pair\n    ) external view override returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB) = PangolinLib.getReserves(pair);\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address tokenA,\n        address tokenB\n    ) external pure override returns (address pair) {\n        address _factory = PangolinLib.factory();\n        pair = PangolinLib.pairFor(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token) external pure override returns (address[] memory) {\n        return PangolinLib.getPathForAVAXoToken(token);\n    }\n\n}\n"
    },
    "src/swap/pangolin/PangolinLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\";\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinFactory.sol\";\nimport \"@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinPair.sol\";\n\n/**\n * @dev Uniswap helpers\n */\nlibrary PangolinLib {\n\n    address public constant PANGOLIN_ROUTER_ADDRESS = 0xefa94DE7a4656D787667C749f7E1223D71E9FD88;\n    address public constant FUJI_PANGOLIN_ROUTER_ADDRESS = 0xE4A575550C2b460d2307b82dCd7aFe84AD1484dd;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function avaxQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 avalanche,\n            uint256 tokenReserve,\n            uint256 avaxReserve\n        )\n    {\n        IPangolinRouter uniswapRouter = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS );\n        address _factory = uniswapRouter.factory();\n        address _WAVAX = uniswapRouter.WAVAX();\n        address _pair = IPangolinFactory(_factory).getPair(token, _WAVAX);\n        (tokenReserve, avaxReserve, ) = IPangolinPair(_pair).getReserves();\n        avalanche = quote(tokenAmount, tokenReserve, avaxReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS ).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function WAVAX() external pure returns (address wavax) {\n        wavax = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS ).WAVAX();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IPangolinRouter uniswapRouter = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS );\n        address _factory = uniswapRouter.factory();\n        address _WAVAX = uniswapRouter.WAVAX();\n        address _pair = IPangolinFactory(_factory).getPair(token, _WAVAX);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs wavax\n     */\n    function getPair(address _factory, address tokenA, address tokenB) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair =\n            IPangolinFactory(_factory).getPair(\n                tokenA,\n                tokenB\n            );\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address pair\n    ) external view returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB, ) = IPangolinPair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        _factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        hex\"40231f6b438bce0797c9ada29b718a87ea0a5cea3fe9a771abdd76bd41a3e545\" // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for avalanche to the given token\n     */\n    function getPathForAVAXoToken(address token) external pure returns (address[] memory) {\n        IPangolinRouter uniswapRouter = IPangolinRouter(PANGOLIN_ROUTER_ADDRESS );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = uniswapRouter.WAVAX();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IPangolinRouter {\n    function factory() external pure returns (address);\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountAVAX);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPangolinFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-core/interfaces/IPangolinPair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPangolinPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "src/swap/pancakeswap/PancakeSwapQueryHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./PancakeSwapLib.sol\";\nimport \"../../interfaces/ISwapQueryHelper.sol\";\n\n/**\n * @dev Uniswap helpers\n */\ncontract PancakeSwapQueryHelper is ISwapQueryHelper {\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n       return PancakeSwapLib.coinQuote(token, tokenAmount);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = PancakeSwapLib.factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = PancakeSwapLib.COIN();\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address token) external view override returns (bool) {\n        return PancakeSwapLib.hasPool(token);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address tokenA, address tokenB) external view override returns (address pair) {\n        address _factory = PancakeSwapLib.factory();\n        pair = PancakeSwapLib.getPair(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address pair\n    ) external view override returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB) = PancakeSwapLib.getReserves(pair);\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address tokenA,\n        address tokenB\n    ) external pure override returns (address pair) {\n        address _factory = PancakeSwapLib.factory();\n        pair = PancakeSwapLib.pairFor(_factory, tokenA, tokenB);\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address token) external pure override returns (address[] memory) {\n        return PancakeSwapLib.getPathForCoinToToken(token);\n    }\n\n}\n"
    },
    "src/swap/pancakeswap/PancakeSwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol\";\nimport \"@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakeFactory.sol\";\nimport \"@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol\";\n\n/**\n * @dev pancake helpers\n */\nlibrary PancakeSwapLib {\n\n    address public constant PANCAKE_ROUTER_ADDRESS = 0xBCfCcbde45cE874adCB698cC183deBcF17952812;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address token, uint256 tokenAmount)\n        external\n        view\n        returns (\n            uint256 coin,\n            uint256 tokenReserve,\n            uint256 coinReserve\n        )\n    {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS );\n        address _factory = pancakeRouter.factory();\n        address _COIN = pancakeRouter.WETH();\n        address _pair = IPancakeFactory(_factory).getPair(token, _COIN);\n        (tokenReserve, coinReserve, ) = IPancakePair(_pair).getReserves();\n        coin = quote(tokenAmount, tokenReserve, coinReserve);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure returns (address fac) {\n        fac = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS ).factory();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure returns (address wavax) {\n        wavax = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS ).WETH();\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function hasPool(address token) external view returns (bool) {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS );\n        address _factory = pancakeRouter.factory();\n        address _WAVAX = pancakeRouter.WETH();\n        address _pair = IPancakeFactory(_factory).getPair(token, _WAVAX);\n        return _pair != address(0);\n    }\n\n    /**\n     * @dev looks for a pool vs wavax\n     */\n    function getPair(address _factory, address tokenA, address tokenB) external view returns (address pair) {\n        require(_factory != address(0), \"INVALID_TOKENS\");\n        require(tokenA != address(0) && tokenB != address(0), \"INVALID_TOKENS\");\n        pair =\n            IPancakeFactory(_factory).getPair(\n                tokenA,\n                tokenB\n            );\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address pair\n    ) external view returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB, ) = IPancakePair(pair).getReserves();\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address _factory,\n        address tokenA,\n        address tokenB\n    ) external pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        _factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        hex\"d0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66\" // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Get a path for coin to the given token\n     */\n    function getPathForCoinToToken(address token) external pure returns (address[] memory) {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS );\n        address[] memory path = new address[](2);\n        path[0] = token;\n        path[1] = pancakeRouter.WETH();\n        return path;\n    }\n\n    /**\n     * @dev given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     */\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Price: Price\");\n        require(reserveA > 0 && reserveB > 0, \"Price: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n\n    /**\n     * @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n     */\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"Price: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"Price: ZERO_ADDRESS\");\n    }\n}\n"
    },
    "pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\nimport './IPancakeRouter01.sol';\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
    },
    "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakeFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "pancakeswap-peripheral/contracts/interfaces/IPancakeRouter01.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n"
    },
    "src/swap/mock/MockQueryHelper.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"../../interfaces/ISwapQueryHelper.sol\";\nimport \"../../libs/SafeMath.sol\";\n\n/**\n * @dev Mock helper for local network\n */\ncontract MockQueryHelper is ISwapQueryHelper {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Get a quote in Ethereum for the given ERC20 token / token amount\n     */\n    function coinQuote(address, uint256 tokenAmount)\n        external\n        pure\n        override\n        returns (\n            uint256 ethereum,\n            uint256 tokenReserve,\n            uint256 ethReserve\n        )\n    {\n       return ( tokenAmount.div(10), tokenAmount.mul(200), tokenAmount.mul(20));\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function factory() external pure override returns (address fac) {\n        fac = address(0);\n    }\n\n    /**\n     * @dev does a Uniswap pool exist for this token?\n     */\n    function COIN() external pure override returns (address weth) {\n        weth = address(99);\n    }\n\n    /**\n     * @dev looks for a pool vs weth\n     */\n    function getPair(address, address) external pure override returns (address pair) {\n        pair = address(0);\n    }\n\n    /**\n     * @dev Get the pair reserves given two erc20 tokens\n     */\n    function getReserves(\n        address\n    ) external pure override returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB) = (0, 0);\n    }\n\n    /**\n     * @dev calculate pair address\n     */\n    function pairFor(\n        address,\n        address\n    ) external pure override returns (address pair) {\n        pair = address(0);\n    }\n\n    /**\n     * @dev does token have a pool\n     */\n    function hasPool(address) external pure override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Get a path for ethereum to the given token\n     */\n    function getPathForCoinToToken(address) external pure override returns (address[] memory) {\n        address[] memory _mock;\n        return _mock;\n    }\n\n}\n"
    },
    "src/fees/NFTGemFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interfaces/INFTGemFeeManager.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract NFTGemFeeManager is INFTGemFeeManager {\n    address private operator;\n\n    uint256 private constant MINIMUM_LIQUIDITY = 100;\n    uint256 private constant FEE_DIVISOR = 1000;\n\n    mapping(address => uint256) private feeDivisors;\n    uint256 private _defaultFeeDivisor;\n\n    mapping(address => uint256) private _liquidity;\n    uint256 private _defaultLiquidity;\n\n    /**\n     * @dev constructor\n     */\n    constructor() {\n        _defaultFeeDivisor = FEE_DIVISOR;\n        _defaultLiquidity = MINIMUM_LIQUIDITY;\n    }\n\n    /**\n     * @dev Set the address allowed to mint and burn\n     */\n    receive() external payable {\n        //\n    }\n\n    /**\n     * @dev Set the address allowed to mint and burn\n     */\n    function setOperator(address _operator) external {\n        require(operator == address(0), \"IMMUTABLE\");\n        operator = _operator;\n    }\n\n    /**\n     * @dev Get the fee divisor for the specified token\n     */\n    function liquidity(address token) external view override returns (uint256) {\n        return _liquidity[token] != 0 ? _liquidity[token] : _defaultLiquidity;\n    }\n\n    /**\n     * @dev Get the fee divisor for the specified token\n     */\n    function defaultLiquidity() external view override returns (uint256 multiplier) {\n        return _defaultLiquidity;\n    }\n\n    /**\n     * @dev Set the fee divisor for the specified token\n     */\n    function setDefaultLiquidity(uint256 _liquidityMult) external override returns (uint256 oldLiquidity) {\n        require(operator == msg.sender, \"UNAUTHORIZED\");\n        require(_liquidityMult != 0, \"INVALID\");\n        oldLiquidity = _defaultLiquidity;\n        _defaultLiquidity = _liquidityMult;\n        emit LiquidityChanged(operator, oldLiquidity, _defaultLiquidity);\n    }\n\n    /**\n     * @dev Get the fee divisor for the specified token\n     */\n    function feeDivisor(address token) external view override returns (uint256 divisor) {\n        divisor = feeDivisors[token];\n        divisor = divisor == 0 ? FEE_DIVISOR : divisor;\n    }\n\n    /**\n     * @dev Get the fee divisor for the specified token\n     */\n    function defaultFeeDivisor() external view override returns (uint256 multiplier) {\n        return _defaultFeeDivisor;\n    }\n\n    /**\n     * @dev Set the fee divisor for the specified token\n     */\n    function setDefaultFeeDivisor(uint256 _feeDivisor) external override returns (uint256 oldDivisor) {\n        require(operator == msg.sender, \"UNAUTHORIZED\");\n        require(_feeDivisor != 0, \"DIVISIONBYZERO\");\n        oldDivisor = _defaultFeeDivisor;\n        _defaultFeeDivisor = _feeDivisor;\n        emit DefaultFeeDivisorChanged(operator, oldDivisor, _defaultFeeDivisor);\n    }\n\n    /**\n     * @dev Set the fee divisor for the specified token\n     */\n    function setFeeDivisor(address token, uint256 _feeDivisor) external override returns (uint256 oldDivisor) {\n        require(operator == msg.sender, \"UNAUTHORIZED\");\n        require(_feeDivisor != 0, \"DIVISIONBYZERO\");\n        oldDivisor = feeDivisors[token];\n        feeDivisors[token] = _feeDivisor;\n        emit FeeDivisorChanged(operator, token, oldDivisor, _feeDivisor);\n    }\n\n    /**\n     * @dev get the ETH balance of this fee manager\n     */\n    function ethBalanceOf() external view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev get the token balance of this fee manager\n     */\n    function balanceOF(address token) external view override returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n\n    /**\n     * @dev transfer ETH from this contract to the to given recipient\n     */\n    function transferEth(address payable recipient, uint256 amount) external override {\n        require(operator == msg.sender, \"UNAUTHORIZED\");\n        require(address(this).balance >= amount, \"INSUFFICIENT_BALANCE\");\n        recipient.transfer(amount);\n    }\n\n    /**\n     * @dev transfer tokens from this contract to the to given recipient\n     */\n    function transferToken(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external override {\n        require(operator == msg.sender, \"UNAUTHORIZED\");\n        require(IERC20(token).balanceOf(address(this)) >= amount, \"INSUFFICIENT_BALANCE\");\n        IERC20(token).transfer(recipient, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}